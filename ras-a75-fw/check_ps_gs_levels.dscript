
//
//  Copyright (C) 2021-2030 Laurent Ravera, IRAP Toulouse.
//  This file is part of the ATHENA X-IFU DRE test driving software.
//
//  ras-js is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.

//  laurent.ravera@irap.omp.eu
//  File name: check_ps_gs_levels.dscript
//  Purpose: This script scans the PS0 and GS0 outputs over the full 
//           scale range in order to verify the requirement XIFU-DRE-R-0160

include("./ras_tools.dscript")
include("./default_configurations.dscript")

print("#------------------------------------------------------")
testDate = maDate();

// Definition of some information that can be writen in a log file
operator_name=get_operator_name();
print(" Operator name: ", operator_name)
print(" Date: ", testDate)
session_name=get_session_name();
print(" Session name: ",  session_name)
session_comment = "No comment";
print(" Comment: ", session_comment)
print_board_and_fw_id();
print("#------------------------------------------------------")

//---------------------------------------------------------------------------------------
// Timing configuration
// Fmasterclock=125MHz, period=8ns
lineperiod = 20; // corresponds to 160ns
delay = 0;
overlap = 0;


//---------------------------------------------------------------------------------------
// Levels configuration
// (1 ADU corresponds approximately to 1mV)
//    0x0D5 corresponds to 210mV
//    0x14A corresponds to 325mV (Phi0/2)
level_min = 0x0000;
level_max = DAC_MAX_RATING;
pixel_on_lvl = level_max; 
pixel_off_lvl = level_min;
group_on_lvl = level_max;
group_off_lvl = level_min;


//---------------------------------------------------------------------------------------
// Sequence configuration
// Configuring a 2-level 8-pixel long sequence

nbrows = 8;
seq = seqIncrementalIRAP2levels_short();
syncseq = 0x00000001;


//---------------------------------------------------------------------------------------
// Sending the parameters to the firmware
configure_ras(nbrows, lineperiod, delay, overlap, seq, syncseq, pixel_off_lvl, pixel_on_lvl, group_off_lvl, group_on_lvl);

print("#------------------------------------------------------")
print("# Measuring row address levels")

//---------------------------------------------------------------------------------------
// RAS levels min/max measurements

pixel_min = getText("Please measure the level min of row addresses (mV):", "")
pixel_max = getText("Please measure the level max of row addresses (mV):", "")
print("")
print("# Row adresses:")
print(" Level min = ", pixel_min, "mV and level max = ", pixel_max, " mV.")
print(" Range = ", pixel_max - pixel_min, " mV")
print("")

group_min = getText("Please measure the level min of cluster addresses (mV):", "")
group_max = getText("Please measure the level max of cluster addresses (mV):", "")
print("")
print("# Cluster adresses:")
print(" Level min = ", group_min, "mV and level max = ", group_max, " mV.")
print(" Range = ", group_max - group_min, " mV")
print("")


alert("Ready to see ramps on the address levels?:")
print("#------------------------------------------------------")
print(" Scanning the ON and OFF levels of row and cluster addresses...")

//---------------------------------------------------------------------------------------
// RAS ramps / resolution

wait_duration = 50
step_size = 16 // With step = 16 the number of steps over FSR is 2^8 (compliant with requirement)

// Scan to change high to low and low high
for (level = level_min; level < level_max; level+= step_size)
{
	set_mode(MODE_DEF);
	stop_dacs();
	set_dac(DAC_PIXEL_OFF, level);
	set_dac(DAC_GROUP_OFF, level);
	set_dac(DAC_PIXEL_ON, level_max-level);
	set_dac(DAC_GROUP_ON, level_max-level);
	start_dacs();
	set_mode(MODE_RUN)
}

// Scan to go back to the initial setting
for (level = level_max; level > 0; level-= step_size)
{
	set_mode(MODE_DEF);
	stop_dacs();
	set_dac(DAC_PIXEL_OFF, level);
	set_dac(DAC_GROUP_OFF, level);
	set_dac(DAC_PIXEL_ON, level_max-level);
	set_dac(DAC_GROUP_ON, level_max-level);
	start_dacs();
	set_mode(MODE_RUN)
}

possible_answers = ["correct", "not correct"]
answer = getItem("The scanning of the address levels was ", possible_answers)
print("The scanning of the address levels was ", possible_answers[answer])

print("#------------------------------------------------------")
print("# End of test")
print("#------------------------------------------------------")
saveLogContent("report_"+testDate+".txt")

//---------------------------------------------------------------------------------------