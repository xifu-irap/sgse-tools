// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   amc7823.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//   This script defines base functions to access (read/write) the AMC device (FMC150 card) via the FPASim SPI module bridge.
//
//
//    Note:
//       . Tested with javascript
//
// -------------------------------------------------------------------------------------------------------------

// import libraries
include("./fpasim/utils_tools.dscript");
include("./fpasim/fpasim.dscript");

// define the SPI device registers (see datasheet: amc7823 device)
const AMC_ADDR = {};
AMC_ADDR['reg0'] = 0x00;
AMC_ADDR['reg1'] = 0x01;
AMC_ADDR['reg2'] = 0x02;
AMC_ADDR['reg3'] = 0x03;
AMC_ADDR['reg4'] = 0x04;
AMC_ADDR['reg5'] = 0x05;
AMC_ADDR['reg6'] = 0x06;
AMC_ADDR['reg7'] = 0x07;
AMC_ADDR['reg8'] = 0x08;
AMC_ADDR['reg9'] = 0x09;
AMC_ADDR['reg10'] = 0x0A;
AMC_ADDR['reg11'] = 0x0B;
AMC_ADDR['reg12'] = 0x0C;
AMC_ADDR['reg13'] = 0x0D;
AMC_ADDR['reg14'] = 0x0E;
AMC_ADDR['reg15'] = 0x0F;
AMC_ADDR['reg16'] = 0x10;
AMC_ADDR['reg17'] = 0x11;
AMC_ADDR['reg18'] = 0x12;
AMC_ADDR['reg19'] = 0x13;
AMC_ADDR['reg20'] = 0x14;
AMC_ADDR['reg21'] = 0x15;
AMC_ADDR['reg22'] = 0x16;
AMC_ADDR['reg23'] = 0x17;
AMC_ADDR['reg24'] = 0x18;
AMC_ADDR['reg25'] = 0x19;
AMC_ADDR['reg26'] = 0x1A;
AMC_ADDR['reg27'] = 0x1B;
AMC_ADDR['reg28'] = 0x1C;
AMC_ADDR['reg29'] = 0x1D;
AMC_ADDR['reg30'] = 0x1E;
AMC_ADDR['reg31'] = 0x1F;

// verbosity min to display register access
const c_AMC_REG_VERBOSITY_MIN = 0;
// verbosity min to display (addr,data)
const c_AMC_ADDR_VERBOSITY_MIN = 1;
// verbosity min to display register bit
const c_AMC_BIT_VERBOSITY_MIN = 2;

// address width of the spi device register
const c_AMC_SPI_ADDR_WIDTH = 16;
// data width of the spi device register
const c_AMC_SPI_DATA_WIDTH = 16;


/**
 * Enable the FPASIM SPI MODULE (bridge)
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */

function amc_spi_enable(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    //---------------------------------------------------------------------
    //-- write in the SPI_CTRL register
    //---------------------------------------------------------------------

    // en the spi links
    const rst = 0;
    const en = 1;
    fpasim_set_spi_ctrl(rst, en, level0, mode_p, verbosity_p);


}

/**
 * Write a spi device register through the FPASIM SPI MODULE (bridge).
 *
 * @param {number} addr_p - register address of the SPI device to write.
 * @param {number} data_p - value to write in the spi device register.
 * @param {number} page_p - page index.
 */
function amc_write_command(addr_p, data_p, page_p) {

    //---------------------------------------------------------------------
    // write in the SPI_CONF0 register
    //---------------------------------------------------------------------
    const spi_mode = 1; // 0: rd, 1: wr
    const spi_id = 3; // 0: cdce,1: adc, 2: dac, 3: amc
    fpasim_set_spi_conf0(spi_id, spi_mode, 0, 0, -1);

    //---------------------------------------------------------------------
    // build the SPI commands
    //    (see amc7823 datasheet)
    //---------------------------------------------------------------------
    const mode = 0; // 0:wr, 1:rd
    const page = page_p // 0: page0, 1: page1
    const start_addr = addr_p // start address: 5 bits
    const end_addr = 0x00

    const spi_cmd = (mode << 15) + (page << 12) + (start_addr << 6) + (end_addr);
    // MSB send first
    //  spi_cmd[15:0]
    //  spi_data[15:0]
    const spi_data = (spi_cmd << 16) + data_p;

    fpasim_set_spi_wr_data(spi_data, 0, 0, -1);

}

/**
 * Read a spi device register value.
 *
 * @param {number} addr_p - register address of the SPI device to read.
 * @param {number} page_p - page index.
 * @return {number} read value from the spi device register.
 *
 */
function amc_read_command(addr_p, page_p) {

    //---------------------------------------------------------------------
    // write in the SPI_CONF0 register
    //---------------------------------------------------------------------
    const spi_mode = 0; // 0: rd, 1: wr
    const spi_id = 3; // 0: cdce,1: adc, 2: dac, 3: amc
    fpasim_set_spi_conf0(spi_id, spi_mode, 0, 0, -1);

    //---------------------------------------------------------------------
    // build and write the SPI commands
    //    (see amc7823 datasheet)
    //---------------------------------------------------------------------
    const mode = 1; // 0:wr, 1:rd
    const page = page_p // 0: page0, 1: page1
    const start_addr = addr_p // start address: 5 bits
    const end_addr = 0x00

    const spi_cmd = (mode << 15) + (page << 12) + (start_addr << 6) + (end_addr);
    // MSB send first
    //  spi_cmd[15:0]
    //  spi_data[15:0]
    const spi_data = (spi_cmd << 16) + 0x0000;
    fpasim_set_spi_wr_data(spi_data, 0, 0, -1);
    waitMs(10);

    //---------------------------------------------------------------------
    // Read the register value from the spi device
    //---------------------------------------------------------------------
    const data = fpasim_get_wireout_spi_rd_data(0, 0, -1);

    // keep only the data part
    // from: cmd15 .. cmd0 data15 .. data0
    // to: data15.. data0
    data = (data & 0xFFFF);
    return data;

}

/**
 * Set the amc_set_gpio register.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [11:08]: R/W: iomod_p[3:0]
 *     . IOMOD-n = 0: Analog input out-of-range detection mode. In this mode, GPIO-n (n = 0, 1, 2, 3) work as
 *          analog input out-of-range indicators, denoted as output pins ALR-n. The status of each pin
 *          ALR-n is set by bit ALR-n of the ALR Register. The ALR-n pin is low when the
 *          corresponding ALR-n bit is '1', and is high-impedance when ALR-n is '0'.
 *     . IOMOD-n = 1: GPIO mode. In this mode, pin GPIO-n works as general digital I/O (bidirectional). When
 *          the pin is output, the status is determined by the corresponding bit IOST-n; it is highimpedance
 *          for IOST-n = 1, and logic low for IOST-n = 0. When the pin is input, reading
 *          this bit acquires the digital logic value present at the pin. GPIO data are preserved during
 *          all power-down conditions.
 *  [05:00]: R/W: iost_p[5:0]:
 *       I/O STATUS bit of the GPIO-n pin. If the GPIO-n pin works as a general-purpose I/O, this
 *      bit indicates the actual logic value present at the pin when reading the bit. It also sets the
 *      state of the corresponding GPIO-n pin (high-impedance for IOST-n = 1, logic low for
 *      IOST-n = 0) when writing to the bit. An external pull-up resistor is required when using pin
 *      GPIO-n as an output.
 *      If the GPIO-n pin works as an analog input out-of-range indicator, then bit IOST-n is a
 *      complement of the corresponding bit ALR-n in the ALR Register. Writing the IOST-n bit
 *      does not cause any change. Note that only GPIO-0, GPIO-1, GPIO-2, and GPIO-3 can be
 *      configured as out-of-range indicators.
 *      44 Submit Documentation Feedback Copyright © 2005–2012, Texas Instruments Incorporated
 *      Product Folder Link(s): AMC7823
 *      AMC7823
 *      www.ti.com SLAS453F –APRIL 2005–REVISED MARCH 2012
 *      To avoid loss of alarm information in bits IOST-n during power-down of the ADC, change to direct conversion
 *      mode (see ADC Control Register) before power-down and do not issue a convert command while the ADC is
 *      powered down.
 */
function amc_set_gpio(iomod_p, iost_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;


    const data1 = (parseInt('1111', 2) << 12) + (parseInt('11', 2) << 6);
    const data0 = (iomod_p << 8) + iost_p;

    const data = data1 + data0;
    const page = 0;

    const addr = AMC_ADDR['reg10'];
    amc_write_command(addr, data, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_set_gpio]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("iomod_p", iomod_p, 4, level2, mode_p);
            display_bit("iost_p", iost_p, 6, level2, mode_p);
        }
    }
}

/**
 * Set the dac(s) register.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [14:12]: R/W: och_p[2:0]
 *      . DAC Address. Read-only. Writing these bits does not cause any change.
 *  [11:0]: R/W: dac_p[11:0]:
 *       . In a write operation, these data bits are written into the DAC Data-n Register. However, in
 *         (WRITE/READ) a read operation, the data bits are returned from the DAC-n Latch, not from the DAC-n
 *         Data Register
 *  dac_id_p: (0 to 7)
 *
 */
function amc_set_dac(dac_p, dac_id_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data0 = dac_p;

    const data = data0;
    const page = 1;

    switch (dac_id_p) {
        case 0:
            addr = AMC_ADDR['reg0'];
            break;
        case 1:
            addr = AMC_ADDR['reg1'];
            break;
        case 2:
            addr = AMC_ADDR['reg2'];
            break;
        case 3:
            addr = AMC_ADDR['reg3'];
            break;
        case 4:
            addr = AMC_ADDR['reg4'];
            break;
        case 5:
            addr = AMC_ADDR['reg5'];
            break;
        case 6:
            addr = AMC_ADDR['reg6'];
            break;
        default: // dac_id_p == 6
            addr = AMC_ADDR['reg7'];
            break;
    }

    amc_write_command(addr, data, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_set_dac" + dac_id_p.toString(16) + "]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("dac_p", data, 12, level2, mode_p);
        }
    }

}


/**
 * Set the dac_load register.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [15:00]: value_p[15:00] = 0xBB00
 *    The data word 0xBB00 (shown above) written into the LOAD DAC Register generates ILDAC, the internal load
 *    DAC signal. ILDAC and the external ELDAC signal work in a similar manner. ILDAC shifts data from the DAC-n
 *    Data register to the DAC-n Latch and updates the output for all DAC-n with the corresponding SLDA-n bit set to
 *    '1'. Other codes written to this register do not generate ILDAC and have no impact on any DAC-n. The LOAD
 *    DAC Register is cleared after ILDAC is generated. The register is also cleared after power-on or reset.
 *
 */
function amc_set_dac_load(level_p, mode_p, verbosity_p) {


    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data0 = 0xBB00;

    const data = data0;
    const page = 1


    const addr = AMC_ADDR['reg8'];
    amc_write_command(addr, data, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_set_dac_load]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("load_dac_p", data, 16, level2, mode_p);
        }
    }
}

/**
 * Set the dac_conf register.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [15:8]: R/W: slda_p[7:0]
 *     DAC Synchronous Load Enable bit.
 *    SLDA-n = '1': Synchronous Load enabled. When the synchronous load DAC signal occurs, DAC-n
 *    Latch is loaded with the value of the corresponding DAC-n Data Register, and the output of DACn
 *    is updated immediately. This load signal can be the rising edge of the external signal ELDAC or
 *    the internal load signal ILDAC. Writing the data word 0xBB00 into the LOAD DAC Register
 *    generates ILDAC. A write command to the DAC-n Data Register updates that register only, and
 *    does not change the DAC-n output.
 *    SLDA-n = '0': Asynchronous Load enabled. A write command to the DAC-n Data Register
 *    immediately updates DAC-n Latch and the output of DAC-n. The synchronous load DAC signal
 *    (ILDAC or ELDAC) does not affect DAC-n.
 *  [7:0]: R/W: gdac_p[7:0]
 *    DAC-n Output Buffer Amplifier Gain bit.
 *    GDAC-n = '1': The gain of the DAC-n output buffer amplifier is equal to 2.
 *    GDAC-n = '0': The gain of the DAC-n output buffer amplifier is equal to 1.
 */
function amc_set_dac_conf(slda_p, gdac_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data0 = (slda_p << 8) + gdac_p;

    const data = data0;
    const page = 1;

    const addr = AMC_ADDR['reg9'];
    amc_write_command(addr, data, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_set_dac_conf]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("gdac_p", gdac_p, 8, level2, mode_p);
            display_bit("slda_p", slda_p, 8, level2, mode_p);
        }
    }

}
/**
 * Set the amc_set_amc_status_conf register.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [14]: R/W: rstc_p[0]
 *     RESET Complete Bit. This bit is set to '1' on power-up or reset. This bit can be cleared by writing
 *     '0' to this location. The host cannot set this bit to '1'. This bit allows the host to determine if the
 *     part has been configured after power-up, or if a reset has occurred to the AMC7823 without
 *     knowledge of the host.
 *  [13]: R/W: davf_p[0]
 *     ADC Data Available Flag. For direct-mode only. Always cleared (set to '0') in auto-mode (see ADC
 *    Control Register).
 *    DAVF = 1: The ADC conversions are complete and new data are available.
 *    DAVF = 0: The ADC conversion is in progress (data is not ready) or the ADC is in Auto-Mode.
 *    In direct-mode, bit DAVF sets the pin DAV. DAV goes low when DAVF = 1, and goes high when
 *    DAVF = 0. In auto-mode, DAVF is always cleared to '0'. However, a 2μs pulse (active low)
 *    appears on the DAV pin when the input with ending address [EA3:EA0] is converted. DAVF is
 *    cleared to '0' in one of three ways: (1) reading the ADC Data Register; (2) starting a new ADC
 *    conversion; or (3) writing '0' to this bit.
 *  [7]: R/W: sref_p[0]
 *     Select Reference bit.
 *     SREF = 0 (default condition): The internal reference is selected as the chip reference. It is
 *     connected to pin 21, EXT_REF_IN, by a 10kΩ resistor.
 *     SREF = 1: The internal reference is de-selected and disconnected from pin 21 (EXT_REF_IN).
 *     Pin 21 floats unless an external reference is applied. Always set SREF bit to '1' when an external
 *     reference is applied; otherwise, the external reference must sink or source current. The current
 *     value is the voltage difference between the external and internal reference divided by a 10kΩ
 *     resistance.
 *     SREF also provides information to the precision current source and is used to configure that
 *     source (see the Precision Current Source section for details). After power-on or reset, SREF is
 *     cleared to '0'.
 *  [6]: R/W: gref_p[0]
 *    Gain of the internal reference voltage (VREF). This bit selects one of two preset values for the
 *    internal reference voltage, but has no effect on the external reference. GREF also provides
 *    information to the precision current source and is used to configure that source (see the Precision
 *    Current Source section for details).
 *    GREF = 0: The internal reference voltage is +1.25V.
 *    GREF = 1: The internal reference voltage is +2.5V.
 *    When an external reference is used and SREF is set to '1', GREF has no impact on the reference.
 *    However, if SREF is cleared to '0', a 10kΩ resistor is connected between pin 21, EXT_REF_IN,
 *    and one of the two internal reference values dictated by the value of GREF. In this case, the
 *    external reference must be able to drive the 10kΩ load. The full-scale range of the ADC input is
 *    equal to 2 x VREF. To avoid ADC input saturation, GREF must be cleared to '0' when AVDD is less
 *    than +5V and the internal reference is used. After power-on or reset, GREF is cleared to '0'.
 *    Table 9 specifies the ADC input range as a function of bits GREF and SREF.
 *  [5]: R/W: ecnvt_p[0]
 *    Enable CONVERT (external conversion trigger). This bit specifies the ADC trigger mode. When
 *    ECNVT = '1', CONVERT is enabled. The ADC is in external trigger mode. The low-to-high
 *    transition of the external trigger signal CONVERT triggers the ADC conversions. A write command
 *    to the ADC Control Register does not initiate conversion, but rather specifies the group of inputs
 *    to convert. After triggered by CONVERT, the AMC7823 sequentially accesses each analog input
 *    one time. The bits [SA3:SA0] of the ADC Control Register comprise the channel address of the
 *    first analog input accessed; [EA3:EA0] is the last analog input accessed. When the conversion
 *    finishes, the ADC is idle and waits for a new CONVERT or a new command. With an external
 *    trigger, the ADC always works in direct-mode (see the ADC Control Register section).
 *    When ECNVT = '0', CONVERT is disabled. The internal ADC trigger is used. A write command to
 *    the ADC Control Register generates the internal trigger and initiates ADC conversion. With an
 *    internal trigger, the ADC can work in either direct-mode or auto-mode (see the ADC Operation
 *    and ADC Control Register sections). Table 10 summarizes the ADC conversion mode
 *    configuration.
 *    After power-on or reset, DAVF, SREF, GREF, and ECNVT are cleared to '0'; RSTC is set to '1'.
 */
function amc_set_amc_status_conf(rstc_p, davf_p, sref_p, gref_p, ecnvt_p, level_p, mode_p, verbosity_p) {


    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = (rstc_p << 14) + (davf_p << 13);
    const data0 = (sref_p << 7) + (gref_p << 6) + (ecnvt_p << 5);

    const data = data1 + data0;
    const page = 1;

    const addr = AMC_ADDR['reg10'];
    amc_write_command(addr, data, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_set_dac_conf]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("rstc_p", rstc_p, 1, level2, mode_p);
            display_bit("davf_p", davf_p, 1, level2, mode_p);
            display_bit("sref_p", sref_p, 1, level2, mode_p);
            display_bit("gref_p", gref_p, 1, level2, mode_p);
            display_bit("ecnvt_p", ecnvt_p, 1, level2, mode_p);
        }
    }
}

/**
 * Set the amc_set_adc_ctrl register.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [15]: R/W: cmode_p[0]
 *    ADC Conversion Mode bit. This bit selects between the two operating conversion modes (direct
 *    or auto) when the Internal trigger is active. This bit is always cleared to '0' (direct-mode) when an
 *    external trigger is active.
 *    CMODE = '0': Direct-mode. The analog inputs from [SA3:SA0] to [EA3:EA0] are converted
 *    sequentially (see Table 12) one time, [SA3:SA0] first and [EA3;EA0] last. When one set of
 *    conversions is complete, the ADC is idle and waits for a new trigger. The external trigger is
 *    restricted to this mode of operation only.
 *    CMODE = '1': Auto-mode. The analog inputs from [SA3:SA0] to [EA3:EA0] are converted
 *    sequentially (see Table 12) and repeatedly, [SA3:SA0] first and [EA3;EA0] last. When one set of
 *    conversions is complete, the ADC multiplexer returns to the starting address [SA3:SA0] and
 *    repeats the process. Repetitive conversions continue until auto-mode is halted by rewriting the
 *    ADC Control Register to direct
 *  [11:8]: R/W: sa_p[3:0]:
 *    The channel address of the first analog input to be converted (see Table 12).
 *  [7:4]: R/W: ea_p[3:0]
 *    The channel address of the last analog input to be converted (see Table 12).
 */
function amc_set_adc_ctrl(cmode_p, sa_p, ea_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = (cmode_p << 15) + (sa_p << 8);
    const data0 = (ea_p << 4);

    const data = data1 + data0;
    const page = 1;

    const addr = AMC_ADDR['reg11'];
    amc_write_command(addr, data, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_set_adc_ctrl]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("cmode_p", cmode_p, 1, level2, mode_p);
            display_bit("sa_p", sa_p, 4, level2, mode_p);
            display_bit("ea_p", ea_p, 4, level2, mode_p);
        }
    }
}

/**
 * Set the amc_set_reset register.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * [15:0]: value_p[15:0]: 0xBB30
 *    The AMC7823 has a special RESET Register that performs the software equivalent function of the device
 *    RESET pin. To invoke a system reset, write the data word 0xBB3X to this register. Only the upper 12 bits are
 *    significant; the lowest four bits are Don’t Care.
 */
function amc_set_reset(level_p, mode_p, verbosity_p) {


    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data0 = 0xBB30;

    const data = data0;
    const page = 1;

    const addr = AMC_ADDR['reg12'];
    amc_write_command(addr, data, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_set_reset]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("reset_p", data, 16, level2, mode_p);
        }
    }
}

/*
 * Set the amc_set_power_down register.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [15]: R/W: padc_p[0]
 *     ADC power-down control bit.
 *    PADC = '0': The ADC is in power-down mode and ADC conversion is halted.
 *    PADC = '1': The ADC is in normal operating mode.
 *  [14:7]: R/W: pdac_p[7:0]
 *     PDAC-n = '0': DAC-n output buffer amplifier is in power-down mode. The output pin
 *    of DAC-n is internally switched from the buffer output to analog ground through an
 *    internal 5kΩ resistor. Each DAC output buffer may be independently powered down.
 *    (See the DAC Operation section for details.)
 *    PDAC-n = '1' and PREFB = '1': DAC-n is in normal operating mode.
 *  [6]: R/W: pts_p[0]
 *     Precision current source power-down control bit.
 *    PTS = '0': Precision current source is in power-down mode and the current output is
 *    zero.
 *    PTS = '1': Precision current source is in normal operating mode (see the Precision
 *    Current Source section for details).
 *  [5]: R/W: prefb_p[0]
 *     Reference buffer amplifier power-down control bit. This bit controls the power-down
 *    condition of the amplifier that supplies a buffered reference voltage to all DAC-n
 *    resistor strings and to the precision current source. This bit also provides
 *    configuration information to the precision current source (see the Precision Current
 *    Source Configuration table, Table 7).
 *    PREFB = '0': Reference buffer amplifier is in power-down mode. All DACs are
 *    inoperative. The precision current source may be used only if GREF = '0' (see the
 *    Precision Current Source Configuration table, Table 7).
 *    PREFB = '1': Reference buffer amplifier is powered on. This mode is required for
 *    any DAC-n operation. The precision current source may be used with either value of
 *    GREF.
 */
function amc_set_power_down(padc_p, pdac_p, pts_p, prefb_p, level_p, mode_p, verbosity_p) {


    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;


    const data1 = (padc_p << 15) + (pdac_p << 7);
    const data0 = (pts_p << 6) + (prefb_p << 5);

    const data = data1 + data0;
    const page = 1;


    const addr = AMC_ADDR['reg13'];
    amc_write_command(addr, data, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_set_power_down]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("padc_p", padc_p, 16, level2, mode_p);
            display_bit("pdac_p", pdac_p, 8, level2, mode_p);
            display_bit("pts_p", pts_p, 1, level2, mode_p);
            display_bit("prefb_p", prefb_p, 1, level2, mode_p);
        }
    }
}

/*
 * Set the amc_set_threshold_hi register.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [11:0]: R/W: threshold_p[11:0]
 *    Data bits of the upper bound threshold of the nth analog input. All bits are set to '1'
 *    after power-on or reset.
 *  threshold_id_p (0 to 3)
 */
function amc_set_threshold_hi(threshold_p, threshold_id_p, level_p, mode_p, verbosity_p) {


    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data0 = threshold_p;

    const data = data0;
    const page = 1;
    switch (threshold_id_p) {

        case 0:
            addr = AMC_ADDR['reg14'];
            break;
        case 1:
            addr = AMC_ADDR['reg16'];
            break;
        case 2:
            addr = AMC_ADDR['reg18'];
            break;
        default: // threshold_id = 3
            addr = AMC_ADDR['reg20'];
            break;
    }

    amc_write_command(addr, data, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_set_threshold_hi" + threshold_id_p.toString(16) + "]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("threshold_hi_p", threshold_p, 12, level2, mode_p);
        }
    }
}

/**
 * Set the amc_set_threshold_lo register.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [11:0]: R/W: threshold_p[11:0]
 *     Data bits of the lower bound threshold of the nth analog input. This register is
 *    cleared to '0' after power-on or reset.
 *  threshold_id_p (0 to 3)
 */
function amc_set_threshold_lo(threshold_p, threshold_id_p, level_p, mode_p, verbosity_p) {


    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data0 = threshold_p;

    const data = data0;
    const page = 1;
    switch (threshold_id_p) {

        case 0:
            addr = AMC_ADDR['reg15'];
            break;
        case 1:
            addr = AMC_ADDR['reg17'];
            break;
        case 2:
            addr = AMC_ADDR['reg19'];
            break;
        default: // threshold_id = 3
            addr = AMC_ADDR['reg21'];
            break;
    }

    amc_write_command(addr, data, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_set_threshold_lo" + threshold_id_p.toString(16) + "]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("threshold_lo_p", threshold_p, 12, level2, mode_p);
        }
    }



}

/**
 * Get the amc_get_adc0 register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:12]: ich_p[3:0]
 *    Analog Input Channel number
 *  [11:00]: adc_p[11:0]
 *     Value of the conversion result. The data are updated when the conversion of the input
 *    [EA3:EA0] finishes; see the ADC Operation section for details.
 */
function amc_get_adc0(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;
    // see the fmc150-user-manual.pdf (page 15)
    const text = "(3.3V analog)"
    const factor = 2.0;

    const addr = AMC_ADDR['reg0'];
    const data0 = amc_read_command(addr, page);
    const data = factor * data0;

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_adc0]: Get the register value " + text;
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("ich_p", 12, 4, data, level2, mode_p);
            display_bit_from_data("adc_p", 0, 12, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_adc1 register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:12]: ich_p[3:0]
 *    Analog Input Channel number
 *  [11:00]: adc_p[11:0]
 *     Value of the conversion result. The data are updated when the conversion of the input
 *    [EA3:EA0] finishes; see the ADC Operation section for details.
 */
function amc_get_adc1(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;
    // see the fmc150-user-manual.pdf (page 15)
    const text = "(3.3V clock)"
    const factor = 2.0;

    const addr = AMC_ADDR['reg1'];
    const data0 = amc_read_command(addr, page);
    const data = factor * data0;

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_adc1]: Get the register value " + text;
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("ich_p", 12, 4, data, level2, mode_p);
            display_bit_from_data("adc_p", 0, 12, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_adc2 register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:12]: ich_p[3:0]
 *    Analog Input Channel number
 *  [11:00]: adc_p[11:0]
 *     Value of the conversion result. The data are updated when the conversion of the input
 *    [EA3:EA0] finishes; see the ADC Operation section for details.
 */
function amc_get_adc2(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;
    // see the fmc150-user-manual.pdf (page 15)
    const text = "(1.8V Analog)"
    const factor = 1.0;

    const addr = AMC_ADDR['reg2'];
    const data0 = amc_read_command(addr, page);
    const data = factor * data0;

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_adc2]: Get the register value " + text;
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("ich_p", 12, 4, data, level2, mode_p);
            display_bit_from_data("adc_p", 0, 12, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_adc3 register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:12]: ich_p[3:0]
 *    Analog Input Channel number
 *  [11:00]: adc_p[11:0]
 *     Value of the conversion result. The data are updated when the conversion of the input
 *    [EA3:EA0] finishes; see the ADC Operation section for details.
 */
function amc_get_adc3(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;
    // see the fmc150-user-manual.pdf (page 15)
    const text = "(1.8V Digital)"
    const factor = 1.0;

    const addr = AMC_ADDR['reg3'];
    const data0 = amc_read_command(addr, page);
    const data = factor * data0;

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_adc3]: Get the register value " + text;
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("ich_p", 12, 4, data, level2, mode_p);
            display_bit_from_data("adc_p", 0, 12, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_adc4 register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:12]: ich_p[3:0]
 *    Analog Input Channel number
 *  [11:00]: adc_p[11:0]
 *     Value of the conversion result. The data are updated when the conversion of the input
 *    [EA3:EA0] finishes; see the ADC Operation section for details.
 */
function amc_get_adc4(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;
    // see the fmc150-user-manual.pdf (page 15)
    const text = "(12V)";
    const factor = 5.7;

    const addr = AMC_ADDR['reg4'];
    const data0 = amc_read_command(addr, page);
    const data = factor * data0;

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_adc4]: Get the register value " + text;
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("ich_p", 12, 4, data, level2, mode_p);
            display_bit_from_data("adc_p", 0, 12, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_adc5 register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:12]: ich_p[3:0]
 *    Analog Input Channel number
 *  [11:00]: adc_p[11:0]
 *     Value of the conversion result. The data are updated when the conversion of the input
 *    [EA3:EA0] finishes; see the ADC Operation section for details.
 */
function amc_get_adc5(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;
    // see the fmc150-user-manual.pdf (page 15)
    const text = "(3.3V)";
    const factor = 2.0;

    const addr = AMC_ADDR['reg5'];
    const data0 = amc_read_command(addr, page);
    const data = factor * data0;

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_adc5]: Get the register value " + text;
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("ich_p", 12, 4, data, level2, mode_p);
            display_bit_from_data("adc_p", 0, 12, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_adc6 register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:12]: ich_p[3:0]
 *    Analog Input Channel number
 *  [11:00]: adc_p[11:0]
 *     Value of the conversion result. The data are updated when the conversion of the input
 *    [EA3:EA0] finishes; see the ADC Operation section for details.
 */
function amc_get_adc6(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;
    // see the fmc150-user-manual.pdf (page 15)
    const text = "VADJ";
    const factor = 2.0;

    const addr = AMC_ADDR['reg6'];
    const data0 = amc_read_command(addr, page);
    const data = factor * data0;

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_adc6]: Get the register value " + text;
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("ich_p", 12, 4, data, level2, mode_p);
            display_bit_from_data("adc_p", 0, 12, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_adc7 register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:12]: ich_p[3:0]
 *    Analog Input Channel number
 *  [11:00]: adc_p[11:0]
 *     Value of the conversion result. The data are updated when the conversion of the input
 *    [EA3:EA0] finishes; see the ADC Operation section for details.
 */
function amc_get_adc7(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;
    // see the fmc150-user-manual.pdf (page 15)
    const text = "3.8V";
    const factor = 2.0;

    const addr = AMC_ADDR['reg7'];
    const data0 = amc_read_command(addr, page);
    const data = factor * data0;

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_adc7]: Get the register value " + text;
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("ich_p", 12, 4, data, level2, mode_p);
            display_bit_from_data("adc_p", 0, 12, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_adc8 register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:12]: ich_p[3:0]
 *    Analog Input Channel number
 *  [11:00]: adc_p[11:0]
 *     Value of the conversion result. The data are updated when the conversion of the input
 *    [EA3:EA0] finishes; see the ADC Operation section for details.
 */
function amc_get_adc8(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;
    // see the fmc150-user-manual.pdf (page 15)
    const text = "(temperature)";
    const factor = 1.0;

    const addr = AMC_ADDR['reg8'];
    const data0 = amc_read_command(addr, page);
    const data = factor * data0;

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_adc8]: Get the register value " + text;
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("ich_p", 12, 4, data, level2, mode_p);
            display_bit_from_data("adc_p", 0, 12, data, level2, mode_p);
        }
    }

    return data;
}


/**
 * Get the amc_get_adc(i) register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:12]: ich_p[3:0]
 *    Analog Input Channel number
 *  [11:00]: adc_p[11:0]
 *     Value of the conversion result. The data are updated when the conversion of the input
 *    [EA3:EA0] finishes; see the ADC Operation section for details.
 *  adc_id_p: (0 to 7)
 */
function amc_get_adc(adc_id_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    switch (adc_id_p) {
        case 0:
            data = amc_get_adc0(level0, mode_p, verbosity_p);
            break;
        case 1:
            data = amc_get_adc1(level0, mode_p, verbosity_p);
            break;
        case 2:
            data = amc_get_adc2(level0, mode_p, verbosity_p);
            break;
        case 3:
            data = amc_get_adc3(level0, mode_p, verbosity_p);
            break;
        case 4:
            data = amc_get_adc4(level0, mode_p, verbosity_p);
            break;
        case 5:
            data = amc_get_adc5(level0, mode_p, verbosity_p);
            break;
        case 6:
            data = amc_get_adc6(level0, mode_p, verbosity_p);
            break;
        case 7:
            data = amc_get_adc7(level0, mode_p, verbosity_p);
            break;
        default: // adc_id_p = 8
            data = amc_get_adc8(level0, mode_p, verbosity_p);
            break;
    }

    return data;
}


/**
 * Get the amc_get_alr register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [11:08]: R/W: alr_p[3:0]
 *     nth analog input out-of-range status flag. These bits are read-only. Writing ALR-n
 *    bits has no effect.
 *    ALR-n = '1' when the nth analog input is out-of-range.
 *    ALR-n = '0' when the nth analog input is not out-of-range. ALR-n is always '0' when
 *    following conditions hold: the value of Threshold-Low-n Register is equal to '0', and
 *    the Threshold-Hi-n Register is equal to the full-scale value of the input.
 */
function amc_get_alr(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;

    const addr = AMC_ADDR['reg9'];
    const data = amc_read_command(addr, page)

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_alr]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("alr_p", 8, 4, data, level2, mode_p);
        }
    }

    return data;
}


/**
 * Get the amc_get_gpio register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [11:08]: R/W: iomod_p[3:0]
 *     . IOMOD-n = 0: Analog input out-of-range detection mode. In this mode, GPIO-n (n = 0, 1, 2, 3) work as
 *          analog input out-of-range indicators, denoted as output pins ALR-n. The status of each pin
 *          ALR-n is set by bit ALR-n of the ALR Register. The ALR-n pin is low when the
 *          corresponding ALR-n bit is '1', and is high-impedance when ALR-n is '0'.
 *     . IOMOD-n = 1: GPIO mode. In this mode, pin GPIO-n works as general digital I/O (bidirectional). When
 *          the pin is output, the status is determined by the corresponding bit IOST-n; it is highimpedance
 *          for IOST-n = 1, and logic low for IOST-n = 0. When the pin is input, reading
 *          this bit acquires the digital logic value present at the pin. GPIO data are preserved during
 *          all power-down conditions.
 *  [05:00]: R/W: iost_p[5:0]:
 *       I/O STATUS bit of the GPIO-n pin. If the GPIO-n pin works as a general-purpose I/O, this
 *      bit indicates the actual logic value present at the pin when reading the bit. It also sets the
 *      state of the corresponding GPIO-n pin (high-impedance for IOST-n = 1, logic low for
 *      IOST-n = 0) when writing to the bit. An external pull-up resistor is required when using pin
 *      GPIO-n as an output.
 *      If the GPIO-n pin works as an analog input out-of-range indicator, then bit IOST-n is a
 *      complement of the corresponding bit ALR-n in the ALR Register. Writing the IOST-n bit
 *      does not cause any change. Note that only GPIO-0, GPIO-1, GPIO-2, and GPIO-3 can be
 *      configured as out-of-range indicators.
 *      44 Submit Documentation Feedback Copyright © 2005–2012, Texas Instruments Incorporated
 *      Product Folder Link(s): AMC7823
 *      AMC7823
 *      www.ti.com SLAS453F –APRIL 2005–REVISED MARCH 2012
 *      To avoid loss of alarm information in bits IOST-n during power-down of the ADC, change to direct conversion
 *      mode (see ADC Control Register) before power-down and do not issue a convert command while the ADC is
 *      powered down.
 */
function amc_get_gpio(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 0;

    const addr = AMC_ADDR['reg10'];
    const data = amc_read_command(addr, page)

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_gpio]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("iomod_p", 8, 4, data, level2, mode_p);
            display_bit_from_data("iost_p", 0, 6, data, level2, mode_p);
        }
    }

    return data;
}




/**
 * Get the amc_get_dac(i) register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [14:12]: R/W: och_p[2:0]
 *      . DAC Address. Read-only. Writing these bits does not cause any change.
 *  [11:0]: R/W: dac_p[11:0]:
 *       . In a write operation, these data bits are written into the DAC Data-n Register. However, in
 *         (WRITE/READ) a read operation, the data bits are returned from the DAC-n Latch, not from the DAC-n
 *         Data Register
 *  dac_id_p: (0 to 7)
 */
function amc_get_dac(dac_id_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 1;

    switch (dac_id_p) {
        case 0:
            addr = AMC_ADDR['reg0'];
            break;
        case 1:
            addr = AMC_ADDR['reg1'];
            break;
        case 2:
            addr = AMC_ADDR['reg2'];
            break;
        case 3:
            addr = AMC_ADDR['reg3'];
            break;
        case 4:
            addr = AMC_ADDR['reg4'];
            break;
        case 5:
            addr = AMC_ADDR['reg5'];
            break;
        case 6:
            addr = AMC_ADDR['reg6'];
            break;
        default: // dac_id_p = 7
            addr = AMC_ADDR['reg7'];
            break;
    }

    const data = amc_read_command(addr, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_dac" + adc_id_p.toString(16) + "]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("och_p", 12, 3, data, level2, mode_p);
            display_bit_from_data("dac_p", 0, 12, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the amc_get_load_dac register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:00]: value_p[15:00] = 0xBB00
 *    The data word 0xBB00 (shown above) written into the LOAD DAC Register generates ILDAC, the internal load
 *    DAC signal. ILDAC and the external ELDAC signal work in a similar manner. ILDAC shifts data from the DAC-n
 *    Data register to the DAC-n Latch and updates the output for all DAC-n with the corresponding SLDA-n bit set to
 *    '1'. Other codes written to this register do not generate ILDAC and have no impact on any DAC-n. The LOAD
 *    DAC Register is cleared after ILDAC is generated. The register is also cleared after power-on or reset.
 *
 */
function amc_get_load_dac(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 1;

    const addr = AMC_ADDR['reg8'];
    const data = amc_read_command(addr, page)

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_load_dac]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("value_p", 0, 16, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_dac_conf register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15:8]: R/W: slda_p[7:0]
 *     DAC Synchronous Load Enable bit.
 *    SLDA-n = '1': Synchronous Load enabled. When the synchronous load DAC signal occurs, DAC-n
 *    Latch is loaded with the value of the corresponding DAC-n Data Register, and the output of DACn
 *    is updated immediately. This load signal can be the rising edge of the external signal ELDAC or
 *    the internal load signal ILDAC. Writing the data word 0xBB00 into the LOAD DAC Register
 *    generates ILDAC. A write command to the DAC-n Data Register updates that register only, and
 *    does not change the DAC-n output.
 *    SLDA-n = '0': Asynchronous Load enabled. A write command to the DAC-n Data Register
 *    immediately updates DAC-n Latch and the output of DAC-n. The synchronous load DAC signal
 *    (ILDAC or ELDAC) does not affect DAC-n.
 *  [7:0]: R/W: gdac_p[7:0]
 *    DAC-n Output Buffer Amplifier Gain bit.
 *    GDAC-n = '1': The gain of the DAC-n output buffer amplifier is equal to 2.
 *    GDAC-n = '0': The gain of the DAC-n output buffer amplifier is equal to 1.
 */
function amc_get_dac_conf(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 1;

    const addr = AMC_ADDR['reg9'];
    const data = amc_read_command(addr, page)

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_dac_conf]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("slda_p", 8, 8, data, level2, mode_p);
            display_bit_from_data("gdac_p", 0, 8, data, level2, mode_p);
        }
    }

    return data;
}

/**
 *  Get the amc_get_amc_status_conf register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [14]: R/W: rstc_p[0]
 *     RESET Complete Bit. This bit is set to '1' on power-up or reset. This bit can be cleared by writing
 *     '0' to this location. The host cannot set this bit to '1'. This bit allows the host to determine if the
 *     part has been configured after power-up, or if a reset has occurred to the AMC7823 without
 *     knowledge of the host.
 *  [13]: R/W: davf_p[0]
 *     ADC Data Available Flag. For direct-mode only. Always cleared (set to '0') in auto-mode (see ADC
 *    Control Register).
 *    DAVF = 1: The ADC conversions are complete and new data are available.
 *    DAVF = 0: The ADC conversion is in progress (data is not ready) or the ADC is in Auto-Mode.
 *    In direct-mode, bit DAVF sets the pin DAV. DAV goes low when DAVF = 1, and goes high when
 *    DAVF = 0. In auto-mode, DAVF is always cleared to '0'. However, a 2μs pulse (active low)
 *    appears on the DAV pin when the input with ending address [EA3:EA0] is converted. DAVF is
 *    cleared to '0' in one of three ways: (1) reading the ADC Data Register; (2) starting a new ADC
 *    conversion; or (3) writing '0' to this bit.
 *  [7]: R/W: sref_p[0]
 *     Select Reference bit.
 *     SREF = 0 (default condition): The internal reference is selected as the chip reference. It is
 *     connected to pin 21, EXT_REF_IN, by a 10kΩ resistor.
 *     SREF = 1: The internal reference is de-selected and disconnected from pin 21 (EXT_REF_IN).
 *     Pin 21 floats unless an external reference is applied. Always set SREF bit to '1' when an external
 *     reference is applied; otherwise, the external reference must sink or source current. The current
 *     value is the voltage difference between the external and internal reference divided by a 10kΩ
 *     resistance.
 *     SREF also provides information to the precision current source and is used to configure that
 *     source (see the Precision Current Source section for details). After power-on or reset, SREF is
 *     cleared to '0'.
 *  [6]: R/W: gref_p[0]
 *    Gain of the internal reference voltage (VREF). This bit selects one of two preset values for the
 *    internal reference voltage, but has no effect on the external reference. GREF also provides
 *    information to the precision current source and is used to configure that source (see the Precision
 *    Current Source section for details).
 *    GREF = 0: The internal reference voltage is +1.25V.
 *    GREF = 1: The internal reference voltage is +2.5V.
 *    When an external reference is used and SREF is set to '1', GREF has no impact on the reference.
 *    However, if SREF is cleared to '0', a 10kΩ resistor is connected between pin 21, EXT_REF_IN,
 *    and one of the two internal reference values dictated by the value of GREF. In this case, the
 *    external reference must be able to drive the 10kΩ load. The full-scale range of the ADC input is
 *    equal to 2 x VREF. To avoid ADC input saturation, GREF must be cleared to '0' when AVDD is less
 *    than +5V and the internal reference is used. After power-on or reset, GREF is cleared to '0'.
 *    Table 9 specifies the ADC input range as a function of bits GREF and SREF.
 *  [5]: R/W: ecnvt_p[0]
 *    Enable CONVERT (external conversion trigger). This bit specifies the ADC trigger mode. When
 *    ECNVT = '1', CONVERT is enabled. The ADC is in external trigger mode. The low-to-high
 *    transition of the external trigger signal CONVERT triggers the ADC conversions. A write command
 *    to the ADC Control Register does not initiate conversion, but rather specifies the group of inputs
 *    to convert. After triggered by CONVERT, the AMC7823 sequentially accesses each analog input
 *    one time. The bits [SA3:SA0] of the ADC Control Register comprise the channel address of the
 *    first analog input accessed; [EA3:EA0] is the last analog input accessed. When the conversion
 *    finishes, the ADC is idle and waits for a new CONVERT or a new command. With an external
 *    trigger, the ADC always works in direct-mode (see the ADC Control Register section).
 *    When ECNVT = '0', CONVERT is disabled. The internal ADC trigger is used. A write command to
 *    the ADC Control Register generates the internal trigger and initiates ADC conversion. With an
 *    internal trigger, the ADC can work in either direct-mode or auto-mode (see the ADC Operation
 *    and ADC Control Register sections). Table 10 summarizes the ADC conversion mode
 *    configuration.
 *    After power-on or reset, DAVF, SREF, GREF, and ECNVT are cleared to '0'; RSTC is set to '1'.
 */

function amc_get_amc_status_conf(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 1;

    const addr = AMC_ADDR['reg10'];
    const data = amc_read_command(addr, page)

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_amc_status_conf]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("rstc_p", 14, 1, data, level2, mode_p);
            display_bit_from_data("davf_p", 13, 1, data, level2, mode_p);
            display_bit_from_data("sref_p", 7, 1, data, level2, mode_p);
            display_bit_from_data("gref_p", 6, 1, data, level2, mode_p);
            display_bit_from_data("ecnvt_p", 5, 1, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_adc_ctrl register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15]: R/W: cmode_p[0]
 *    ADC Conversion Mode bit. This bit selects between the two operating conversion modes (direct
 *    or auto) when the Internal trigger is active. This bit is always cleared to '0' (direct-mode) when an
 *    external trigger is active.
 *    CMODE = '0': Direct-mode. The analog inputs from [SA3:SA0] to [EA3:EA0] are converted
 *    sequentially (see Table 12) one time, [SA3:SA0] first and [EA3;EA0] last. When one set of
 *    conversions is complete, the ADC is idle and waits for a new trigger. The external trigger is
 *    restricted to this mode of operation only.
 *    CMODE = '1': Auto-mode. The analog inputs from [SA3:SA0] to [EA3:EA0] are converted
 *    sequentially (see Table 12) and repeatedly, [SA3:SA0] first and [EA3;EA0] last. When one set of
 *    conversions is complete, the ADC multiplexer returns to the starting address [SA3:SA0] and
 *    repeats the process. Repetitive conversions continue until auto-mode is halted by rewriting the
 *    ADC Control Register to direct
 *  [11:8]: R/W: sa_p[3:0]:
 *    The channel address of the first analog input to be converted (see Table 12).
 *  [7:4]: R/W: ea_p[3:0]
 *    The channel address of the last analog input to be converted (see Table 12).
 */

function amc_get_adc_ctrl(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 1;

    const addr = AMC_ADDR['reg11'];
    const data = amc_read_command(addr, page)

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_adc_ctrl]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("cmode_p", 15, 1, data, level2, mode_p);
            display_bit_from_data("sa_p", 8, 4, data, level2, mode_p);
            display_bit_from_data("ea_p", 4, 4, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the amc_get_reset register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * [15:0]: value_p[15:0]: 0xBB30
 *    The AMC7823 has a special RESET Register that performs the software equivalent function of the device
 *    RESET pin. To invoke a system reset, write the data word 0xBB3X to this register. Only the upper 12 bits are
 *    significant; the lowest four bits are Don’t Care.
 */
function amc_get_reset(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 1;

    const addr = AMC_ADDR['reg12'];
    const data = amc_read_command(addr, page)

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_reset]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("value_p", 0, 16, data, level2, mode_p);
        }
    }

    return data;
}

/*
 *  Get the amc_get_power_down register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [15]: R/W: padc_p[0]
 *     ADC power-down control bit.
 *    PADC = '0': The ADC is in power-down mode and ADC conversion is halted.
 *    PADC = '1': The ADC is in normal operating mode.
 *  [14:7]: R/W: pdac_p[7:0]
 *     PDAC-n = '0': DAC-n output buffer amplifier is in power-down mode. The output pin
 *    of DAC-n is internally switched from the buffer output to analog ground through an
 *    internal 5kΩ resistor. Each DAC output buffer may be independently powered down.
 *    (See the DAC Operation section for details.)
 *    PDAC-n = '1' and PREFB = '1': DAC-n is in normal operating mode.
 *  [6]: R/W: pts_p[0]
 *     Precision current source power-down control bit.
 *    PTS = '0': Precision current source is in power-down mode and the current output is
 *    zero.
 *    PTS = '1': Precision current source is in normal operating mode (see the Precision
 *    Current Source section for details).
 *  [5]: R/W: prefb_p[0]
 *     Reference buffer amplifier power-down control bit. This bit controls the power-down
 *    condition of the amplifier that supplies a buffered reference voltage to all DAC-n
 *    resistor strings and to the precision current source. This bit also provides
 *    configuration information to the precision current source (see the Precision Current
 *    Source Configuration table, Table 7).
 *    PREFB = '0': Reference buffer amplifier is in power-down mode. All DACs are
 *    inoperative. The precision current source may be used only if GREF = '0' (see the
 *    Precision Current Source Configuration table, Table 7).
 *    PREFB = '1': Reference buffer amplifier is powered on. This mode is required for
 *    any DAC-n operation. The precision current source may be used with either value of
 *    GREF.
 */

function amc_get_power_down(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 1;

    const addr = AMC_ADDR['reg13'];
    const data = amc_read_command(addr, page)

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_power_down]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("padc_p", 15, 1, data, level2, mode_p);
            display_bit_from_data("pdac_p", 7, 8, data, level2, mode_p);
            display_bit_from_data("pts_p", 6, 1, data, level2, mode_p);
            display_bit_from_data("prefb_p", 5, 1, data, level2, mode_p);
        }
    }

    return data;
}

/*
 * Get the amc_get_threshold_hi register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [11:0]: R/W: threshold_p[11:0]
 *    Data bits of the upper bound threshold of the nth analog input. All bits are set to '1'
 *    after power-on or reset.
 *  threshold_id_p (0 to 3)
 */
function amc_get_threshold_hi(threshold_id_p, level_p, mode_p, verbosity_p) {


    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 1;
    switch (threshold_id_p) {

        case 0:
            addr = AMC_ADDR['reg14'];
            break;
        case 1:
            addr = AMC_ADDR['reg16'];
            break;
        case 2:
            addr = AMC_ADDR['reg18'];
            break;
        default: // threshold_id = 3
            addr = AMC_ADDR['reg20'];
            break;
    }

    const data = amc_read_command(addr, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_threshold_hi" + threshold_id_p.toString(16) + "]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("threshold_hi_p", data, 12, level2, mode_p);
        }
    }
}

/**
 *  Get the amc_get_threshold_lo register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [11:0]: R/W: threshold_p[11:0]
 *     Data bits of the lower bound threshold of the nth analog input. This register is
 *    cleared to '0' after power-on or reset.
 *  threshold_id_p (0 to 3)
 */
function amc_get_threshold_lo(threshold_id_p, level_p, mode_p, verbosity_p) {


    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 1;

    switch (threshold_id_p) {

        case 0:
            addr = AMC_ADDR['reg15'];
            break;
        case 1:
            addr = AMC_ADDR['reg17'];
            break;
        case 2:
            addr = AMC_ADDR['reg19'];
            break;
        default: // threshold_id = 3
            addr = AMC_ADDR['reg21'];
            break;
    }

    const data = amc_read_command(addr, page);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_threshold_lo" + threshold_id_p.toString(16) + "]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit("threshold_lo_p", data, 12, level2, mode_p);
        }
    }



}

/**
 * Get the amc_get_part_rev_number register value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * [15:0]: value_p[15:0]: 0xE000
 */
function amc_get_part_rev_number(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const page = 1;

    const addr = AMC_ADDR['reg30'];
    const data = amc_read_command(addr, page)

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_AMC_REG_VERBOSITY_MIN) {
            const msg = "[amc_get_part_rev_number]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_AMC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_AMC_SPI_ADDR_WIDTH, data, c_AMC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_AMC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("value_p", 0, 16, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Read and Display HK values (adcs).
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */
function adc_display_hk(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    amc_get_adc(0, level0, mode_p, verbosity_p);
    amc_get_adc(1, level0, mode_p, verbosity_p);
    amc_get_adc(2, level0, mode_p, verbosity_p);
    amc_get_adc(3, level0, mode_p, verbosity_p);
    amc_get_adc(4, level0, mode_p, verbosity_p);
    amc_get_adc(5, level0, mode_p, verbosity_p);
    amc_get_adc(6, level0, mode_p, verbosity_p);
    amc_get_adc(7, level0, mode_p, verbosity_p);
    amc_get_adc(8, level0, mode_p, verbosity_p);


}

/**
 * Read and Display the configuration of all spi device registers.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */
function adc_display_all_config(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    adc_display_hk(level0, mode_p, verbosity_p);

    amc_get_alr(level0, mode_p, verbosity_p);
    amc_get_gpio(level0, mode_p, verbosity_p);
    amc_get_dac(0, level0, mode_p, verbosity_p);
    amc_get_dac(1, level0, mode_p, verbosity_p);
    amc_get_dac(2, level0, mode_p, verbosity_p);
    amc_get_dac(3, level0, mode_p, verbosity_p);
    amc_get_dac(4, level0, mode_p, verbosity_p);
    amc_get_dac(5, level0, mode_p, verbosity_p);
    amc_get_dac(6, level0, mode_p, verbosity_p);
    amc_get_dac(7, level0, mode_p, verbosity_p);

    amc_get_load_dac(level0, mode_p, verbosity_p);
    amc_get_dac_conf(level0, mode_p, verbosity_p);
    amc_get_amc_status_conf(level0, mode_p, verbosity_p);
    amc_get_adc_ctrl(level0, mode_p, verbosity_p);
    amc_get_reset(level0, mode_p, verbosity_p);
    amc_get_power_down(level0, mode_p, verbosity_p);

    amc_get_threshold_hi(0, level0, mode_p, verbosity_p);
    amc_get_threshold_hi(1, level0, mode_p, verbosity_p);
    amc_get_threshold_hi(2, level0, mode_p, verbosity_p);
    amc_get_threshold_hi(3, level0, mode_p, verbosity_p);

    amc_get_threshold_lo(0, level0, mode_p, verbosity_p);
    amc_get_threshold_lo(1, level0, mode_p, verbosity_p);
    amc_get_threshold_lo(2, level0, mode_p, verbosity_p);
    amc_get_threshold_lo(3, level0, mode_p, verbosity_p);

    amc_get_part_rev_number(level0, mode_p, verbosity_p);
}



/**
 * Default Configuration of the ads62p49 (adc) spi device (FMC150 board).
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */
function AMC7823_configure(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    const msg = "AMC7823_configure";
    display_title(msg, level0, mode_p);

    // Enable the SPI on the FPGA board
    amc_spi_enable(level1, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);

    /**
     * #############################################################
     *  set the amc_set_gpio register
     * ##############################################################
     *  [11:08]: R/W: iomod_p[3:0]
     *     . IOMOD-n = 0: Analog input out-of-range detection mode. In this mode, GPIO-n (n = 0, 1, 2, 3) work as
     *          analog input out-of-range indicators, denoted as output pins ALR-n. The status of each pin
     *          ALR-n is set by bit ALR-n of the ALR Register. The ALR-n pin is low when the
     *          corresponding ALR-n bit is '1', and is high-impedance when ALR-n is '0'.
     *     . IOMOD-n = 1: GPIO mode. In this mode, pin GPIO-n works as general digital I/O (bidirectional). When
     *          the pin is output, the status is determined by the corresponding bit IOST-n; it is highimpedance
     *          for IOST-n = 1, and logic low for IOST-n = 0. When the pin is input, reading
     *          this bit acquires the digital logic value present at the pin. GPIO data are preserved during
     *          all power-down conditions.
     *  [05:00]: R/W: iost_p[5:0]:
     *       I/O STATUS bit of the GPIO-n pin. If the GPIO-n pin works as a general-purpose I/O, this
     *      bit indicates the actual logic value present at the pin when reading the bit. It also sets the
     *      state of the corresponding GPIO-n pin (high-impedance for IOST-n = 1, logic low for
     *      IOST-n = 0) when writing to the bit. An external pull-up resistor is required when using pin
     *      GPIO-n as an output.
     *      If the GPIO-n pin works as an analog input out-of-range indicator, then bit IOST-n is a
     *      complement of the corresponding bit ALR-n in the ALR Register. Writing the IOST-n bit
     *      does not cause any change. Note that only GPIO-0, GPIO-1, GPIO-2, and GPIO-3 can be
     *      configured as out-of-range indicators.
     *      44 Submit Documentation Feedback Copyright © 2005–2012, Texas Instruments Incorporated
     *      Product Folder Link(s): AMC7823
     *      AMC7823
     *      www.ti.com SLAS453F –APRIL 2005–REVISED MARCH 2012
     *      To avoid loss of alarm information in bits IOST-n during power-down of the ADC, change to direct conversion
     *      mode (see ADC Control Register) before power-down and do not issue a convert command while the ADC is
     *      powered down.
     */
    const iomod = parseInt('1111', 2);
    const iost = parseInt('111111', 2);
    amc_set_gpio(
        iomod, iost,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /**
     * ##############################################################
     *  set the amc_set_amc_status_conf register
     * ##############################################################
     *  [14]: R/W: rstc_p[0]
     *     RESET Complete Bit. This bit is set to '1' on power-up or reset. This bit can be cleared by writing
     *     '0' to this location. The host cannot set this bit to '1'. This bit allows the host to determine if the
     *     part has been configured after power-up, or if a reset has occurred to the AMC7823 without
     *     knowledge of the host.
     *  [13]: R/W: davf_p[0]
     *     ADC Data Available Flag. For direct-mode only. Always cleared (set to '0') in auto-mode (see ADC
     *    Control Register).
     *    DAVF = 1: The ADC conversions are complete and new data are available.
     *    DAVF = 0: The ADC conversion is in progress (data is not ready) or the ADC is in Auto-Mode.
     *    In direct-mode, bit DAVF sets the pin DAV. DAV goes low when DAVF = 1, and goes high when
     *    DAVF = 0. In auto-mode, DAVF is always cleared to '0'. However, a 2μs pulse (active low)
     *    appears on the DAV pin when the input with ending address [EA3:EA0] is converted. DAVF is
     *    cleared to '0' in one of three ways: (1) reading the ADC Data Register; (2) starting a new ADC
     *    conversion; or (3) writing '0' to this bit.
     *  [7]: R/W: sref_p[0]
     *     Select Reference bit.
     *     SREF = 0 (default condition): The internal reference is selected as the chip reference. It is
     *     connected to pin 21, EXT_REF_IN, by a 10kΩ resistor.
     *     SREF = 1: The internal reference is de-selected and disconnected from pin 21 (EXT_REF_IN).
     *     Pin 21 floats unless an external reference is applied. Always set SREF bit to '1' when an external
     *     reference is applied; otherwise, the external reference must sink or source current. The current
     *     value is the voltage difference between the external and internal reference divided by a 10kΩ
     *     resistance.
     *     SREF also provides information to the precision current source and is used to configure that
     *     source (see the Precision Current Source section for details). After power-on or reset, SREF is
     *     cleared to '0'.
     *  [6]: R/W: gref_p[0]
     *    Gain of the internal reference voltage (VREF). This bit selects one of two preset values for the
     *    internal reference voltage, but has no effect on the external reference. GREF also provides
     *    information to the precision current source and is used to configure that source (see the Precision
     *    Current Source section for details).
     *    GREF = 0: The internal reference voltage is +1.25V.
     *    GREF = 1: The internal reference voltage is +2.5V.
     *    When an external reference is used and SREF is set to '1', GREF has no impact on the reference.
     *    However, if SREF is cleared to '0', a 10kΩ resistor is connected between pin 21, EXT_REF_IN,
     *    and one of the two internal reference values dictated by the value of GREF. In this case, the
     *    external reference must be able to drive the 10kΩ load. The full-scale range of the ADC input is
     *    equal to 2 x VREF. To avoid ADC input saturation, GREF must be cleared to '0' when AVDD is less
     *    than +5V and the internal reference is used. After power-on or reset, GREF is cleared to '0'.
     *    Table 9 specifies the ADC input range as a function of bits GREF and SREF.
     *  [5]: R/W: ecnvt_p[0]
     *    Enable CONVERT (external conversion trigger). This bit specifies the ADC trigger mode. When
     *    ECNVT = '1', CONVERT is enabled. The ADC is in external trigger mode. The low-to-high
     *    transition of the external trigger signal CONVERT triggers the ADC conversions. A write command
     *    to the ADC Control Register does not initiate conversion, but rather specifies the group of inputs
     *    to convert. After triggered by CONVERT, the AMC7823 sequentially accesses each analog input
     *    one time. The bits [SA3:SA0] of the ADC Control Register comprise the channel address of the
     *    first analog input accessed; [EA3:EA0] is the last analog input accessed. When the conversion
     *    finishes, the ADC is idle and waits for a new CONVERT or a new command. With an external
     *    trigger, the ADC always works in direct-mode (see the ADC Control Register section).
     *    When ECNVT = '0', CONVERT is disabled. The internal ADC trigger is used. A write command to
     *    the ADC Control Register generates the internal trigger and initiates ADC conversion. With an
     *    internal trigger, the ADC can work in either direct-mode or auto-mode (see the ADC Operation
     *    and ADC Control Register sections). Table 10 summarizes the ADC conversion mode
     *    configuration.
     *    After power-on or reset, DAVF, SREF, GREF, and ECNVT are cleared to '0'; RSTC is set to '1'.
     */
    const rstc = 0;
    const davf = 0;
    const sref = 0;
    const gref = 0;
    const ecnvt = 0;
    amc_set_amc_status_conf(
        rstc, davf, sref, gref, ecnvt,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /**
     * ##############################################################
     *  set the amc_set_adc_ctrl register
     * ##############################################################
     *  [15]: R/W: cmode_p[0]
     *    ADC Conversion Mode bit. This bit selects between the two operating conversion modes (direct
     *    or auto) when the Internal trigger is active. This bit is always cleared to '0' (direct-mode) when an
     *    external trigger is active.
     *    CMODE = '0': Direct-mode. The analog inputs from [SA3:SA0] to [EA3:EA0] are converted
     *    sequentially (see Table 12) one time, [SA3:SA0] first and [EA3;EA0] last. When one set of
     *    conversions is complete, the ADC is idle and waits for a new trigger. The external trigger is
     *    restricted to this mode of operation only.
     *    CMODE = '1': Auto-mode. The analog inputs from [SA3:SA0] to [EA3:EA0] are converted
     *    sequentially (see Table 12) and repeatedly, [SA3:SA0] first and [EA3;EA0] last. When one set of
     *    conversions is complete, the ADC multiplexer returns to the starting address [SA3:SA0] and
     *    repeats the process. Repetitive conversions continue until auto-mode is halted by rewriting the
     *    ADC Control Register to direct
     *  [11:8]: R/W: sa_p[3:0]:
     *    The channel address of the first analog input to be converted (see Table 12).
     *  [7:4]: R/W: ea_p[3:0]
     *    The channel address of the last analog input to be converted (see Table 12).
     */
    const cmode = 1; // 0: direct mode, 1: auto-mode
    const sa = parseInt('0000', 2); // adc0
    const ea = parseInt('1000', 2); // adc8
    amc_set_adc_ctrl(
        cmode, sa, ea,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
     * ##############################################################
     *  set the amc_set_power_down register
     * ##############################################################
     *  [15]: R/W: padc_p[0]
     *     ADC power-down control bit.
     *    PADC = '0': The ADC is in power-down mode and ADC conversion is halted.
     *    PADC = '1': The ADC is in normal operating mode.
     *  [14:7]: R/W: pdac_p[7:0]
     *     PDAC-n = '0': DAC-n output buffer amplifier is in power-down mode. The output pin
     *    of DAC-n is internally switched from the buffer output to analog ground through an
     *    internal 5kΩ resistor. Each DAC output buffer may be independently powered down.
     *    (See the DAC Operation section for details.)
     *    PDAC-n = '1' and PREFB = '1': DAC-n is in normal operating mode.
     *  [6]: R/W: pts_p[0]
     *     Precision current source power-down control bit.
     *    PTS = '0': Precision current source is in power-down mode and the current output is
     *    zero.
     *    PTS = '1': Precision current source is in normal operating mode (see the Precision
     *    Current Source section for details).
     *  [5]: R/W: prefb_p[0]
     *     Reference buffer amplifier power-down control bit. This bit controls the power-down
     *    condition of the amplifier that supplies a buffered reference voltage to all DAC-n
     *    resistor strings and to the precision current source. This bit also provides
     *    configuration information to the precision current source (see the Precision Current
     *    Source Configuration table, Table 7).
     *    PREFB = '0': Reference buffer amplifier is in power-down mode. All DACs are
     *    inoperative. The precision current source may be used only if GREF = '0' (see the
     *    Precision Current Source Configuration table, Table 7).
     *    PREFB = '1': Reference buffer amplifier is powered on. This mode is required for
     *    any DAC-n operation. The precision current source may be used with either value of
     *    GREF.
     */
    const padc = 1; // 0: adc is power down, 1: adc is in normal mode
    const pdac = parseInt('0000_0000', 2); //0: DACi is power down,1 + (prefb = 1) = DAC is normal mode
    const pts = 0; //0: Precision current source is in power-down mode and the current output is zero, 1:Precision current source is in normal operating mode
    const prefb = 0; //0: Reference buffer amplifier is in power-down mode, 1:Reference buffer amplifier is powered on
    amc_set_power_down(
        padc, pdac, pts, prefb,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
     * ##############################################################
     *  set the amc_set_threshold_hi register
     * ##############################################################
     *  [11:0]: R/W: threshold_p[11:0]
     *    Data bits of the upper bound threshold of the nth analog input. All bits are set to '1'
     *    after power-on or reset.
     *  threshold_id_p (0 to 3)
     */
    const threshold = 0x0B16;
    const threshold_id = 0;
    amc_set_threshold_hi(
        threshold, threshold_id,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /**
     * ##############################################################
     *  set the amc_set_threshold_lo register
     * ##############################################################
     *  [11:0]: R/W: threshold_p[11:0]
     *     Data bits of the lower bound threshold of the nth analog input. This register is
     *    cleared to '0' after power-on or reset.
     *  threshold_id_p (0 to 3)
     */
    const threshold = 0x0A08;
    const threshold_id = 0;
    amc_set_threshold_lo(
        threshold, threshold_id,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
     * ##############################################################
     *  set the amc_set_threshold_hi register
     * ##############################################################
     *  [11:0]: R/W: threshold_p[11:0]
     *    Data bits of the upper bound threshold of the nth analog input. All bits are set to '1'
     *    after power-on or reset.
     *  threshold_id_p (0 to 3)
     */
    const threshold = 0x0B16;
    const threshold_id = 1;
    amc_set_threshold_hi(
        threshold, threshold_id,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /**
     * ##############################################################
     *  set the amc_set_threshold_lo register
     * ##############################################################
     *  [11:0]: R/W: threshold_p[11:0]
     *     Data bits of the lower bound threshold of the nth analog input. This register is
     *    cleared to '0' after power-on or reset.
     *  threshold_id_p (0 to 3)
     */
    const threshold = 0x0A08;
    const threshold_id = 1;
    amc_set_threshold_lo(
        threshold, threshold_id,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
     * ##############################################################
     *  set the amc_set_threshold_hi register
     * ##############################################################
     *  [11:0]: R/W: threshold_p[11:0]
     *    Data bits of the upper bound threshold of the nth analog input. All bits are set to '1'
     *    after power-on or reset.
     *  threshold_id_p (0 to 3)
     */
    const threshold = 0x0C18;
    const threshold_id = 2;
    amc_set_threshold_hi(
        threshold, threshold_id,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /**
     * ##############################################################
     *  set the amc_set_threshold_lo register
     * ##############################################################
     *  [11:0]: R/W: threshold_p[11:0]
     *     Data bits of the lower bound threshold of the nth analog input. This register is
     *    cleared to '0' after power-on or reset.
     *  threshold_id_p (0 to 3)
     */
    const threshold = 0x0AF1;
    const threshold_id = 2;
    amc_set_threshold_lo(
        threshold, threshold_id,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
     * ##############################################################
     *  set the amc_set_threshold_hi register
     * ##############################################################
     *  [11:0]: R/W: threshold_p[11:0]
     *    Data bits of the upper bound threshold of the nth analog input. All bits are set to '1'
     *    after power-on or reset.
     *  threshold_id_p (0 to 3)
     */
    const threshold = 0x0C18;
    const threshold_id = 3;
    amc_set_threshold_hi(
        threshold, threshold_id,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /**
     * ##############################################################
     *  set the amc_set_threshold_lo register
     * ##############################################################
     *  [11:0]: R/W: threshold_p[11:0]
     *     Data bits of the lower bound threshold of the nth analog input. This register is
     *    cleared to '0' after power-on or reset.
     *  threshold_id_p (0 to 3)
     */
    const threshold = 0x0AF1;
    const threshold_id = 3;
    amc_set_threshold_lo(
        threshold, threshold_id,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);


}