// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   fpasim_tools.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//    This script combines imported functions in order to build higher level functions.
//
// -------------------------------------------------------------------------------------------------------------
include("./fpasim/CDCE72010.dscript");
include("./fpasim/ADS62P49.dscript");
include("./fpasim/DAC3283.dscript");
include("./fpasim/AMC7823.dscript");



/**
 * Display the essential parameters of the test.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_script_info(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // count the number of error message
    cnt_error_info = 0;
    /*
     Print the test info
    */
    const msg = "[fpasim_script_info]";
    display(msg, level0, mode_p);

    // get the operator name
    const operator_name = get_operator_name();
    const msg = "Operator Name: " + operator_name;
    display(msg, level1, mode_p);

    const msg = "";
    display(msg, level1, mode_p);

    // get the session
    const session_name = get_session_name();
    const msg = "Session: " + session_name;
    display(msg, level1, mode_p);

    const msg = "";
    display(msg, level1, mode_p);

    // Print the current date
    const date = maDate()
    const msg = "Date: " + date;
    display(msg, level1, mode_p);

    const msg = "";
    display(msg, level1, mode_p);

    // get hardware_id
    const reg_name = 'HARDWARE_ID';
    const msg = "Get " + reg_name + ": ";
    display(msg, level1, mode_p);
    const data = fpasim_get_wireout_by_name(reg_name, level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);

    // get firmware name
    const reg_name = 'FIRMWARE_NAME';
    const msg = "Get " + reg_name + ": ";
    display(msg, level1, mode_p);
    const data = fpasim_get_wireout_by_name(reg_name, level2, mode_p, verbosity_p);
    data0 = 0x46504173; // code ASCII of "FPAs"
    error = check_equal(data0, data, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_info += 1
    }

    const msg = "";
    display(msg, level1, mode_p);

    // get firmware version
    const reg_name = 'FIRMWARE_VERSION';
    const msg = "Get " + reg_name + ": ";
    display(msg, level1, mode_p);
    data = fpasim_get_wireout_by_name(reg_name, level2, mode_p, verbosity_p);

    // build output filename
    //output_filename = operator_name + "_" + session_name + "_" + date;
    output_filename = date + "_" + operator_name;

    return [cnt_error_info,output_filename];
}

/**
 * Reset the fpasim function.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_reset(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const msg = "[fpasim_reset]";
    display(msg, level0, mode_p);

    /*
    Enable off
    */

    const rst = 0;
    const en = 0;
    // build the data to send
    const data = fpasim_build_ctrl(rst, en);

    const msg = "Set CTRL: Enable Off";
    display(msg, level1, mode_p);
    sendToFPAsim_configureControl(data);
    // fpasim_set_ctrl(rst_p=rst,en_p=en, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    const msg = "";
    display(msg, level1, mode_p);

    /*
     add tempo
    */
    const tempo = 10;
    const msg = "wait for " + tempo.toString(10) + " ms";
    display(msg, level1, mode_p);

    waitMs(tempo);

    const msg = "";
    display(msg, level1, mode_p);


    /*
     reset on
    */

    const rst = 1;
    const en = 0;
    // build the data to send
    const data = fpasim_build_ctrl(rst, en);

    const msg = "Set CTRL: Reset On"
    display(msg, level1, mode_p);
    sendToFPAsim_configureControl(data);
    //fpasim_set_ctrl(rst_p=rst,en_p=en, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    const msg = "";
    display(msg, level1, mode_p);

    /*
     reset off
    */

    const rst = 0;
    const en = 0;
    // build the data to send
    const data = fpasim_build_ctrl(rst, en);

    const msg = "Set CTRL: Reset Off"
    display(msg, level1, mode_p);
    sendToFPAsim_configureControl(data);
    //fpasim_set_ctrl(rst_p=rst,en_p=en, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    const msg = "";
    display(msg, level1, mode_p);

    /*
     add tempo
    */
    const tempo = 10;
    const msg = "wait for " + tempo.toString(10) + " ms";
    display(msg, level1, mode_p);

    waitMs(tempo);

    const msg = "";
    display(msg, level1, mode_p);


    /*
     reset FPASim spi bridge
    */

    const rst = 1;
    const en = 0;

    const msg = "Set SPI_CTRL: Reset On"
    display(msg, level1, mode_p);
    fpasim_set_spi_ctrl(rst, en, level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);

    /*
     spi reset off
    */

    const rst = 0;
    const en = 0;

    const msg = "Set SPI_CTRL: Reset Off"
    display(msg, level1, mode_p);
    fpasim_set_spi_ctrl(rst, en, level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);

    /*
    reset status On
    */
    const adc1_bypass = 0;
    const adc0_bypass = 0;
    const dac_en_pattern = 0;
    const rst_status = 1;
    const debug_pulse = 0;
    // build the data to send

    const msg = "Set DEBUG_CTRL: Reset Status On"
    display(msg, level1, mode_p);
    fpasim_set_debug_ctrl(adc1_bypass, adc0_bypass, dac_en_pattern, rst_status, debug_pulse, level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);


    /*
     reset status off
    */
    const msg = "Set DEBUG_CTRL: Reset Status Off"
    display(msg, level1, mode_p);
    const adc1_bypass = 0;
    const adc0_bypass = 0;
    const dac_en_pattern = 0;
    const rst_status = 0;
    const debug_pulse = 0;
    // build the data to send
    fpasim_set_debug_ctrl(adc1_bypass, adc0_bypass, dac_en_pattern, rst_status, debug_pulse, level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);

    waitMs(10);
}


/**
 * Check if the specified error is equal to error_p. Then, display the result.
 * @param {number} error_id_p - error id. The range is [0;10].
 * @param {number} error_p - error value to compare.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_check_error_by_id(error_id_p, error_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;


    const data1 = error_p;

    const msg = "[fpasim_check_error_by_id]";
    display(msg, level0, mode_p);

    const data0 = fpasim_get_error_by_id(error_id_p, level1, mode_p, -2);
    const str_data0 = convert_int_to_str_hex(data0, 32);
    const str_data1 = convert_int_to_str_hex(data1, 32);
    const msg_error = "Errors" + error_id_p.toString(10) + ":";
    error = check_equal(data0, data1, msg_error, level1, mode_p, verbosity_p);
    return error;
}


/**
 * Check if all errors are equal to 0x0. Then, display the result of each check.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_check_all_errors(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    const msg = "[fpasim_check_all_errors]";
    display(msg, level0, mode_p);
    cnt_error = 0;
    for (i = 0; i <= 10; i++) {
        error = fpasim_check_error_by_id(i, 0, level1, mode_p, verbosity_p);
        if (error == -1) {
            cnt_error += 1
        }

    }
    return cnt_error

}

/**
 * Configure the initial State of the FPAsim
 * Configure the SPI devices of the FMC150 boards.
 * Configure the FPAsim RAM with default values
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} 0
 */
function fpasim_configure(level_p,mode_p,verbosity_p)
{
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    // configure the spi_device of the fmc150 board
    configure_fmc150_spi_device(level_p, mode_p, verbosity_p);
    // configure the FPAsim RAM with default values
    error_load_ram_cnt = configure_fpasim_default_ram(level_p, mode_p, verbosity_p);
    return error_load_ram_cnt;

}

/**
 * Configure the SPI devices of the FMC150 boards.
 *  The order is important:
 *    In particular, CDCE72010_configure function needs to be called first
 *  in order to generate clocks for adc and dac devices.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} 0
 */
function configure_fmc150_spi_device(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    const msg = "[configure_fmc150_spi_device]";
    display(msg, level0, mode_p);

    /*
    disable the FPASim
    */
    const msg = "Set CTRL: Enable Off"
    display(msg, level1, mode_p);

    const rst = 0;
    const en = 0;
    // build the data to send
    const data = fpasim_build_ctrl(rst, en);
    sendToFPAsim_configureControl(data);
    // fpasim_set_ctrl(rst, en, level1, mode_p, verbosity_p);
    const msg = "";
    display(msg, level1, mode_p);

    waitMs(10);

    CDCE72010_configure(level1, mode_p, verbosity_p);
    ADS62P49_configure(level1, mode_p, verbosity_p);
    DAC3283_configure(level1, mode_p, verbosity_p);
    AMC7823_configure(level1, mode_p, verbosity_p);

    return 0;

}


/**
 * Check if 2 values are equal. Then, display the result.
 * @param {number} value0_p - first value to compare.
 * @param {number} value1_p - 2nd  value to compare.
 * @param {string} msg_p - error message.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @return {number} 0
 */
function check_equal(value0_p, value1_p, msg_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    const str_data0 = convert_int_to_str_hex(value0_p, 32);
    const str_data1 = convert_int_to_str_hex(value1_p, 32);

    if (value0_p !== value1_p) {
        const msg_tmp = "[KO]: " + msg_p;
        display(msg_tmp, level0, mode_p);
        if (verbosity_p > 0) {
            const msg = "[check_equal]: value0_p: 0x" + str_data0 + " !=  value_1_p: 0x" + str_data1;
            display(msg, level1, mode_p);

        }
        return -1
    } else {
        const msg = "[OK]: " + msg_p;
        display(msg, level0, mode_p);
        if (verbosity_p > 0) {
            const msg = "[check_equal]: value0_p: 0x" + str_data0 + " ==  value_1_p: 0x" + str_data1;
            display(msg, level1, mode_p);
        }
        return 0
    }
}

/**
 * Check if 2 tables are identical. Then, display the result.
 * @param {array of number} tab0_p - 1st tab.
 * @param {array of number} tab1_p - 2nd tab.
 * @param {string} msg_p - error message.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @return {number} 0
 */
function check_equal_tab(tab0_p, tab1_p, msg_p, level_p, mode_p, verbosity_p)

{
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;
    error = 0;

    for (i = 0; i <= tab0_p.length; i++) {
        const value0 = tab0_p[i];
        const value1 = tab1_p[i];

        if (value0 != value1) {
            if (verbosity_p > 0) {
                const msg = "index: " + i.toString(10) + " value0_p: " + value0.toString(10) + " ,value1_p:" + value1.toString(10);
                display(msg, level_p, mode_p);

            }
            error = 1;
        }
    }

    const error2 = check_equal(error, 0, msg_p, level_p, mode_p, verbosity_p);
    return error2;

}

/**
 * Enable the dac pattern checker at the dac device side and the dac pattern generator at the FPGA side.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} 0
 */
function fpasim_dac_enable_pattern(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const msg = "[fpasim_dac_enable_pattern]";
    display(msg, level0, mode_p);

    // Enable the dac pattern checker
    // DAC3283_enable_pattern(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    // Enable the SPI on the FPGA board
    const msg = "Enable the FPASim spi bridge";
    display(msg, level1, mode_p);
    dac_spi_enable(level1, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);



    //###############################################################
    // dac_config1
    //###############################################################
    // When asserted the QMC offset correction circuitry is enabled.
    // [7]: R/W: qmc_offset_ena[0]
    //
    // When asserted the QMC phase and gain correction circuitry is enabled.
    // [6]: R/W: qmc_correct_ena[0]
    //
    // When asserted FIR0 is activated enabling 2x interpolation.
    // [5]: R/W: fir0_ena[0]
    //
    // When asserted FIR1 is activated enabling 4x interpolation. fir0_ena must be set to '1' for 4x interpolation.
    // [4]: R/W: fir1_ena[0]
    //
    // When asserted enables the data pattern checker operation.
    // [2]: R/W: iotest_ena[0]
    //
    // When asserted the inputs are expected to be in 2's complement format. When
    // de-asserted the input format is expected to be offset-binary.
    // [0]: R/W: twos[0]
    const qmc_offset_ena = 0;
    const qmc_correct_ena = 0;
    const fir0_ena = 0;
    const fir1_ena = 0;
    const iotest_ena = 1;
    const twos = 1;

    const msg = "Enable the dac pattern checker (dac device)";
    display(msg, level1, mode_p);

    dac_set_config1(qmc_offset_ena, qmc_correct_ena,
        fir0_ena, fir1_ena,
        iotest_ena, twos,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);


    /*
     *
     * Enable pattern generation in the fpga
     */
    const adc1_bypass = 0;
    const adc0_bypass = 0;
    const dac_en_pattern = 1;
    const rst_status = 0;
    const debug_pulse = 0;

    const msg = "Enable the FPASim dac pattern generator";
    display(msg, level1, mode_p);
    fpasim_set_debug_ctrl(adc1_bypass, adc0_bypass, dac_en_pattern, rst_status, debug_pulse, level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     Enable the fpasim function
      ***************************************************************************
      */
    const rst = 0;
    const en = 1;
    const data = fpasim_build_ctrl(rst, en);
    const msg = "Enable the FPASIM function";
    display(msg, level1, mode_p);
    // sendToFPAsim_configureControl(data);
    fpasim_set_ctrl(rst, en, level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);

    /*
    run at least 100 pattern sequence
      . @500MHz: t = 100*8(patterns)*2 =1600 ns
    */
    const tempo = 10;
    const msg = "wait for " + tempo.toString(10) + " ms";
    display(msg, level1, mode_p);
    waitMs(tempo);

    const msg = "";
    display(msg, level1, mode_p);

    /*
    clear the iotest_results (config8)
    */
    const iotest_results = 0x0;
    const msg = "Reset iotest_results (dac device)";
    display(msg, level1, mode_p);
    dac_set_config8(iotest_results, level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);
    /*
    clear the alarm_from_iotest (config7)
    */
    const alarm_from_zerochk = 0;
    const alarm_fifo_collision = 0;
    const alarm_from_iotest = 0;
    const alarm_fifo_2away = 0;
    const alarm_fifo1away = 0;
    const msg = "Reset alarms bits (dac device)";
    display(msg, level1, mode_p);
    dac_set_config7(alarm_from_zerochk, alarm_fifo_collision, alarm_from_iotest, alarm_fifo_2away, alarm_fifo1away, level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);



}
/**
 * Disable the dac pattern checker at the dac device side and the dac pattern generator at the FPGA side.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} 0
 */
function fpasim_dac_disable_pattern(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const msg = "[fpasim_dac_disable_pattern]";
    display(msg, level0, mode_p);


    // Disable the dac pattern checker (spi device)
    // DAC3283_disable_pattern(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    //###############################################################
    // dac_config1
    //###############################################################
    // When asserted the QMC offset correction circuitry is enabled.
    // [7]: R/W: qmc_offset_ena[0]
    //
    // When asserted the QMC phase and gain correction circuitry is enabled.
    // [6]: R/W: qmc_correct_ena[0]
    //
    // When asserted FIR0 is activated enabling 2x interpolation.
    // [5]: R/W: fir0_ena[0]
    //
    // When asserted FIR1 is activated enabling 4x interpolation. fir0_ena must be set to '1' for 4x interpolation.
    // [4]: R/W: fir1_ena[0]
    //
    // When asserted enables the data pattern checker operation.
    // [2]: R/W: iotest_ena[0]
    //
    // When asserted the inputs are expected to be in 2's complement format. When
    // de-asserted the input format is expected to be offset-binary.
    // [0]: R/W: twos[0]
    const qmc_offset_ena = 0;
    const qmc_correct_ena = 0;
    const fir0_ena = 0;
    const fir1_ena = 0;
    const iotest_ena = 0;
    const twos = 1;

    const msg = "Disable the dac pattern checker (dac device)";
    display(msg, level1, mode_p);

    dac_set_config1(qmc_offset_ena, qmc_correct_ena,
        fir0_ena, fir1_ena,
        iotest_ena, twos,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
     *
     * add tempo
     */
    const tempo = 10;
    const msg = "wait for " + tempo.toString(10) + " ms";
    display(msg, level1, mode_p);
    waitMs(tempo);

    const msg = "";
    display(msg, level1, mode_p);

    /*
     *
     * disable pattern generation in the fpga
     */
    const adc1_bypass = 0;
    const adc0_bypass = 0;
    const dac_en_pattern = 0;
    const rst_status = 0;
    const debug_pulse = 0;
    const msg = "Disable the FPASim dac pattern generator";
    display(msg, level1, mode_p);
    fpasim_set_debug_ctrl(adc1_bypass, adc0_bypass, dac_en_pattern, rst_status, debug_pulse, level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);


    /*
    disable the FPASim
    */

    const rst = 0;
    const en = 0;
    // build the data to send
    const data = fpasim_build_ctrl(rst, en);
    const msg = "Set CTRL: Enable Off"
    display(msg, level1, mode_p);
    // sendToFPAsim_configureControl(data);
    fpasim_set_ctrl(rst, en, level2, mode_p, verbosity_p);
    const msg = "";
    display(msg, level1, mode_p);

    const msg = "";
    display(msg, level1, mode_p);
}

/**
 * Check if the dac pattern checker (at the dac device side) has detected an error.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} iotest_results
 */
function fpasim_dac_get_pattern_result(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const msg = "[fpasim_dac_get_pattern_result]";
    display(msg, level0, mode_p);

    // get the general errors
    const msg = "Get the alarm_from_iotest error bit (dac device)";
    display(msg, level1, mode_p);

    const data = dac_get_config7(level2, mode_p, verbosity_p);
    // retrieves only the valid error bits when the dac is in pattern mode.
    const alarm_from_iotest = (data & 0x8);

    const msg = "";
    display(msg, level1, mode_p);


    /*
     * The values of these bits tell which bit in the byte-wide LVDS bus
     * failed during the pattern checker test.
     */
    // get the general errors
    const msg = "Get the error bits on the byte-wide LVDS bus (dac device)";
    display(msg, level1, mode_p);

    const iotest_results = dac_get_config8(level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);

    return iotest_results;
}

//---------------------------------------------------------------------------------------
// General functions
//---------------------------------------------------------------------------------------

/**
 * Display a popup menu with a pre-defined list of operators.
 * @return {string} Name of the operator.
 */
function get_operator_name() {
    operator_tab = ["", "David", "Corentin", "Odile", "Laurent", "Ken", "Yann"]
    operator_id = getItem("Please, select the operator name:", operator_tab)
    if (operator_id == -1) {
        operator_name = getText("Please, type the operator name:", "")
    } else {
        operator_name = operator_tab[operator_id]
    }
    return (operator_name)
}

/**
 * Display a popup menu in order to define a session by the user.
 * @return {string} Name of the session.
 */
function get_session_name() {
    const session_name = getText("Please, type the session name:", "Default_session_name");
    return (session_name);
}

/**
 * Format the current date.
 * @return {string} formatted date.
 */
function maDate()
// Returns the date using the format : yearmonthday_hourminutesecond
{
    const d = new Date();
    const Now_date = d.getFullYear() + (("00" + (d.getMonth() + 1).toString()).slice(-2)) + (("00" + (d.getDate()).toString()).slice(-2)) + "_" + (("00" + (d.getHours()).toString()).slice(-2)) + (("00" + (d.getMinutes()).toString()).slice(-2)) + (("00" + (d.getSeconds()).toString()).slice(-2));
    return Now_date;
}

//---------------------------------------------------------------------------------------
// RAMs functions: write ram content from a file
//---------------------------------------------------------------------------------------
/**
 * This function does the following steps:
 *  1. reads an *.mem input file
 *  2. store the file data part into an array
 *  3. return the build array
 *
 * @param {number} file_p - filepath to the *.mem file
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {array} data file contents.
 */
// var fileDataArray
// var fileDataOffset
function loadFromFile(file_p,level_p, mode_p, verbosity_p)
{
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    const msg = "[loadFromFile]: "+file_p;
    display(msg, level0, mode_p);

    fileContent = readTextFile(file_p);

    if (fileContent.length > 1 )
    {
        if (fileContent[0].slice(0,1) == "@")
        {
            // fileDataOffset = parseInt(fileContent[0].slice(1),16)
            fileDataArray = new Array(fileContent.length - 1);
            for (i =1; i < fileContent.length;++i)
                {
                    fileDataArray[i - 1] = parseInt(fileContent[i],16);
                }

            const array_length = fileDataArray.length;
            const msg = "OK: array size: "+array_length.toString(10);
            display(msg, level1, mode_p);
            return fileDataArray;
            // return fileDataArray.length

        }
        else
        {
            const msg = "KO: bad file format...";
            display(msg, level1, mode_p);
            // fileDataOffset = parseInt(fileContent[0],16)
            fileDataArray = new Array(1);
            return fileDataArray;
            // return 0
        }

    }
    else
        {
            const msg = "KO: bad file format or file not found...";
            display(msg, level1, mode_p);
            // fileDataOffset = parseInt(fileContent[0],16)
            fileDataArray = new Array(1);
            return fileDataArray;
            // return 0
        }
}

/**
 * This function does the following steps:
 *  1. reads an *.mem input file
 *  2. store the file data part into an array
 *  3. send the array into the FPAsim RAM (tes_pulse_shape)
 *  4. return the array if no errors
 *
 * @param {number} file_p - filepath to the *.mem file
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {array} written ram data.
 */
function fpasim_loadTES_PulseShape_From_File(file_p,level_p, mode_p, verbosity_p)
{
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // function name
    msg = "[fpasim_loadTES_PulseShape_From_File]";
    display(msg, level0, mode_p);

    // expected number of read data values from the input file
    const expected_array_size = 32768;

    // read value from the file
    array = loadFromFile(file_p, level1, mode_p, verbosity_p);
    array_length = array.length;

    if (array_length != expected_array_size)
    {
        msg = "[KO]: bad File size";
        display(msg, level1, mode_p);

        msg = "  expected: " + expected_array_size.toString(10);
        display(msg, level2, mode_p);

        msg = "  file size:" + array_length+toString(10);
        display(msg, level2, mode_p);

        // error code
        return -1;
    }

    // send the array to the fpasim
    sendToFPAsim_loadTES_pulseShape(array);

    // no error
    return 0;
}

/**
 * This function does the following steps:
 *  1. reads an *.mem input file
 *  2. store the file data part into an array
 *  3. send the array into the FPAsim RAM (amp_squid_tf)
 *  4. return the array if no errors
 *
 * @param {number} file_p - filepath to the *.mem file
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {array} written ram data.
 */
function fpasim_sendToFPA_loadAmpSQUID_TF_From_File(file_p,level_p, mode_p, verbosity_p)
{
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // function name
    msg = "[fpasim_sendToFPA_loadAmpSQUID_TF_From_File]";
    display(msg, level0, mode_p);
    // expected number of read data values from the input file
    const expected_array_size = 16384;

    // read value from the file
    array = loadFromFile(file_p, level1, mode_p, verbosity_p);
    array_length = array.length

    if (array_length != expected_array_size)
    {
        msg = "[KO]: bad File size";
        display(msg, level1, mode_p);

        msg = "  expected: " + expected_array_size.toString(10);
        display(msg, level2, mode_p);

        msg = "  file size:" + array_length+toString(10);
        display(msg, level2, mode_p);

        // error code
        return -1;
    }

    // send the array to the fpasim
    sendToFPAsim_loadSQA_TF(array);

   // no error
    return 0;
}

/**
 * This function does the following steps:
 *  1. reads an *.mem input file
 *  2. store the file data part into an array
 *  3. send the array into the FPAsim RAM (mux_squid_tf)
 *  4. return the array if no errors
 *
 * @param {number} file_p - filepath to the *.mem file
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {array} written ram data.
 */
function fpasim_sendToFPA_loadMuxSQUID_TF_From_File(file_p,level_p, mode_p, verbosity_p)
{
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // function name
    msg = "[fpasim_sendToFPA_loadMuxSQUID_TF_From_File]";
    display(msg, level0, mode_p);
    // expected number of read data values from the input file
    const expected_array_size = 8192;

    // read value from the file
    array = loadFromFile(file_p, level1, mode_p, verbosity_p);
    array_length = array.length

    if (array_length != expected_array_size)
    {
        msg = "[KO]: bad File size";
        display(msg, level1, mode_p);

        msg = "  expected: " + expected_array_size.toString(10);
        display(msg, level2, mode_p);

        msg = "  file size:" + array_length+toString(10);
        display(msg, level2, mode_p);

        // error code
        return -1;
    }

    // send the array to the fpasim
    sendToFPAsim_loadSQM_TF(array);

    // no error
    return 0;
}

/**
 * This function does the following steps:
 *  1. reads an *.mem input file
 *  2. store the file data part into an array
 *  3. send the array into the FPAsim RAM (tes_steady_state)
 *  4. return the array if no errors
 *
 * @param {number} file_p - filepath to the *.mem file
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {array} written ram data.
 */
function fpasim_sendToFPA_loadTES_SteadyState_From_File(file_p,level_p, mode_p, verbosity_p)
{

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // function name
    msg = "[fpasim_sendToFPA_loadTES_SteadyState_From_File]";
    display(msg, level0, mode_p);

    // expected number of read data values from the input file
    const expected_array_size = 64;

    // read value from the file
    array = loadFromFile(file_p, level1, mode_p, verbosity_p);
    array_length = array.length

    if (array_length != expected_array_size)
    {
        msg = "[KO]: bad File size";
        display(msg, level1, mode_p);

        msg = "  expected: " + expected_array_size.toString(10);
        display(msg, level2, mode_p);

        msg = "  file size:" + array_length+toString(10);
        display(msg, level2, mode_p);

        // error code
        return -1;
    }


    // send the array to the fpasim
    sendToFPAsim_loadTES_steadyState(array);

    // no error
    return 0;
}

/**
 * This function does the following steps:
 *  1. reads an *.mem input file
 *  2. store the file data part into an array
 *  3. send the array into the FPAsim RAM (mux_squid_offset)
 *  4. return the array if no errors
 *
 * @param {number} file_p - filepath to the *.mem file
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {array} written ram data.
 */
function fpasim_sendToFPA_loadMuxSQUID_Offset_From_File(file_p,level_p, mode_p, verbosity_p)
{

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // function name
    msg = "[fpasim_sendToFPA_loadMuxSQUID_Offset_From_File]";
    display(msg, level0, mode_p);
    // expected number of read data values from the input file
    const expected_array_size = 64;

    // read value from the file
    array = loadFromFile(file_p, level1, mode_p, verbosity_p);
    array_length = array.length

    if (array_length != expected_array_size)
    {
        msg = "[KO]: bad File size";
        display(msg, level1, mode_p);

        msg = "  expected: " + expected_array_size.toString(10);
        display(msg, level2, mode_p);

        msg = "  file size:" + array_length+toString(10);
        display(msg, level2, mode_p);

        // error code
        return -1;
    }


    // send the array to the fpasim
    sendToFPAsim_loadSQM_offset(array);

    // no error
    return 0;
}

/**
 * Configure the default value of the fpasim rams
 *  Note:
 *    .The spi device needs to be configured before in order to get
 *    the FPAsim clocks.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} 0
 */
function configure_fpasim_default_ram(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const msg = "[configure_fpasim_default_ram]";
    display(msg, level0, mode_p);

    // relative path from the main script (the calling script path)
    ram_base_path = "./fpasim_default_ram/"

    tes_pulse_shape_filepath  = ram_base_path + "tes_pulse_shape.mem"
    tes_std_state_filepath    = ram_base_path + "tes_std_state.mem"
    mux_squid_offset_filepath = ram_base_path + "mux_squid_offset.mem"
    mux_squid_tf_filepath     = ram_base_path + "mux_squid_tf.mem"
    amp_squid_tf_filepath     = ram_base_path + "amp_squid_tf.mem"

    err0 = fpasim_loadTES_PulseShape_From_File(tes_pulse_shape_filepath,level1, mode_p, verbosity_p);
    err1 = fpasim_sendToFPA_loadTES_SteadyState_From_File(tes_std_state_filepath,level1, mode_p, verbosity_p);
    err2 = fpasim_sendToFPA_loadMuxSQUID_Offset_From_File(mux_squid_offset_filepath,level1, mode_p, verbosity_p);
    err3 = fpasim_sendToFPA_loadMuxSQUID_TF_From_File(mux_squid_tf_filepath,level1, mode_p, verbosity_p);
    err4 = fpasim_sendToFPA_loadAmpSQUID_TF_From_File(amp_squid_tf_filepath,level1, mode_p, verbosity_p);

    errors_cnt = err0 + err1 + err2 + err3 + err4;

    // negative -> positive value
    errors_cnt = errors_cnt * -1;

    return errors_cnt;

}


/**
 * convert a percentage into a pulse height value.
 *   This computed value is used by the "MAKE PULSE" register.
 * @param {number} percentage_p - percentage. The range is [0,1.0]
 */
function fpasim_convert_percentage_to_pulse_height(percentage_p) {

    value = percentage_p * (Math.pow(2, 16) - 1) / 100;
    return Math.round(value);
}

//---------------------------------------------------------------------------------------