// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   ads62p49.py
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//   This script defines base functions to access (read/write) the ADC device (FMC150 card) via the FPASim SPI module bridge.
//
//   Note:
//      . Tested with javascript
//
// -------------------------------------------------------------------------------------------------------------

// import libraries
//include("./fpasim/utils_tools.dscript");
//include("./fpasim/fpasim.dscript");


// define the SPI device registers (see datasheet: ads62p49  device)
const ADC_ADDR = {};
ADC_ADDR['reg0'] = 0x00;
ADC_ADDR['reg1'] = 0x20;
ADC_ADDR['reg2'] = 0x3F;
ADC_ADDR['reg3'] = 0x40;
ADC_ADDR['reg4'] = 0x41;
ADC_ADDR['reg5'] = 0x44;
ADC_ADDR['reg6'] = 0x50;
ADC_ADDR['reg7'] = 0x51;
ADC_ADDR['reg8'] = 0x52;
ADC_ADDR['reg9'] = 0x53;
ADC_ADDR['reg10'] = 0x55;
ADC_ADDR['reg11'] = 0x57;
ADC_ADDR['reg12'] = 0x62;
ADC_ADDR['reg13'] = 0x63;
ADC_ADDR['reg14'] = 0x66;
ADC_ADDR['reg15'] = 0x68;
ADC_ADDR['reg16'] = 0x6A;
ADC_ADDR['reg17'] = 0x75;
ADC_ADDR['reg18'] = 0x76;

// verbosity min to display register access
const c_ADC_REG_VERBOSITY_MIN = 0;
// verbosity min to display (addr,data)
const c_ADC_ADDR_VERBOSITY_MIN = 1;
// verbosity min to display register bit
const c_ADC_BIT_VERBOSITY_MIN = 2;

// address width of the spi device register
const c_ADC_SPI_ADDR_WIDTH = 8;
// data width of the spi device register
const c_ADC_SPI_DATA_WIDTH = 8;

/**
 * Enable the FPASIM SPI MODULE (bridge)
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function adc_spi_enable(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    //---------------------------------------------------------------------
    //-- write in the SPI_CTRL register
    //---------------------------------------------------------------------

    // en the spi links
    const rst = 0;
    const en = 1;
    fpasim_set_spi_ctrl(rst, en, level0, mode_p, verbosity_p);

}

/**
 * Write a spi device register through the FPASIM SPI MODULE (bridge).
 *
 * @param {number} addr_p - register address of the SPI device to write.
 * @param {number} data_p - value to write in the spi device register.
 */
function adc_write_command(addr_p, data_p) {

    //---------------------------------------------------------------------
    // write in the SPI_CONF0 register
    //---------------------------------------------------------------------
    const spi_mode = 1; // 0: rd, 1: wr
    const spi_id = 1; // 0: cdce,1: adc, 2: dac, 3: amc
    fpasim_set_spi_conf0(spi_id, spi_mode, 0, 0, -1);

    //---------------------------------------------------------------------
    // build and write the SPI commands
    //   (see the ads62p49 datasheet)
    //---------------------------------------------------------------------
    const spi_cmd = (addr_p << 8) + data_p;
    fpasim_set_spi_wr_data(spi_cmd, 0, 0, -1);

}

/**
 * Read spi device register value.
 *
 * @param {number} addr_p - register address of the SPI device to read.
 * @return {number} read value from the spi device register.
 *
 */
function adc_read_command(addr_p) {

    //---------------------------------------------------------------------
    // Enable the read on the spi device
    //---------------------------------------------------------------------
    const rst0 = 0; //  Software reset applied – resets all internal registers and self-clears to 0.
    const serial_out0 = 1; //0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).1:Serial readout enabled, Pin SDOUT functions as serial data readout.
    adc_set_config0(
        rst0, serial_out0,
        0, 0, -1
    );

    //---------------------------------------------------------------------
    // write in the SPI_CONF0 register
    //---------------------------------------------------------------------
    const spi_mode = 0; // 0: rd, 1: wr
    const spi_id = 1; // 0: cdce,1: adc, 2: dac, 3: amc
    fpasim_set_spi_conf0(spi_id, spi_mode, 0, 0, -1);

    //---------------------------------------------------------------------
    // build and write the SPI commands
    //   (see the ads62p49 datasheet)
    //---------------------------------------------------------------------
    data = 0x0;
    const spi_cmd = (addr_p << 8) + data;
    fpasim_set_spi_wr_data(spi_cmd, 0, 0, -1);

    // tempo
    waitMs(10);

    //---------------------------------------------------------------------
    // Read the register value from the spi device
    //---------------------------------------------------------------------
    data = fpasim_get_wireout_spi_rd_data(0, 0, -1);

    //---------------------------------------------------------------------
    // Disable the read on the spi device
    //---------------------------------------------------------------------
    const rst1 = 0; //  Software reset applied – resets all internal registers and self-clears to 0.
    const serial_out1 = 0; //0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).1:Serial readout enabled, Pin SDOUT functions as serial data readout.
    adc_set_config0(
        rst1, serial_out1,
        0, 0, -1
    );


    // keep only the data part
    // from: addr7 .. addr0 data7 .. data0
    // to: data7.. data0
    data = (data & 0xFF);

    return data;

}

/**
 * Set the register0 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [7]: rst
 *     1: Software reset applied – resets all internal registers and self-clears to 0.
 *     0: do nothing
 *  [0] : serial_out
 *     0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).
 *     1: Serial readout enabled, Pin SDOUT functions as serial data readout.
 */
function adc_set_config0(rst_p, serial_out_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (rst_p << 7) + serial_out_p;
    const addr = ADC_ADDR['reg0'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config0]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("rst_p", rst_p, 1, level2, mode_p);
            display_bit("serial_out_p", serial_out_p, 1, level2, mode_p);
        }
    }

}

/**
 * Set the register1 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [2]: enable_low_speed
 *  0: LOW SPEED mode disabled. Use for sampling frequency > 80 MSPS
 *  1: Enable LOW SPEED mode for sampling frequencies ≤ 80 MSPS.
 *
 */
function adc_set_config1(enable_low_speed_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (enable_low_speed_p << 2);
    const addr = ADC_ADDR['reg1'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config1]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("enable_low_speed_p", enable_low_speed_p, 1, level2, mode_p);
        }
    }

}

/**
 * Set the register2 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [6:5] ref: Internal or external reference selection
 *       00 : Internal reference enabled
 *       01:
 *       10:
 *       11: External reference enabled
 *  [1]: standby <STANDBY>
 *       0 Normal operation
 *       1 Both ADC channels are put in standby. Internal references, output buffers are active. This results in
 *    quick wake-up time from standby.
 */
function adc_set_config2(ref_p, standby_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (ref_p << 5) + (standby_p << 1);
    const addr = ADC_ADDR['reg2'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config2]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("ref_p", ref_p, 2, level2, mode_p);
            display_bit("standby_p", standby_p, 1, level2, mode_p);
        }
    }

}


/**
 * Set the register3 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [3:0]: power_down
 *    0000 Pins CTRL1, CTRL2, and CTRL3 determine power down modes.
 *    1000 Normal operation
 *    1001 Output buffer disabled for channel B
 *    1010 Output buffer disabled for channel A
 *    1011 Output buffer disabled for channel A and B
 *    1100 Global power down
 *    1101 Channel B standby
 *    1110 Channel A standby
 *    1111 Multiplexed mode, MUX- (only with CMOS interface)
 *       Channel A and B data is multiplexed and output on DA13 to DA0 pins. Refer to the Multiplexed
 *       Output Mode section in the APPLICATION INFORMATION for additional information.
 *
 */
function adc_set_config3(power_down_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = power_down_p;
    const addr = ADC_ADDR['reg3'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config3]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("power_down_p", power_down_p, 4, level2, mode_p);
        }
    }

}


/**
 * Set the register4 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [7]: lvds_cmos
 *    0 Parallel CMOS interface
 *    1 DDR LVDS interface
 */
function adc_set_config4(lvds_cmos_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (lvds_cmos_p << 7);
    const addr = ADC_ADDR['reg4'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config4]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("lvds_cmos_p", lvds_cmos_p, 1, level2, mode_p);
        }
    }
}

/**
 * Set the register5 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  LVDS interface
 *     [7:5] clkout_pos_rise Output clock rising edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Falling edge shifted (delayed) by + (4/26)×Ts(1)
 *        110 Falling edge shifted (advanced) by – (7/26)×Ts
 *        111 Falling edge shifted (advanced) by – (4/26)×Ts
 *     [4:2] clkout_pos_fall Output clock falling edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Rising edge shifted (delayed) by + (4/26)×Ts
 *        110 Rising edge shifted (advanced) by – (7/26)×Ts
 *        111 Rising edge shifted (advanced) by – (4/26)×Ts
 *  CMOS interface
 *     [7:5]: clkout_pos_rise Output clock rising edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Rising edge shifted (delayed) by + (4/26)×Ts
 *        110 Rising edge shifted (advanced) by – (7/26)×Ts
 *        111 Rising edge shifted (advanced) by – (4/26)×Ts
 *     [4:2] clkout_pos_fall Output clock falling edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Falling edge shifted (delayed) by + (4/26)×Ts
 *        110 Falling edge shifted (advanced) by – (7/26)×Ts
 *        111 Falling edge shifted (advanced) by – (4/26)×Ts
 *  Note:
 *        (1) Ts = 1 / sampling frequency
 *        (2) Keep the same duty cycle, move both edges by the same amount (i.e., write both D<4:2> and D<7:5> to be
 *        the same value).
 *
 */
function adc_set_config5(clkout_pos_rise_p, clkout_pos_fall_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (clkout_pos_rise_p << 5) + clkout_pos_fall_p;
    const addr = ADC_ADDR['reg5'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config5]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("clkout_pos_rise_p", clkout_pos_rise_p, 3, level2, mode_p);
            display_bit("clkout_pos_fall_p", clkout_pos_fall_p, 3, level2, mode_p);
        }
    }

}

/**
 * Set the register6 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [6]: en_independant_chan_ctrl
 *     0 Common control – both channels use common control settings for test patterns, offset correction,
 *       fine gain, gain correction and SNR Boost functions. These settings can be specified in a single set of registers.
 *     1 Independent control – both channels can be programmed with independent control settings for test
 *       patterns, offset correction and SNR Boost functions. Separate registers are available for each channel.
 *  [2:1]: data_format
 *    10 2s complement
 *    11 Offset binary
 *
 */
function adc_set_config6(en_independant_chan_ctrl_p, data_format_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (en_independant_chan_ctrl_p << 6) + (data_format_p << 1);
    const addr = ADC_ADDR['reg6'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config6]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("en_independant_chan_ctrl_p", en_independant_chan_ctrl_p, 1, level2, mode_p);
            display_bit("data_format_p", data_format_p, 2, level2, mode_p);
        }
    }
}

/**
 * Set the register7 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [7:0] custom_pattern_low
 *    8 lower bits of custom pattern available at the output instead of ADC data.
 *  Note: Use this mode along with “Test Patterns” (register 0x62).
 *
 */
function adc_set_config7(custom_patter_low_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = custom_patter_low_p;
    const addr = ADC_ADDR['reg7'];
    adc_write_command(0x51, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config7]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("custom_patter_low_p", custom_patter_low_p, 8, level2, mode_p);
        }
    }

}

/**
 * Set the register8 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [5:0] custom_pattern_high
 *    6 upper bits of custom pattern available at the output instead of ADC data
 *  Note: Use this mode along with “Test Patterns” (register 0x62).
 *
 */
function adc_set_config8(custom_patter_high_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = custom_patter_high_p;
    const addr = ADC_ADDR['reg8'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config8]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("custom_patter_high_p", custom_patter_high_p, 6, level2, mode_p);
        }
    }

}

/**
 * Set the register9 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [6]:  en_offset_correction – Common/Ch A>
 *       Offset correction enable control for both channels (with common control) or for channel A only (with
 *       independent control).
 *    0 Offset correction disabled
 *    1 Offset correction enabled
 *
 */
function adc_set_config9(en_offset_correction_cha_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (en_offset_correction_cha_p << 6);
    const addr = ADC_ADDR['reg9'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config9]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("en_offset_correction_cha_p", en_offset_correction_cha_p, 1, level2, mode_p);
        }
    }
}
/**
 * Set the register10 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [7:4] gain_common_or_cha <GAIN – Common/Ch A>
 *   Gain control for both channels (with common control) or for channel A only (with independent control).
 *     0000 0 dB gain, default after reset
 *     0001 0.5 dB gain
 *     0010 1.0 dB gain
 *     0011 1.5 dB gain
 *     0100 2.0 dB gain
 *     0101 2.5 dB gain
 *     0110 3.0 dB gain
 *     0111 3.5 dB gain
 *     1000 4.0 dB gain
 *     1001 4.5 dB gain
 *     1010 5.0 dB gain
 *     1011 5.5 dB gain
 *     1100 6.0 dB gain
 *  [3:0] offset_corr_time_common_or_cha <OFFSET CORR TIME CONSTANT – Common/Ch A>
 *     Correction loop time constant in number of clock cycles.
 *     Applies to both channels (with common control) or for channel A only (with independent control).
 *     0000 256 k
 *     0001 512 k
 *     0010 1 M
 *     0011 2 M
 *     0100 4 M
 *     0101 8 M
 *     0110 16 M
 *     0111 32 M
 *     1000 64 M
 *     1001 128 M
 *     1010 256 M
 *     1011 512 M
 *
 */
function adc_set_config10(gain_common_or_cha_p, offset_corr_time_common_or_cha_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (gain_common_or_cha_p << 4) + offset_corr_time_common_or_cha_p;
    const addr = ADC_ADDR['reg10'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config10]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("gain_common_or_cha_p", gain_common_or_cha_p, 4, level2, mode_p);
            display_bit("offset_corr_time_common_or_cha_p", offset_corr_time_common_or_cha_p, 4, level2, mode_p);
        }
    }

}
/**
 * Set the register11 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * [6:0] fine_gain_adjust_common_or_cha
 * Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
 * additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
 * trimmed channel gain is:
 *     Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
 * Note: that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
 *      <GAIN PROGRAMMABILITY>
 *
 */
function adc_set_config11(fine_gain_adjust_common_or_cha_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (fine_gain_adjust_common_or_cha_p);
    const addr = ADC_ADDR['reg11'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config11]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("fine_gain_adjust_common_or_cha_p", fine_gain_adjust_common_or_cha_p, 7, level2, mode_p);
        }
    }

}
/**
 * Set the register12 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * [2:0] test_pattern_common_or_cha Test Patterns to verify data capture.
 *   Applies to both channels (with common control) or for channel A only (with independent control).
 *   000 Normal operation
 *   001 Outputs all zeros
 *   010 Outputs all ones
 *   011 Outputs toggle pattern – see Figure 14 and Figure 15 for test pattern timing diagrams for LVDS and CMOS modes.
 *       In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
 *       In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
 *   100 Outputs digital ramp
 *        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
 *        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
 *   101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
 *   110 Unused
 *   111 Unused
 */
function adc_set_config12(test_pattern_common_or_cha_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (test_pattern_common_or_cha_p);
    const addr = ADC_ADDR['reg12'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config12]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("test_pattern_common_or_cha_p", test_pattern_common_or_cha_p, 3, level2, mode_p);
        }
    }

}

/**
 * Set the register13 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [5:0]: offset_pedestal_common_or_cha <OFFSET PEDESTAL – Common/Ch A>
 *        When the offset correction is enabled, the final converged value (after the offset is corrected) will
 *        be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
 *        added to the final converged value by programming these bits. So, the final converged value will
 *        be = ideal mid-code + PEDESTAL.
 *        See "Offset Correction" in application section.
 *        Applies to both channels (with common control) or for channel A only (with independent control).
 *     011111 PEDESTAL = 31 LSB
 *     011110 PEDESTAL = 30 LSB
 *     011101 PEDESTAL = 29 LSB
 *     ...
 *     000000 PEDESTAL = 0
 *     ...
 *     111111 PEDESTAL = –1 LSB
 *     111110 PEDESTAL = –2 LSB
 *     ...
 *     100000 PEDESTAL = –32 LSB
 */

function adc_set_config13(offset_pedestal_common_or_cha_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (offset_pedestal_common_or_cha_p);
    const addr = ADC_ADDR['reg13'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config13]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("offset_pedestal_common_or_cha_p", offset_pedestal_common_or_cha_p, 6, level2, mode_p);
        }
    }


}

/**
 * Set the register14 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [6] offset_corr_chb
 *      Offset correction enable control for channel B (only with independent control).
 *    0 offset correction disabled
 *    1 offset correction enabled
 */

function adc_set_config14(offset_corr_chb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (offset_corr_chb_p << 6);
    const addr = ADC_ADDR['reg14'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config14]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("offset_corr_chb_p", offset_corr_chb_p, 1, level2, mode_p);
        }
    }


}
/**
 * Set the register15 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [7:4] gain_chb Gain programmability to 0.5 dB steps.
 *        Applies to channel B (only with independent control).
 *     0000 0 dB gain, default after reset
 *     0001 0.5 dB gain
 *     0010 1.0 dB gain
 *     0011 1.5 dB gain
 *     0100 2.0 dB gain
 *     0101 2.5 dB gain
 *     0110 3.0 dB gain
 *     0111 3.5 dB gain
 *     1000 4.0 dB gain
 *     1001 4.5 dB gain
 *     1010 5.0 dB gain
 *     1011 5.5 dB gain
 *     1100 6.0 dB gain
 *  [3:0] offset_corr_time_chb Time constant of correction loop in number of clock cycles.
 *        Applies to channel B (only with independent control)
 *   0000 256 k
 *   0001 512 k
 *   0010 1 M
 *   0011 2 M
 *   0100 4 M
 *   0101 8 M
 *   0110 16 M
 *   0111 32 M
 *   1000 64 M
 *   1001 128 M
 *   1010 256 M
 *   1011 512 M
 *
 */
function adc_set_config15(gain_chb_p, offset_corr_time_chb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = (gain_chb_p << 4) + offset_corr_time_chb_p;
    const addr = ADC_ADDR['reg15'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config15]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("gain_chb_p", gain_chb_p, 4, level2, mode_p);
            display_bit("offset_corr_time_chb_p", offset_corr_time_chb_p, 4, level2, mode_p);
        }
    }
}

/**
 * Set the register16 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * [7:0] fine_gain_adjust_chb
 *     Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
 *     additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
 *     trimmed channel gain is:
 *        Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
 * Note that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
 *  <GAIN PROGRAMMABILITY>
 *
 */
function adc_set_config16(fine_gain_adjust_chb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fine_gain_adjust_chb_p;
    const addr = ADC_ADDR['reg16'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config16]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("fine_gain_adjust_chb_p", fine_gain_adjust_chb_p, 8, level2, mode_p);
        }
    }
}
/**
 * Set the register17 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [2:0]: test_pattern_chb Test Patterns to verify data capture.
 *        Applies to channel B (only with independent control)
 *      000 Normal operation
 *      001 Outputs all zeros
 *      010 Outputs all ones
 *      011 Outputs toggle pattern – see Figure 14 and Figure 15 for LVDS and CMOS modes.
 *         In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
 *         In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
 *      100 Outputs digital ramp
 *         In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
 *         In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
 *      101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
 *      110 Unused
 *      111 Unused
 */

function adc_set_config17(test_pattern_chb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = test_pattern_chb_p;
    const addr = ADC_ADDR['reg17'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config17]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("test_pattern_chb_p", test_pattern_chb_p, 3, level2, mode_p);
        }
    }
}

/**
 * Set the register18 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 *  [5:0]: offset_pedestal_common_or_chb
 *        When the offset correction is enabled, the final converged value (after the offset is corrected) will
 *        be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
 *        added to the final converged value by programming these bits. So, the final converged value will
 *        be = ideal mid-code + PEDESTAL. See "Offset Correction" in application section.
 *        Applies to channel B (only with independent control).
 *    011111 PEDESTAL = 31 LSB
 *    011110 PEDESTAL = 30 LSB
 *    011101 PEDESTAL = 29 LSB
 *    ...
 *    000000 PEDESTAL = 0
 *    ...
 *    111111 PEDESTAL = –1 LSB
 *    111110 PEDESTAL = –2 LSB
 *    ...
 *    100000 PEDESTAL = –32 LSB
 */
function adc_set_config18(offset_pedestal_common_or_chb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = offset_pedestal_common_or_chb_p;
    const addr = ADC_ADDR['reg18'];
    adc_write_command(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_set_config18]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit("offset_pedestal_common_or_chb_p", offset_pedestal_common_or_chb_p, 6, level2, mode_p);
        }
    }
}

/**
 * Get the register0 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [7]: rst
 *     1: Software reset applied – resets all internal registers and self-clears to 0.
 *     0: do nothing
 *  [0] : serial_out
 *     0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).
 *     1: Serial readout enabled, Pin SDOUT functions as serial data readout.
 */
function adc_get_config0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg0'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config0]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("rst_p", 7, 1, data, level2, mode_p);
            display_bit_from_data("serial_out_p", 0, 1, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register1 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [2]: enable_low_speed
 *  0: LOW SPEED mode disabled. Use for sampling frequency > 80 MSPS
 *  1: Enable LOW SPEED mode for sampling frequencies ≤ 80 MSPS.
 *
 */
function adc_get_config1(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg1'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config1]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("enable_low_speed_p", 2, 1, data, level2, mode_p);
        }
    }
    return data;
}


/**
 * Get the register2 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [6:5] ref: Internal or external reference selection
 *       00 : Internal reference enabled
 *       01:
 *       10:
 *       11: External reference enabled
 *  [1]: standby <STANDBY>
 *       0 Normal operation
 *       1 Both ADC channels are put in standby. Internal references, output buffers are active. This results in
 *    quick wake-up time from standby.
 *
 */
function adc_get_config2(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg2'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config2]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("ref_p", 5, 2, data, level2, mode_p);
            display_bit_from_data("standby_p", 1, 1, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register3 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [3:0]: power_down
 *    0000 Pins CTRL1, CTRL2, and CTRL3 determine power down modes.
 *    1000 Normal operation
 *    1001 Output buffer disabled for channel B
 *    1010 Output buffer disabled for channel A
 *    1011 Output buffer disabled for channel A and B
 *    1100 Global power down
 *    1101 Channel B standby
 *    1110 Channel A standby
 *    1111 Multiplexed mode, MUX- (only with CMOS interface)
 *       Channel A and B data is multiplexed and output on DA13 to DA0 pins. Refer to the Multiplexed
 *       Output Mode section in the APPLICATION INFORMATION for additional information.
 *
 */
function adc_get_config3(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg3'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config3]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("power_down_p", 0, 4, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register4 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [7]: lvds_cmos
 *    0 Parallel CMOS interface
 *    1 DDR LVDS interface
 */
function adc_get_config4(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg4'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config4]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("lvds_cmos", 7, 1, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register5 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  LVDS interface
 *     [7:5] clkout_pos_rise Output clock rising edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Falling edge shifted (delayed) by + (4/26)×Ts(1)
 *        110 Falling edge shifted (advanced) by – (7/26)×Ts
 *        111 Falling edge shifted (advanced) by – (4/26)×Ts
 *     [4:2] clkout_pos_fall Output clock falling edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Rising edge shifted (delayed) by + (4/26)×Ts
 *        110 Rising edge shifted (advanced) by – (7/26)×Ts
 *        111 Rising edge shifted (advanced) by – (4/26)×Ts
 *  CMOS interface
 *     [7:5]: clkout_pos_rise Output clock rising edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Rising edge shifted (delayed) by + (4/26)×Ts
 *        110 Rising edge shifted (advanced) by – (7/26)×Ts
 *        111 Rising edge shifted (advanced) by – (4/26)×Ts
 *     [4:2] clkout_pos_fall Output clock falling edge position (2)
 *        000, 100 Default output clock position (refer to timing specification table)
 *        101 Falling edge shifted (delayed) by + (4/26)×Ts
 *        110 Falling edge shifted (advanced) by – (7/26)×Ts
 *        111 Falling edge shifted (advanced) by – (4/26)×Ts
 *  Note:
 *        (1) Ts = 1 / sampling frequency
 *        (2) Keep the same duty cycle, move both edges by the same amount (i.e., write both D<4:2> and D<7:5> to be
 *        the same value).
 */
function adc_get_config5(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg5'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config5]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("clkout_pos_rise_p", 5, 3, data, level2, mode_p);
            display_bit_from_data("clkout_pos_fall_p", 2, 3, data, level2, mode_p);
        }
    }
    return data;
}


/**
 * Get the register6 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [6]: en_independant_chan_ctrl
 *     0 Common control – both channels use common control settings for test patterns, offset correction,
 *       fine gain, gain correction and SNR Boost functions. These settings can be specified in a single set of registers.
 *     1 Independent control – both channels can be programmed with independent control settings for test
 *       patterns, offset correction and SNR Boost functions. Separate registers are available for each channel.
 *  [2:1]: data_format
 *    10 2s complement
 *    11 Offset binary
 */
function adc_get_config6(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg6'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config6]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("en_independant_chan_ctrl_p", 6, 1, data, level2, mode_p);
            display_bit_from_data("data_format_p", 1, 2, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register7 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [7:0] custom_pattern_low
 *    8 lower bits of custom pattern available at the output instead of ADC data.
 *  Note: Use this mode along with “Test Patterns” (register 0x62).
 *
 */
function adc_get_config7(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg7'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config7]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("custom_patter_low_p", 0, 8, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register8 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [5:0] custom_pattern_high
 *    6 upper bits of custom pattern available at the output instead of ADC data
 *  Note: Use this mode along with “Test Patterns” (register 0x62).
 *
 *
 */
function adc_get_config8(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg8'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config8]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("custom_patter_high_p", 0, 6, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register9 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [6]:  en_offset_correction – Common/Ch A>
 *       Offset correction enable control for both channels (with common control) or for channel A only (with
 *       independent control).
 *    0 Offset correction disabled
 *    1 Offset correction enabled
 *
 */
function adc_get_config9(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg9'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config9]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("en_offset_correction_cha_p", 6, 1, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register10 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [7:4] gain_common_or_cha <GAIN – Common/Ch A>
 *   Gain control for both channels (with common control) or for channel A only (with independent control).
 *     0000 0 dB gain, default after reset
 *     0001 0.5 dB gain
 *     0010 1.0 dB gain
 *     0011 1.5 dB gain
 *     0100 2.0 dB gain
 *     0101 2.5 dB gain
 *     0110 3.0 dB gain
 *     0111 3.5 dB gain
 *     1000 4.0 dB gain
 *     1001 4.5 dB gain
 *     1010 5.0 dB gain
 *     1011 5.5 dB gain
 *     1100 6.0 dB gain
 *  [3:0] offset_corr_time_common_or_cha <OFFSET CORR TIME CONSTANT – Common/Ch A>
 *     Correction loop time constant in number of clock cycles.
 *     Applies to both channels (with common control) or for channel A only (with independent control).
 *     0000 256 k
 *     0001 512 k
 *     0010 1 M
 *     0011 2 M
 *     0100 4 M
 *     0101 8 M
 *     0110 16 M
 *     0111 32 M
 *     1000 64 M
 *     1001 128 M
 *     1010 256 M
 *     1011 512 M
 *
 */
function adc_get_config10(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg10'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config10]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("gain_common_or_cha_p", 4, 4, data, level2, mode_p);
            display_bit_from_data("offset_corr_time_common_or_cha_p", 0, 4, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register11 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * [6:0] fine_gain_adjust_common_or_cha
 * Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
 * additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
 * trimmed channel gain is:
 *     Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
 * Note: that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
 *      <GAIN PROGRAMMABILITY>
 *
 */
function adc_get_config11(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg11'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config11]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("fine_gain_adjust_common_or_cha_p", 0, 7, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register12 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * [2:0] test_pattern_common_or_cha Test Patterns to verify data capture.
 *   Applies to both channels (with common control) or for channel A only (with independent control).
 *   000 Normal operation
 *   001 Outputs all zeros
 *   010 Outputs all ones
 *   011 Outputs toggle pattern – see Figure 14 and Figure 15 for test pattern timing diagrams for LVDS and CMOS modes.
 *       In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
 *       In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
 *   100 Outputs digital ramp
 *        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
 *        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
 *   101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
 *   110 Unused
 *   111 Unused
 *
 */
function adc_get_config12(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg12'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config12]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("test_pattern_common_or_cha_p", 0, 3, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register13 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [5:0]: offset_pedestal_common_or_cha <OFFSET PEDESTAL – Common/Ch A>
 *        When the offset correction is enabled, the final converged value (after the offset is corrected) will
 *        be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
 *        added to the final converged value by programming these bits. So, the final converged value will
 *        be = ideal mid-code + PEDESTAL.
 *        See "Offset Correction" in application section.
 *        Applies to both channels (with common control) or for channel A only (with independent control).
 *     011111 PEDESTAL = 31 LSB
 *     011110 PEDESTAL = 30 LSB
 *     011101 PEDESTAL = 29 LSB
 *     ...
 *     000000 PEDESTAL = 0
 *     ...
 *     111111 PEDESTAL = –1 LSB
 *     111110 PEDESTAL = –2 LSB
 *     ...
 *     100000 PEDESTAL = –32 LSB
 *
 */
function adc_get_config13(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg13'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config13]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("offset_pedestal_common_or_cha_p", 0, 6, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register14 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [6] offset_corr_chb
 *      Offset correction enable control for channel B (only with independent control).
 *    0 offset correction disabled
 *    1 offset correction enabled
 *
 */
function adc_get_config14(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg14'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config14]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("offset_corr_chb", 6, 1, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register15 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [7:4] gain_chb Gain programmability to 0.5 dB steps.
 *        Applies to channel B (only with independent control).
 *     0000 0 dB gain, default after reset
 *     0001 0.5 dB gain
 *     0010 1.0 dB gain
 *     0011 1.5 dB gain
 *     0100 2.0 dB gain
 *     0101 2.5 dB gain
 *     0110 3.0 dB gain
 *     0111 3.5 dB gain
 *     1000 4.0 dB gain
 *     1001 4.5 dB gain
 *     1010 5.0 dB gain
 *     1011 5.5 dB gain
 *     1100 6.0 dB gain
 *  [3:0] offset_corr_time_chb Time constant of correction loop in number of clock cycles.
 *        Applies to channel B (only with independent control)
 *   0000 256 k
 *   0001 512 k
 *   0010 1 M
 *   0011 2 M
 *   0100 4 M
 *   0101 8 M
 *   0110 16 M
 *   0111 32 M
 *   1000 64 M
 *   1001 128 M
 *   1010 256 M
 *   1011 512 M
 */
function adc_get_config15(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg15'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config15]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("gain_chb_p", 4, 4, data, level2, mode_p);
            display_bit_from_data("offset_corr_time_chb_p", 4, 4, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register16 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * [7:0] fine_gain_adjust_chb
 *     Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
 *     additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
 *     trimmed channel gain is:
 *        Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
 * Note that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
 *  <GAIN PROGRAMMABILITY>
 *
 */
function adc_get_config16(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg16'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config16]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("fine_gain_adjust_chb_p", 0, 8, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register17 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [2:0]: test_pattern_chb Test Patterns to verify data capture.
 *        Applies to channel B (only with independent control)
 *      000 Normal operation
 *      001 Outputs all zeros
 *      010 Outputs all ones
 *      011 Outputs toggle pattern – see Figure 14 and Figure 15 for LVDS and CMOS modes.
 *         In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
 *         In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
 *      100 Outputs digital ramp
 *         In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
 *         In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
 *      101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
 *      110 Unused
 *      111 Unused
 *
 */
function adc_get_config17(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg17'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config17]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("test_pattern_chb_p", 0, 3, data, level2, mode_p);
        }
    }
    return data;
}

/**
 * Get the register18 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *  [5:0]: offset_pedestal_common_or_chb
 *        When the offset correction is enabled, the final converged value (after the offset is corrected) will
 *        be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
 *        added to the final converged value by programming these bits. So, the final converged value will
 *        be = ideal mid-code + PEDESTAL. See "Offset Correction" in application section.
 *        Applies to channel B (only with independent control).
 *    011111 PEDESTAL = 31 LSB
 *    011110 PEDESTAL = 30 LSB
 *    011101 PEDESTAL = 29 LSB
 *    ...
 *    000000 PEDESTAL = 0
 *    ...
 *    111111 PEDESTAL = –1 LSB
 *    111110 PEDESTAL = –2 LSB
 *    ...
 *    100000 PEDESTAL = –32 LSB
 *
 */
function adc_get_config18(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = ADC_ADDR['reg18'];
    const data = adc_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_ADC_REG_VERBOSITY_MIN) {
            const msg = "[adc_get_config18]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_ADC_ADDR_VERBOSITY_MIN) {
            display_register(addr, c_ADC_SPI_ADDR_WIDTH, data, c_ADC_SPI_DATA_WIDTH, level1, mode_p);
        }

        if (verbosity_p >= c_ADC_BIT_VERBOSITY_MIN) {
            display_bit_from_data("offset_pedestal_common_or_chb_p", 0, 6, data, level2, mode_p);
        }
    }
    return data;

}


// function adc_get_config(reg_id) {

//     if (reg_id == 7) {
//         addr = 0x51
//         value = adc_read_command(addr);
//         print('custom_patter_low_p: 0x', value.toString(16))
//     }

// }

/**
 * Configure the device to generate the following pre-defined pattern
 *  . cha: generates the following alternates values
 *    . "01010101010101" (14 bits).
 *    . "10101010101010" (14 bits).
 *  . chb: generates the following incremental values
 *    . 0 to 16383 (14 bits) -> -8192 to 8191
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */
function adc_generate_pattern0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const msg = "[adc_generate_pattern0]";
    display(msg, level0, mode_p);

    const msg = "";
    display(msg, level0, mode_p);

    // Enable the SPI on the FPGA board
    const msg = "Enable the FPASim SPI Bridge";
    display(msg, level1, mode_p);
    adc_spi_enable(level2, mode_p, verbosity_p);

    const msg = "";
    display(msg, level2, mode_p);

    /*
    //###############################################################
    // register0
    //###############################################################
    // [7]: rst
    //    1: Software reset applied – resets all internal registers and self-clears to 0.
    //    0: do nothing
    // [0] : serial_out
    //    0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).
    //    1: Serial readout enabled, Pin SDOUT functions as serial data readout.
    */
    const rst = 0; //  Software reset applied – resets all internal registers and self-clears to 0.
    const serial_out = 0; //0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).1:Serial readout enabled, Pin SDOUT functions as serial data readout.

    const msg = "Configure the spi device in read mode";
    display(msg, level2, mode_p);
    adc_set_config0(
        rst, serial_out,
        level2, mode_p, verbosity_p
    );
    const msg = "";
    display(msg, level2, mode_p);

    /*
    //###############################################################
    // register1
    //###############################################################
    // [2]: enable_low_speed
    //      0: LOW SPEED mode disabled. Use for sampling frequency > 80 MSPS
    //      1: Enable LOW SPEED mode for sampling frequencies ≤ 80 MSPS.
    */
    // const enable_low_speed = 0;

    // const msg = "Set ADC in high speed mode";
    // display(msg, level2, mode_p);
    // adc_set_config1(
    //     enable_low_speed,
    //     level2, mode_p, verbosity_p
    // );

    // const msg = "";
    // display(msg, level2, mode_p);

    /*
    //###############################################################
    // register2
    //###############################################################
    // [6] ref: Internal or external reference selection
    //      00 : Internal reference enabled
    //      01:
    //      10:
    //      11: External reference enabled
    // [1]: standby <STANDBY>
    //      0 Normal operation
    //      1 Both ADC channels are put in standby. Internal references, output buffers are active. This results in
    //   quick wake-up time from standby.
    */
    // const ref = parseInt('00', 2);
    // const standby = 0;
    // adc_set_config2(
    //     ref, standby,
    //     level2, mode_p, verbosity_p
    // );

    // const msg = "";
    // display(msg, level2, mode_p);

    /*
    //###############################################################
    // register3
    //###############################################################
    // [3:0]: power_down
    //   0000 Pins CTRL1, CTRL2, and CTRL3 determine power down modes.
    //   1000 Normal operation
    //   1001 Output buffer disabled for channel B
    //   1010 Output buffer disabled for channel A
    //   1011 Output buffer disabled for channel A and B
    //   1100 Global power down
    //   1101 Channel B standby
    //   1110 Channel A standby
    //   1111 Multiplexed mode, MUX- (only with CMOS interface)
    //      Channel A and B data is multiplexed and output on DA13 to DA0 pins. Refer to the Multiplexed
    //      Output Mode section in the APPLICATION INFORMATION for additional information.
    */
    // const power_down = parseInt('1000', 2);
    // adc_set_config3(
    //     power_down,
    //     level2, mode_p, verbosity_p
    // );

    // const msg = "";
    // display(msg, level2, mode_p);

    /*
    //###############################################################
    // register4
    //###############################################################
    // [7]: lvds_cmos
    //   0 Parallel CMOS interface
    //   1 DDR LVDS interface
    */
    // const lvds_cmos = 1;
    // adc_set_config4(
    //     lvds_cmos,
    //     level2, mode_p, verbosity_p
    // );

    // const msg = "";
    // display(msg, level2, mode_p);

    /*
    //###############################################################
    // register5
    //###############################################################
    // LVDS interface
    //    [7:5] clkout_pos_rise Output clock rising edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Falling edge shifted (delayed) by + (4/26)×Ts(1)
    //       110 Falling edge shifted (advanced) by – (7/26)×Ts
    //       111 Falling edge shifted (advanced) by – (4/26)×Ts
    //    [4:2] clkout_pos_fall Output clock falling edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Rising edge shifted (delayed) by + (4/26)×Ts
    //       110 Rising edge shifted (advanced) by – (7/26)×Ts
    //       111 Rising edge shifted (advanced) by – (4/26)×Ts
    // CMOS interface
    //    [7:5]: clkout_pos_rise Output clock rising edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Rising edge shifted (delayed) by + (4/26)×Ts
    //       110 Rising edge shifted (advanced) by – (7/26)×Ts
    //       111 Rising edge shifted (advanced) by – (4/26)×Ts
    //    [4:2] clkout_pos_fall Output clock falling edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Falling edge shifted (delayed) by + (4/26)×Ts
    //       110 Falling edge shifted (advanced) by – (7/26)×Ts
    //       111 Falling edge shifted (advanced) by – (4/26)×Ts
    // Note:
    //       (1) Ts = 1 / sampling frequency
    //       (2) Keep the same duty cycle, move both edges by the same amount (i.e., write both D<4:2> and D<7:5> to be
    //       the same value).
    */
    // const clkout_pos_rise = parseInt('000', 2);
    // const clkout_pos_fall = parseInt('000', 2);

    // adc_set_config5(
    //     clkout_pos_rise, clkout_pos_fall,
    //     level2, mode_p, verbosity_p
    // );

    // const msg = "";
    // display(msg, level2, mode_p);



    /*
    //###############################################################
    // register6
    //###############################################################
    // [6]: en_independant_chan_ctrl
    //    0 Common control – both channels use common control settings for test patterns, offset correction,
    //      fine gain, gain correction and SNR Boost functions. These settings can be specified in a single set of registers.
    //    1 Independent control – both channels can be programmed with independent control settings for test
    //      patterns, offset correction and SNR Boost functions. Separate registers are available for each channel.
    // [2:1]: data_format
    //   10 2s complement
    //   11 Offset binary
    */
    const en_independant_chan_ctrl = 1;
    const data_format = parseInt('10', 2);

    const msg = "Configure ADC device with independent channels";
    display(msg, level2, mode_p);

    adc_set_config6(
        en_independant_chan_ctrl, data_format,
        level2, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level2, mode_p);

    //###############################################################
    // register12
    //###############################################################
    // [2:0] test_pattern_common_or_cha Test Patterns to verify data capture.
    //   Applies to both channels (with common control) or for channel A only (with independent control).
    //   000 Normal operation
    //   001 Outputs all zeros
    //   010 Outputs all ones
    //   011 Outputs toggle pattern – see Figure 14 and Figure 15 for test pattern timing diagrams for LVDS and CMOS modes.
    //       In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    //       In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    //   100 Outputs digital ramp
    //        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    //        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    //   101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    //   110 Unused
    //   111 Unused
    const test_pattern_common_or_cha = parseInt('011', 2);

    const msg = "Set the pattern mode of the ADC0";
    display(msg, level2, mode_p);

    adc_set_config12(
        test_pattern_common_or_cha,
        level2, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level2, mode_p);

    //###############################################################
    // register17
    //###############################################################
    // [2:0]: test_pattern_chb Test Patterns to verify data capture.
    //       Applies to channel B (only with independent control)
    //     000 Normal operation
    //     001 Outputs all zeros
    //     010 Outputs all ones
    //     011 Outputs toggle pattern – see Figure 14 and Figure 15 for LVDS and CMOS modes.
    //        In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    //        In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    //     100 Outputs digital ramp
    //        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    //        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    //     101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    //     110 Unused
    //     111 Unused
    const test_pattern_chb = parseInt('100', 2);

    const msg = "Set the pattern mode of the ADC1";
    display(msg, level2, mode_p);

    adc_set_config17(
        test_pattern_chb,
        level2, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level2, mode_p);


}

/**
 * Read and Display the configuration of all spi device registers.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */
function adc_display_all_config(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    adc_get_config0(level0, mode_p, verbosity_p);
    adc_get_config1(level0, mode_p, verbosity_p);
    adc_get_config2(level0, mode_p, verbosity_p);
    adc_get_config3(level0, mode_p, verbosity_p);
    adc_get_config4(level0, mode_p, verbosity_p);
    adc_get_config5(level0, mode_p, verbosity_p);
    adc_get_config6(level0, mode_p, verbosity_p);
    adc_get_config7(level0, mode_p, verbosity_p);
    adc_get_config8(level0, mode_p, verbosity_p);
    adc_get_config9(level0, mode_p, verbosity_p);
    adc_get_config10(level0, mode_p, verbosity_p);
    adc_get_config11(level0, mode_p, verbosity_p);
    adc_get_config12(level0, mode_p, verbosity_p);
    adc_get_config13(level0, mode_p, verbosity_p);
    adc_get_config14(level0, mode_p, verbosity_p);
    adc_get_config15(level0, mode_p, verbosity_p);
    adc_get_config16(level0, mode_p, verbosity_p);
    adc_get_config17(level0, mode_p, verbosity_p);
    adc_get_config18(level0, mode_p, verbosity_p);


}


/**
 * Default Configuration of the ads62p49 (adc) spi device (FMC150 board).
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */
function ADS62P49_configure(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    const msg = "ADS62P49_configure";
    display_title(msg, level0, mode_p);

    // Enable the SPI on the FPGA board
    const msg = "Enable the FPASim SPI bridge";
    display(msg, level1, mode_p);
    adc_spi_enable(level1, mode_p, verbosity_p);

    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register0
    //###############################################################
    // [7]: rst
    //    1: Software reset applied – resets all internal registers and self-clears to 0.
    //    0: do nothing
    // [0] : serial_out
    //    0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).
    //    1: Serial readout enabled, Pin SDOUT functions as serial data readout.
    */
    const rst = 1; //  Software reset applied – resets all internal registers and self-clears to 0.
    const serial_out = 0; //0: Serial readout disabled. SDOUT is forced low by the device (and not put in high impedance state).1:Serial readout enabled, Pin SDOUT functions as serial data readout.
    adc_set_config0(
        rst, serial_out,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register1
    //###############################################################
    // [2]: enable_low_speed
    //      0: LOW SPEED mode disabled. Use for sampling frequency > 80 MSPS
    //      1: Enable LOW SPEED mode for sampling frequencies ≤ 80 MSPS.
    */
    const enable_low_speed = 0;
    adc_set_config1(
        enable_low_speed,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register2
    //###############################################################
    // [6] ref: Internal or external reference selection
    //      00 : Internal reference enabled
    //      01:
    //      10:
    //      11: External reference enabled
    // [1]: standby <STANDBY>
    //      0 Normal operation
    //      1 Both ADC channels are put in standby. Internal references, output buffers are active. This results in
    //   quick wake-up time from standby.
    */
    const ref = parseInt('00', 2);
    const standby = 0;
    adc_set_config2(
        ref, standby,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register3
    //###############################################################
    // [3:0]: power_down
    //   0000 Pins CTRL1, CTRL2, and CTRL3 determine power down modes.
    //   1000 Normal operation
    //   1001 Output buffer disabled for channel B
    //   1010 Output buffer disabled for channel A
    //   1011 Output buffer disabled for channel A and B
    //   1100 Global power down
    //   1101 Channel B standby
    //   1110 Channel A standby
    //   1111 Multiplexed mode, MUX- (only with CMOS interface)
    //      Channel A and B data is multiplexed and output on DA13 to DA0 pins. Refer to the Multiplexed
    //      Output Mode section in the APPLICATION INFORMATION for additional information.
    */
    const power_down = parseInt('1000', 2);
    adc_set_config3(
        power_down,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register4
    //###############################################################
    // [7]: lvds_cmos
    //   0 Parallel CMOS interface
    //   1 DDR LVDS interface
    */
    const lvds_cmos = 1;
    adc_set_config4(
        lvds_cmos,
        level1, mode_p, verbosity_p
    );
    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register5
    //###############################################################
    // LVDS interface
    //    [7:5] clkout_pos_rise Output clock rising edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Falling edge shifted (delayed) by + (4/26)×Ts(1)
    //       110 Falling edge shifted (advanced) by – (7/26)×Ts
    //       111 Falling edge shifted (advanced) by – (4/26)×Ts
    //    [4:2] clkout_pos_fall Output clock falling edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Rising edge shifted (delayed) by + (4/26)×Ts
    //       110 Rising edge shifted (advanced) by – (7/26)×Ts
    //       111 Rising edge shifted (advanced) by – (4/26)×Ts
    // CMOS interface
    //    [7:5]: clkout_pos_rise Output clock rising edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Rising edge shifted (delayed) by + (4/26)×Ts
    //       110 Rising edge shifted (advanced) by – (7/26)×Ts
    //       111 Rising edge shifted (advanced) by – (4/26)×Ts
    //    [4:2] clkout_pos_fall Output clock falling edge position (2)
    //       000, 100 Default output clock position (refer to timing specification table)
    //       101 Falling edge shifted (delayed) by + (4/26)×Ts
    //       110 Falling edge shifted (advanced) by – (7/26)×Ts
    //       111 Falling edge shifted (advanced) by – (4/26)×Ts
    // Note:
    //       (1) Ts = 1 / sampling frequency
    //       (2) Keep the same duty cycle, move both edges by the same amount (i.e., write both D<4:2> and D<7:5> to be
    //       the same value).
    */
    const clkout_pos_rise = parseInt('000', 2);
    const clkout_pos_fall = parseInt('000', 2);

    adc_set_config5(
        clkout_pos_rise, clkout_pos_fall,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register6
    //###############################################################
    // [6]: en_independant_chan_ctrl
    //    0 Common control – both channels use common control settings for test patterns, offset correction,
    //      fine gain, gain correction and SNR Boost functions. These settings can be specified in a single set of registers.
    //    1 Independent control – both channels can be programmed with independent control settings for test
    //      patterns, offset correction and SNR Boost functions. Separate registers are available for each channel.
    // [2:1]: data_format
    //   10 2s complement
    //   11 Offset binary
    */
    const en_independant_chan_ctrl = 1;
    const data_format = parseInt('10', 2);

    adc_set_config6(
        en_independant_chan_ctrl, data_format,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register7
    //###############################################################
    // [7:0] custom_pattern_low
    //   8 lower bits of custom pattern available at the output instead of ADC data.
    // Note: Use this mode along with “Test Patterns” (register 0x62).
    */
    const custom_patter_low = parseInt('10011111', 2);

    adc_set_config7(
        custom_patter_low,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register8
    //###############################################################
    // [5:0] custom_pattern_high
    //   6 upper bits of custom pattern available at the output instead of ADC data
    // Note: Use this mode along with “Test Patterns” (register 0x62).
    */
    const custom_patter_high = parseInt('100000', 2);

    adc_set_config8(
        custom_patter_high,
        level1, mode_p, verbosity_p
    );
    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register9
    //###############################################################
    // [6]:  en_offset_correction – Common/Ch A>
    //      Offset correction enable control for both channels (with common control) or for channel A only (with
    //      independent control).
    //   0 Offset correction disabled
    //   1 Offset correction enabled
    */
    const en_offset_correction_cha = 0;

    adc_set_config9(
        en_offset_correction_cha,
        level1, mode_p, verbosity_p
    );
    const msg = "";
    display(msg, level1, mode_p);

    /*
    //###############################################################
    // register10
    //###############################################################
    // [7:4] gain_common_or_cha <GAIN – Common/Ch A>
    //  Gain control for both channels (with common control) or for channel A only (with independent control).
    //    0000 0 dB gain, default after reset
    //    0001 0.5 dB gain
    //    0010 1.0 dB gain
    //    0011 1.5 dB gain
    //    0100 2.0 dB gain
    //    0101 2.5 dB gain
    //    0110 3.0 dB gain
    //    0111 3.5 dB gain
    //    1000 4.0 dB gain
    //    1001 4.5 dB gain
    //    1010 5.0 dB gain
    //    1011 5.5 dB gain
    //    1100 6.0 dB gain
    // [3:0] offset_corr_time_common_or_cha <OFFSET CORR TIME CONSTANT – Common/Ch A>
    //    Correction loop time constant in number of clock cycles.
    //    Applies to both channels (with common control) or for channel A only (with independent control).
    //    0000 256 k
    //    0001 512 k
    //    0010 1 M
    //    0011 2 M
    //    0100 4 M
    //    0101 8 M
    //    0110 16 M
    //    0111 32 M
    //    1000 64 M
    //    1001 128 M
    //    1010 256 M
    //    1011 512 M
    */
    const gain_cha = parseInt('0000', 2);
    const offset_corr_time_cha = parseInt('0000', 2);

    adc_set_config10(
        gain_cha, offset_corr_time_cha,
        level1, mode_p, verbosity_p
    );
    const msg = "";
    display(msg, level1, mode_p);

    //###############################################################
    // register11
    //###############################################################
    // [6:0] fine_gain_adjust_common_or_cha
    // Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
    // additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
    // trimmed channel gain is:
    //     Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
    // Note: that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
    //      <GAIN PROGRAMMABILITY>
    const fine_gain_adjust_common_or_cha = parseInt('0000000', 2);

    adc_set_config11(
        fine_gain_adjust_common_or_cha,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    //###############################################################
    // register12
    //###############################################################
    // [2:0] test_pattern_common_or_cha Test Patterns to verify data capture.
    //   Applies to both channels (with common control) or for channel A only (with independent control).
    //   000 Normal operation
    //   001 Outputs all zeros
    //   010 Outputs all ones
    //   011 Outputs toggle pattern – see Figure 14 and Figure 15 for test pattern timing diagrams for LVDS and CMOS modes.
    //       In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    //       In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    //   100 Outputs digital ramp
    //        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    //        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    //   101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    //   110 Unused
    //   111 Unused
    const test_pattern_common_or_cha = parseInt('000', 2);
    adc_set_config12(
        test_pattern_common_or_cha,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    //###############################################################
    // register13
    //###############################################################
    // [5:0]: offset_pedestal_common_or_cha <OFFSET PEDESTAL – Common/Ch A>
    //       When the offset correction is enabled, the final converged value (after the offset is corrected) will
    //       be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
    //       added to the final converged value by programming these bits. So, the final converged value will
    //       be = ideal mid-code + PEDESTAL.
    //       See "Offset Correction" in application section.
    //       Applies to both channels (with common control) or for channel A only (with independent control).
    //    011111 PEDESTAL = 31 LSB
    //    011110 PEDESTAL = 30 LSB
    //    011101 PEDESTAL = 29 LSB
    //    ...
    //    000000 PEDESTAL = 0
    //    ...
    //    111111 PEDESTAL = –1 LSB
    //    111110 PEDESTAL = –2 LSB
    //    ...
    //    100000 PEDESTAL = –32 LSB
    const offset_pedestal_common_or_cha = parseInt('000000', 2);

    adc_set_config13(
        offset_pedestal_common_or_cha,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    //###############################################################
    // register14
    //###############################################################
    // [6] offset_corr_chb
    //     Offset correction enable control for channel B (only with independent control).
    //   0 offset correction disabled
    //   1 offset correction enabled
    const offset_corr_chb = 0;

    adc_set_config14(
        offset_corr_chb,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    //###############################################################
    // register15
    //###############################################################
    // [7:4] gain_chb Gain programmability to 0.5 dB steps.
    //       Applies to channel B (only with independent control).
    //    0000 0 dB gain, default after reset
    //    0001 0.5 dB gain
    //    0010 1.0 dB gain
    //    0011 1.5 dB gain
    //    0100 2.0 dB gain
    //    0101 2.5 dB gain
    //    0110 3.0 dB gain
    //    0111 3.5 dB gain
    //    1000 4.0 dB gain
    //    1001 4.5 dB gain
    //    1010 5.0 dB gain
    //    1011 5.5 dB gain
    //    1100 6.0 dB gain
    // [3:0] offset_corr_time_chb Time constant of correction loop in number of clock cycles.
    //       Applies to channel B (only with independent control)
    //  0000 256 k
    //  0001 512 k
    //  0010 1 M
    //  0011 2 M
    //  0100 4 M
    //  0101 8 M
    //  0110 16 M
    //  0111 32 M
    //  1000 64 M
    //  1001 128 M
    //  1010 256 M
    //  1011 512 M
    const gain_chb = parseInt('0000', 2);
    const offset_corr_time_chb = parseInt('0000', 2);

    adc_set_config15(
        gain_chb, offset_corr_time_chb,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    //###############################################################
    // register16
    //###############################################################
    // [7:0] fine_gain_adjust_chb
    //     Using the FINE GAIN ADJUST register bits, the channel gain can be trimmed in fine steps. The trim is only
    //     additive, has 128 steps and a range of 0.134dB. The relation between the FINE GAIN ADJUST bits and the
    //     trimmed channel gain is:
    //        Δ Channel gain = 20*log10[1 + (FINE GAIN ADJUST/8192)]
    // Note that the total device gain = ADC gain + Δ Channel gain. The ADC gain is determined by register bits
    //  <GAIN PROGRAMMABILITY>
    const fine_gain_adjust_chb = parseInt('0000000', 2);

    adc_set_config16(
        fine_gain_adjust_chb,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    //###############################################################
    // register17
    //###############################################################
    // [2:0]: test_pattern_chb Test Patterns to verify data capture.
    //       Applies to channel B (only with independent control)
    //     000 Normal operation
    //     001 Outputs all zeros
    //     010 Outputs all ones
    //     011 Outputs toggle pattern – see Figure 14 and Figure 15 for LVDS and CMOS modes.
    //        In ads62p49/48, output data <D13:D0> alternates between 01010101010101 and 10101010101010 every clock cycle.
    //        In ADS62P29/28, output data <D11:D0> alternates between 010101010101 and 101010101010 every clock cycle.
    //     100 Outputs digital ramp
    //        In ads62p49/48, output data increments by one LSB (14-bit) every clock cycle from code 0 to code 16383
    //        In ADS62P29/28, output data increments by one LSB (12-bit) every 4th clock cycle from code 0 to code 4095
    //     101 Outputs custom pattern (use registers 0x51, 0x52 for setting the custom pattern), see Figure 16 for an example of a custom pattern.
    //     110 Unused
    //     111 Unused
    const test_pattern_chb = parseInt('000', 2);

    adc_set_config17(
        test_pattern_chb,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

    //###############################################################
    // register18
    //###############################################################
    // [5:0]: offset_pedestal_common_or_chb
    //       When the offset correction is enabled, the final converged value (after the offset is corrected) will
    //       be the ideal ADC mid-code value (=8192 for P49/48, = 2048 for P29/28). A pedestal can be
    //       added to the final converged value by programming these bits. So, the final converged value will
    //       be = ideal mid-code + PEDESTAL. See "Offset Correction" in application section.
    //       Applies to channel B (only with independent control).
    //   011111 PEDESTAL = 31 LSB
    //   011110 PEDESTAL = 30 LSB
    //   011101 PEDESTAL = 29 LSB
    //   ...
    //   000000 PEDESTAL = 0
    //   ...
    //   111111 PEDESTAL = –1 LSB
    //   111110 PEDESTAL = –2 LSB
    //   ...
    //   100000 PEDESTAL = –32 LSB
    const offset_pedestal_common_or_chb = parseInt('000000', 0);

    adc_set_config18(
        offset_pedestal_common_or_chb,
        level1, mode_p, verbosity_p
    );

    const msg = "";
    display(msg, level1, mode_p);

}