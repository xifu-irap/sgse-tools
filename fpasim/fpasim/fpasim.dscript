// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   fpasim_tools.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference    
// -------------------------------------------------------------------------------------------------------------
//    @details       
//
//    This script defines base functions to access (read/write) to the FPASim functions. 
//    In particular, functions associated to the SPI module bridge are defined for the downstream javascript.         
//
//    Note: 
//      . This script only implemented function to access registers not yet implemented by the Xifu Studio application.
//
// -------------------------------------------------------------------------------------------------------------
include("./fpasim/utils_tools.dscript")

// verbosity min to display register access
const c_FPASIM_REG_VERBOSITY_MIN = 0;
// verbosity min to display (addr,data)
const c_FPASIM_ADDR_VERBOSITY_MIN = 1;
// verbosity min to display register bit
const c_FPASIM_BIT_VERBOSITY_MIN = c_FPASIM_ADDR_VERBOSITY_MIN + 1;

/*
 Trig in address
 */
const FPASIM_ADDR_TRIGIN = {};
FPASIM_ADDR_TRIGIN['TRIG'] = 0x40;

/*
 position of trig bit in trig_in
*/
const FPASIM_POS_TRIGIN = {};
FPASIM_POS_TRIGIN['reg_valid'] = 0;
FPASIM_POS_TRIGIN['make_pulse'] = 4;
FPASIM_POS_TRIGIN['rd_all'] = 8;
FPASIM_POS_TRIGIN['ctrl_valid'] = 12;
FPASIM_POS_TRIGIN['debug_valid'] = 16;
FPASIM_POS_TRIGIN['rec_valid'] = 20;
FPASIM_POS_TRIGIN['spi_valid'] = 24;

/*
  Wire in addresses
*/
const FPASIM_ADDR_WIREIN = {};
FPASIM_ADDR_WIREIN['CTRL'] = 0x00; // 0
FPASIM_ADDR_WIREIN['MAKE_PULSE'] = 0x01; // 1
FPASIM_ADDR_WIREIN['FPASIM_GAIN'] = 0x02; // 2
FPASIM_ADDR_WIREIN['MUX_SQ_FB_DELAY'] = 0x03; // 3
FPASIM_ADDR_WIREIN['AMP_SQ_OF_DELAY'] = 0x04; // 4
FPASIM_ADDR_WIREIN['ERROR_DELAY'] = 0x05; // 5
FPASIM_ADDR_WIREIN['RA_DELAY'] = 0x06; // 6
FPASIM_ADDR_WIREIN['TES_CONF'] = 0x07; // 7
FPASIM_ADDR_WIREIN['CONF0'] = 0x08; // 8
// FPASIM_ADDR_WIREIN['RFU'] = 0x09; // 9
// FPASIM_ADDR_WIREIN['FPASIM_STATUS'] = 0x0A; // 10
// FPASIM_ADDR_WIREIN['DATA_COUNT'] = 0x0B; // 11
FPASIM_ADDR_WIREIN['REC_CTRL'] = 0x0C; // 12
FPASIM_ADDR_WIREIN['REC_CONF0'] = 0x0D; // 13
// FPASIM_ADDR_WIREIN['RFU'] = 0x0E; // 14
// FPASIM_ADDR_WIREIN['RFU'] = 0x0F; // 15
// FPASIM_ADDR_WIREIN['RFU'] = 0x10; // 16
// FPASIM_ADDR_WIREIN['REC_DATA_COUNT'] = 0x11; // 17
FPASIM_ADDR_WIREIN['SPI_CTRL'] = 0x12; // 18
FPASIM_ADDR_WIREIN['SPI_CONF0'] = 0x13; // 19
FPASIM_ADDR_WIREIN['SPI_CONF1'] = 0x14; // 20
FPASIM_ADDR_WIREIN['SPI_WR_DATA'] = 0x15; // 21
// FPASIM_ADDR_WIREIN['SPI_RD_DATA'] = 0x16; // 22
// FPASIM_ADDR_WIREIN['SPI_STATUS'] = 0x37; // 23
FPASIM_ADDR_WIREIN['DEBUG_CTRL'] = 0x18; // 24
FPASIM_ADDR_WIREIN['ERROR_SEL'] = 0x19; // 25
// FPASIM_ADDR_WIREIN['ERRORS'] = 0x1A; // 26
// FPASIM_ADDR_WIREIN['STATUS'] = 0x1B; // 27
// FPASIM_ADDR_WIREIN['RFU'] = 0x1C; // 28
// FPASIM_ADDR_WIREIN['BOARD_ID'] = 0x1D; // 29
// FPASIM_ADDR_WIREIN['FIRMWARE_ID'] = 0x1E; // 30
// FPASIM_ADDR_WIREIN['FIRMWARE_VERSION'] = 0x1F; // 31


/*
  Wire out addresses
*/
const FPASIM_ADDR_WIREOUT = {};
FPASIM_ADDR_WIREOUT['CTRL'] = 0x20; // 0
FPASIM_ADDR_WIREOUT['MAKE_PULSE'] = 0x21; // 1
FPASIM_ADDR_WIREOUT['FPASIM_GAIN'] = 0x22; // 2
FPASIM_ADDR_WIREOUT['MUX_SQ_FB_DELAY'] = 0x23; // 3
FPASIM_ADDR_WIREOUT['AMP_SQ_OF_DELAY'] = 0x24; // 4
FPASIM_ADDR_WIREOUT['ERROR_DELAY'] = 0x25; // 5
FPASIM_ADDR_WIREOUT['RA_DELAY'] = 0x26; // 6
FPASIM_ADDR_WIREOUT['TES_CONF'] = 0x27; // 7
FPASIM_ADDR_WIREOUT['CONF0'] = 0x28; // 8
// FPASIM_ADDR_WIREOUT['RFU'] = 0x29; // 9
FPASIM_ADDR_WIREOUT['FPASIM_STATUS'] = 0x2A; // 10
FPASIM_ADDR_WIREOUT['DATA_COUNT'] = 0x2B; // 11
FPASIM_ADDR_WIREOUT['REC_CTRL'] = 0x2C; // 12
FPASIM_ADDR_WIREOUT['REC_CONF0'] = 0x2D; // 13
// FPASIM_ADDR_WIREOUT['RFU'] = 0x2E; // 14
// FPASIM_ADDR_WIREOUT['RFU'] = 0x2F; // 15
// FPASIM_ADDR_WIREOUT['RFU'] = 0x30; // 16
FPASIM_ADDR_WIREOUT['REC_DATA_COUNT'] = 0x31; // 17
FPASIM_ADDR_WIREOUT['SPI_CTRL'] = 0x32; // 18
FPASIM_ADDR_WIREOUT['SPI_CONF0'] = 0x33; // 19
FPASIM_ADDR_WIREOUT['SPI_CONF1'] = 0x34; // 20
FPASIM_ADDR_WIREOUT['SPI_WR_DATA'] = 0x35; // 21
FPASIM_ADDR_WIREOUT['SPI_RD_DATA'] = 0x36; // 22
FPASIM_ADDR_WIREOUT['SPI_STATUS'] = 0x37; // 23
FPASIM_ADDR_WIREOUT['DEBUG_CTRL'] = 0x38; // 24
FPASIM_ADDR_WIREOUT['ERROR_SEL'] = 0x39; // 25
FPASIM_ADDR_WIREOUT['ERRORS'] = 0x3A; // 26
FPASIM_ADDR_WIREOUT['STATUS'] = 0x3B; // 27
// FPASIM_ADDR_WIREOUT['RFU'] = 0x3C; // 28
FPASIM_ADDR_WIREOUT['BOARD_ID'] = 0x3D; // 29
FPASIM_ADDR_WIREOUT['FIRMWARE_ID'] = 0x3E; // 30
FPASIM_ADDR_WIREOUT['FIRMWARE_VERSION'] = 0x3F; // 31



/**
 * Build the word to write in the "CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rst_p - reset.
 * @param {number} en_p - enable.
 * @return {number} built word.
 */
function fpasim_build_ctrl(rst_p, en_p) {
    const data = (rst_p << 1) + en_p;

    return data;
}

/**
 * Build the word to write in the "MAKE_PULSE" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} pixel_all_p    - 
 * @param {number} pixel_id_p     - 
 * @param {number} time_shift_p   - 
 * @param {number} pulse_height_p - 
 * @return {number} built word.
 */
function fpasim_build_make_pulse(pixel_all_p, pixel_id_p, time_shift_p, pulse_height_p) {
    const data = (pixel_all_p << 31) + (pixel_id_p << 24) + (time_shift_p << 16) + (pulse_height_p)
    return data;
}

/**
 * Build the word to write in the "FPASIM_GAIN" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} fpasim_gain_p - 
 * @return {number} built word.
 */
function fpasim_build_fpasim_gain(fpasim_gain_p) {
    const data = fpasim_gain_p;
    return data;
}

/**
 * Build the word to write in the "MUX_SQ_FB_DELAY" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} mux_sq_fb_delay_p - 
 * @return {number} built word.
 */
function fpasim_build_mux_sq_fb_delay(mux_sq_fb_delay_p) {
    const data = mux_sq_fb_delay_p;
    return data;
}

/**
 * Build the word to write in the "AMP_SQ_OF_DELAY" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} amp_sq_of_delay_p - 
 * @return {number} built word.
 */
function fpasim_build_amp_sq_of_delay(amp_sq_of_delay_p) {
    const data = amp_sq_of_delay_p;
    return data;
}

/**
 * Build the word to write in the "ERROR_DELAY" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} error_delay_p - 
 * @return {number} built word.
 */
function fpasim_build_error_delay(error_delay_p) {
    const data = error_delay_p;
    return data;
}

/**
 * Build the word to write in the "RA_DELAY" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} ra_delay_p - 
 * @return {number} built word.
 */
function fpasim_build_ra_delay(ra_delay_p) {
    const data = ra_delay_p;
    return data;
}

/**
 * Build the word to write in the "TES_CONF" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} nb_pixel_by_frame_p - 
 * @param {number} nb_sample_by_pixel_p - 
 * @param {number} nb_samples_by_frame_p - 
 * @return {number} built word.
 */
function fpasim_build_tes_conf(nb_pixel_by_frame_p, nb_sample_by_pixel_p, nb_samples_by_frame_p) {
    const data = (nb_pixel_by_frame_p << 24) + (nb_sample_by_pixel_p << 16) + nb_samples_by_frame_p;
    return data;
}

/**
 * Build the word to write in the "CONF0" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} inter_squid_gain_p - 
 * @return {number} built word.
 */
function fpasim_build_conf0(inter_squid_gain_p) {
    const data = inter_squid_gain_p;
    return data;
}


/**
 * Build the word to write in the "SPI_CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rst_p - 
 * @param {number} en_p - 
 * @return {number} built word.
 */
function fpasim_build_spi_ctrl(rst_p, en_p) {
    const data = (rst_p << 1) + (en_p);
    return data;
}


/**
 * Build the word to write in the "SPI_CONF0" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} spi_id_p - 
 * @param {number} spi_mode_p - 
 * @return {number} built word.
 */
function fpasim_build_spi_conf0(spi_id_p, spi_mode_p) {
    const data = (spi_id_p << 4) + spi_mode_p;
    return data;
}

/**
 * Build the word to write in the "SPI_CONF1" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} spi_dac_tx_en_p - 
 * @return {number} built word.
 */
function fpasim_build_spi_conf1(spi_dac_tx_en_p) {
    const data = (spi_dac_tx_en_p << 0);
    return data;
}

/**
 * Build the word to write in the "SPI_WR_DATA" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} data_p - 
 * @return {number} built word.
 */
function fpasim_build_spi_wr_data(data_p) {
    const data = data_p;
    return data;
}

/**
 * Build the word to write in the "REC_CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} en_p - 
 * @return {number} built word.
 */
function fpasim_build_rec_ctrl(en_p) {
    const data = en_p;
    return data;
}

/**
 * Build the word to write in the "REC_CONF0" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rec_adc_nb_word_32b_p -
 * @return {number} built word.
 */
function fpasim_build_rec_conf0(rec_adc_nb_word_32b_p) {
    const data = rec_adc_nb_word_32b_p;
    return data;
}

/**
 * Build the word to write in the "debug_ctrl" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rst_status_p - 
 * @param {number} debug_pulse_p - 
 * @return {number} built word.
 */
function fpasim_build_debug_ctrl(dac_en_pattern_p, rst_status_p, debug_pulse_p) {
    const data = (dac_en_pattern_p << 4) + (rst_status_p << 1) + debug_pulse_p;
    return data;
}

/**
 * Build the word to write in the "ERROR_SEL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} sel_error_p - 
 * @return {number} built word.
 */
function fpasim_build_error_sel(sel_error_p) {
    const data = sel_error_p;
    return data;
}


/**
 * Get the selected status register value.
 * @param {number} sel_error_p - 
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_status(sel_error_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    // Select the errors to read
    const index = sel_error_p;
    fpasim_set_debug_wirein_by_name(reg_name_p = "ERROR_SEL", data_p = index, level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    fpasim_get_wireout_by_name(reg_name_p = "STATUS", level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    return data;
}


/**
 * Set the "CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rst_p - .
 * @param {number} en_p - .
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_ctrl(rst_p, en_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fpasim_build_ctrl(rst_p = rst_p, en_p = en_p);
    const addr = FPASIM_ADDR_WIREIN["CTRL"];

    sendToFPA_debugSetWireIn(addr, data);

    const trig_pos = FPASIM_POS_TRIGIN['ctrl_valid'];
    const trig_addr = FPASIM_ADDR_TRIGIN['TRIG'];
    sendToFPA_debugSetTriggerIn(trig_addr, trig_pos);


    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_ctrl]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }
        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "rst_p", bit_value_p = rst_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "en_p", bit_value_p = en_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);

        }

    }


}


/**
 * Set the "SPI_CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rst_p - reset.
 * @param {number} en_p - enable.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_spi_ctrl(rst_p, en_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fpasim_build_spi_ctrl(rst_p = rst_p, en_p = en_p);
    const addr = addr = FPASIM_ADDR_WIREIN["SPI_CTRL"];

    sendToFPA_debugSetWireIn(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_spi_ctrl]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "rst_p", bit_value_p = rst_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "en_p", bit_value_p = en_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);

        }
    }


}

/**
 * Set the "SPI_CONF0" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} spi_id_p - 
 * @param {number} spi_mode_p - 
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_spi_conf0(spi_id_p, spi_mode_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fpasim_build_spi_conf0(spi_id_p, spi_mode_p);
    const addr = addr = FPASIM_ADDR_WIREIN["SPI_CONF0"];

    sendToFPA_debugSetWireIn(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_spi_conf0]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "spi_id_p", bit_value_p = spi_id_p, bit_width_p = 3, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "spi_mode_p", bit_value_p = spi_mode_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);

        }
    }


}

/**
 * Set the "SPI_CONF1" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 *         This function should be called before and after the dac device configuration.
 * @param {number} spi_dac_tx_en_p - 
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_spi_conf1(spi_dac_tx_en_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fpasim_build_spi_conf1(spi_dac_tx_en_p);
    const addr = addr = FPASIM_ADDR_WIREIN["SPI_CONF1"];

    sendToFPA_debugSetWireIn(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_spi_conf1]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "spi_dac_tx_en_p", bit_value_p = spi_dac_tx_en_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);

        }
    }


}

/**
 * Set the "SPI_WR_DATA" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 *         This function should be called after the fpasim_set_spi_ctrl and fpasim_set_spi_conf0 function 
 * @param {number} data_p - 
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_spi_wr_data(data_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    const data = fpasim_build_spi_wr_data(data_p);
    const addr = addr = FPASIM_ADDR_WIREIN["SPI_WR_DATA"];

    sendToFPA_debugSetWireIn(addr, data);

    const trig_pos = FPASIM_POS_TRIGIN['spi_valid'];
    const trig_addr = FPASIM_ADDR_TRIGIN['TRIG'];
    sendToFPA_debugSetTriggerIn(trig_addr, trig_pos);


    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_spi_wr_data]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

    }


}

/**
 * Set the "DEBUG_CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} dac_en_pattern_p - enable the dac pattern generator.
 * @param {number} rst_status_p - reset errors.
 * @param {number} debug_pulse_p - '1': errors are pipelined, 0': errors are latches.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_debug_ctrl(dac_en_pattern_p, rst_status_p, debug_pulse_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fpasim_build_debug_ctrl(dac_en_pattern_p, rst_status_p, debug_pulse_p)
    const addr = FPASIM_ADDR_WIREIN["DEBUG_CTRL"];

    sendToFPA_debugSetWireIn(addr, data);

    const trig_pos = FPASIM_POS_TRIGIN['debug_valid'];
    const trig_addr = FPASIM_ADDR_TRIGIN['TRIG'];
    sendToFPA_debugSetTriggerIn(trig_addr, trig_pos);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_debug_ctrl]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "dac_en_pattern_p", bit_value_p = dac_en_pattern_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "rst_status_p", bit_value_p = rst_status_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "debug_pulse_p", bit_value_p = debug_pulse_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);

        }
    }


}

/**
 * Set the selected register value.
 *   Note: for few registers, the sendToFPA_debugSetTriggerIn function is called.
 * @param {string} reg_name_p - Name of the FPASIM register.
 * @param {number} data_p - data to write in the register.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */

function fpasim_set_debug_wirein_by_name(reg_name_p, data_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    data = data_p;
    addr = 0;
    trig_addr = FPASIM_ADDR_TRIGIN['TRIG'];
    trig_pos = -1;
    error = 0;
    switch (reg_name_p) {
        case 'CTRL':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['ctrl_valid'];
            break;
        case 'MAKE_PULSE':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['make_pulse'];
            break;
        case 'FPASIM_GAIN':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;
        case 'MUX_SQ_FB_DELAY':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;
        case 'AMP_SQ_OF_DELAY':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;
        case 'ERROR_DELAY':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;
        case 'RA_DELAY':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;
        case 'TES_CONF':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;

        case 'CONF0':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;


            // case 'RFU':
            //   break;

            // case 'RFU':
            //   break;

            // case 'DATA_COUNT':
            //     break;
        case 'REC_CTRL':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['rec_valid'];
            // trig_pos = -1;
            break;
        case 'REC_CONF0':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['rec_valid'];
            break;

            // case 'RFU':
            //   break;

            // case 'RFU':
            //   break;

            // case 'RFU':
            //   break;

            // case 'REC_DATA_COUNT':
            //     break;

        case 'SPI_CTRL':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;

        case 'SPI_CONF0':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;

        case 'SPI_CONF1':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;

        case 'SPI_WR_DATA':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['spi_valid'];
            break;
            // case 'SPI_RD_DATA':
            //     break;
        case 'SPI_STATUS':
            break;

            // case 'RFU':
            // break;

        case 'DEBUG_CTRL':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['debug_valid'];
            break;

        case 'ERROR_SEL':
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;

            // case 'ERRORS':
            //     break;

            // case 'STATUS':
            //     break;

            // case 'RFU':
            // data = FPA_WireOutValues[28];
            // break;

            // case 'BOARD_ID':
            //     break;
            // case 'FIRMWARE_ID':
            //     break;
            // case 'FIRMWARE_VERSION':
            //     break;
        default:
            msg = "[KO][fpasim_set_debug_wirein_by_name]: The register " + reg_name_p + " doesn't exist."
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
            error = 1;
            break;
    }

    if (error == 0) {

        sendToFPA_debugSetWireIn(addr, data);

        if (trig_pos != -1) {
            sendToFPA_debugSetTriggerIn(trig_addr, trig_pos);
        }
        if (verbosity_p < 0) {
            // do nothing
        } else {

            if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
                msg = "[fpasim_set_debug_wirein_by_name]: Set " + reg_name_p;
                display(msg_p = msg, level_p = level0, mode_p = mode_p);
            }

            if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
                display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
            }

            if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
                if (trig_pos != -1) {
                    msg = "[fpasim_set_debug_wirein_by_name]: Set Trig (bit" + trig_pos.toString(10) + ")";
                    display(msg_p = msg, level_p = level0, mode_p = mode_p);
                }
            }

        }


    }

}

/**
 * Get the register value (wireout access).
 *   Note: for few registers, the sendToFPA_debugSetTriggerIn function is also called.
 * @param {number} addr_p - data to write in the register.
 * @return {number} read register value.
 */
function fpasim_wireout_read_command(addr_p) {
    // shift address
    const index = addr_p - 0x20;
    //---------------------------------------------------------------------
    // Read wire out registers
    //---------------------------------------------------------------------
    // waitMs(50);
    getLatestValue("FPA_WireOutValues");
    const data = FPA_WireOutValues[index];

    return data;
}

/**
 * Get the "CTRL" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['CTRL'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {

        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_ctrl]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "en", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "rst", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "MAKE_PULSE" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_make_pulse(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['MAKE_PULSE'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_make_pulse]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "pulse_height", bit_pos_p = 0, bit_width_p = 11, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "time_shift", bit_pos_p = 16, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "pixel_id", bit_pos_p = 24, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "pixel_all", bit_pos_p = 31, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "FPASIM_GAIN" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_fpasim_gain(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['FPASIM_GAIN'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {

        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_make_pulse]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "fpasim_gain_p", bit_pos_p = 0, bit_width_p = 3, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "MUX_SQ_FB_DELAY" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_mux_sq_fb_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['MUX_SQ_FB_DELAY'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_mux_sq_fb_delay]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "gain_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "AMP_SQ_OF_DELAY" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_amp_sq_of_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['AMP_SQ_OF_DELAY'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_amp_sq_of_delay]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "gain_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "ERROR_DELAY" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_error_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['ERROR_DELAY'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_error_delay]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "gain_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "RA_DELAY" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_ra_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['RA_DELAY'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_ra_delay]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "gain_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "TES_CONF" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_tes_conf(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['TES_CONF'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_tes_conf]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "nb_sample_by_frame", bit_pos_p = 0, bit_width_p = 16, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "nb_sample_by_pixel", bit_pos_p = 0, bit_width_p = 7, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "nb_pixel_by_frame", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "CONF0" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_conf0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['CONF0'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_conf0]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "inter_squid_gain_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "FPASIM_STATUS" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_fpasim_status(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['FPASIM_STATUS'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_fpasim_status]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "tes_neg_out_pixel_id", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "tes_neg_out_error", bit_pos_p = 7, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "DATA_COUNT" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_data_count(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['DATA_COUNT'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_data_count]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "pipe_data_count", bit_pos_p = 0, bit_width_p = 16, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "make_pulse_wr_data_count", bit_pos_p = 16, bit_width_p = 16, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "REC_CTRL" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_rec_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['REC_CTRL'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_rec_ctrl]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rec_adc_en", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "REC_CONF0" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_rec_conf0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['REC_CONF0'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_rec_conf0]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rec_adc_nb_word_32b_p", bit_pos_p = 0, bit_width_p = 16, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "REC_DATA_COUNT" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_rec_data_count(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['REC_DATA_COUNT'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_rec_data_count]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rec_adc_data_count_p", bit_pos_p = 0, bit_width_p = 16, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_CTRL" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_CTRL'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_ctrl]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rst_p", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "en_p", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_CONF0" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_conf0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_CONF0'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_conf0]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "spi_id_p", bit_pos_p = 4, bit_width_p = 2, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "spi_mode_p", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_CONF1" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_conf1(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_CONF1'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_conf1]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "spi_dac_tx_enable_p", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_WR_DATA" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_wr_data(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_WR_DATA'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_wr_data]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "wr_data_p", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_RD_DATA" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_rd_data(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_RD_DATA'];
    data = fpasim_wireout_read_command(addr_p = addr);


    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_rd_data]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "rd_data_p", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_STATUS" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_status(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_STATUS'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_status]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "spi_ready", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "cdce_pll_status", bit_pos_p = 4, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "amc_galr_n", bit_pos_p = 8, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "DEBUG_CTRL" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_debug_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['DEBUG_CTRL'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_debug_ctrl]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "dac_en_pattern", bit_pos_p = 4, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "rst_status", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "debug_pulse", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the "ERROR_SEL" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_error_sel(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['ERROR_SEL'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_error_sel]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "sel_error", bit_pos_p = 1, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the selected "ERRORS" register value.
 *   Note: the register to read is defined by the "ERROR_SEL" register
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_errors(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['ERRORS'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_errors]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "errors", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the selected "STATUS" register value.
 *   Note: the register to read is defined by the "ERROR_SEL" register
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_status(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['STATUS'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_status]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "status", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the selected "BOARD_ID" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_board_id(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['BOARD_ID'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_board_id]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "board_id_p", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}

/**
 * Get the selected "FIRMWARE_ID" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_firmware_id(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['FIRMWARE_ID'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_firmware_id]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "firmware_id_p", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
            msg = "firmware_id_p (ASCII): " + convert_hex_to_ascii(value_p = data, width_p = 32);
            display(msg_p = msg, level_p = level2, mode_p = mode_p);
        }
    }



    return data;
}

/**
 * Get the selected "FIRMWARE_VERSION" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_firmware_version(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['FIRMWARE_VERSION'];
    data = fpasim_wireout_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_firmware_version]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = 32, data_p = data, data_width_p = 32, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "firmware_version_p", bit_pos_p = 0, bit_width_p = 32, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }

    return data;
}



/**
 * Get a register value by name.
 * @param {string} reg_name_p - register name.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {object} dic.data - data value (all read bits).
 * @return {object} dic.error - error value.
 * @return {object} dic.field_name(s) - (optional) value(s) of the differents fields, if exist.
 */
function fpasim_get_wireout_by_name(reg_name_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    data = 0;
    switch (reg_name_p) {
        case 'CTRL':
            data = fpasim_get_wireout_ctrl(level_p = level0, mode_p, verbosity_p);
            break;
        case 'MAKE_PULSE':
            data = fpasim_get_wireout_make_pulse(level_p = level0, mode_p, verbosity_p);
            break;
        case 'FPASIM_GAIN':
            data = fpasim_get_wireout_fpasim_gain(level_p = level0, mode_p, verbosity_p);
            break;
        case 'MUX_SQ_FB_DELAY':
            data = fpasim_get_wireout_mux_sq_fb_delay(level_p = level0, mode_p, verbosity_p);
            break;
        case 'AMP_SQ_OF_DELAY':
            data = fpasim_get_wireout_amp_sq_of_delay(level_p = level0, mode_p, verbosity_p);
            break;
        case 'ERROR_DELAY':
            data = fpasim_get_wireout_error_delay(level_p = level0, mode_p, verbosity_p);
            break;
        case 'RA_DELAY':
            data = fpasim_get_wireout_ra_delay(level_p = level0, mode_p, verbosity_p);
            break;
        case 'TES_CONF':
            data = fpasim_get_wireout_tes_conf(level_p = level0, mode_p, verbosity_p);
            break;

        case 'CONF0':
            data = fpasim_get_wireout_conf0(level_p = level0, mode_p, verbosity_p);
            break;

            // case 'RFU':
            //   data = FPA_WireOutValues[8];
            //   break;

            // case 'RFU':
            //   data = FPA_WireOutValues[9];
            //   break;

        case 'FPASIM_STATUS':
            data = fpasim_get_wireout_fpasim_status(level_p = level0, mode_p, verbosity_p);
            break;

        case 'DATA_COUNT':
            data = fpasim_get_wireout_data_count(level_p = level0, mode_p, verbosity_p);
            break;
        case 'REC_CTRL':
            data = fpasim_get_wireout_rec_ctrl(level_p = level0, mode_p, verbosity_p);
            break;
        case 'REC_CONF0':
            data = fpasim_get_wireout_rec_conf0(level_p = level0, mode_p, verbosity_p);
            break;

            // case 'RFU':
            //   data = FPA_WireOutValues[14];
            //   break;

            // case 'RFU':
            //   data = FPA_WireOutValues[15];
            //   break;

            // case 'RFU':
            //   data = FPA_WireOutValues[16];
            //   break;

        case 'REC_DATA_COUNT':
            data = fpasim_get_wireout_rec_data_count(level_p = level0, mode_p, verbosity_p);
            break;

        case 'SPI_CTRL':
            data = fpasim_get_wireout_spi_ctrl(level_p = level0, mode_p, verbosity_p);
            break;

        case 'SPI_CONF0':
            data = fpasim_get_wireout_spi_conf0(level_p = level0, mode_p, verbosity_p);
            break;
        case 'SPI_CONF1':
            data = fpasim_get_wireout_spi_conf1(level_p = level0, mode_p, verbosity_p);
            break;
        case 'SPI_WR_DATA':
            data = fpasim_get_wireout_spi_wr_data(level_p = level0, mode_p, verbosity_p);
            break;
        case 'SPI_RD_DATA':
            data = fpasim_get_wireout_spi_rd_data(level_p = level0, mode_p, verbosity_p);
            break;
        case 'SPI_STATUS':
            data = fpasim_get_wireout_spi_status(level_p = level0, mode_p, verbosity_p);
            break;

            // case 'RFU':
            // data = FPA_WireOutValues[23];
            // break;

        case 'DEBUG_CTRL':
            data = fpasim_get_wireout_debug_ctrl(level_p = level0, mode_p, verbosity_p);
            break;

        case 'ERROR_SEL':
            data = fpasim_get_wireout_error_sel(level_p = level0, mode_p, verbosity_p);
            break;

        case 'ERRORS':
            data = fpasim_get_wireout_errors(level_p = level0, mode_p, verbosity_p);
            break;

        case 'STATUS':
            data = fpasim_get_wireout_status(level_p = level0, mode_p, verbosity_p);
            break;

            // case 'RFU':
            // data = FPA_WireOutValues[28];
            // break;

        case 'BOARD_ID':
            data = fpasim_get_wireout_board_id(level_p = level0, mode_p, verbosity_p);
            break;
        case 'FIRMWARE_ID':
            data = fpasim_get_wireout_firmware_id(level_p = level0, mode_p, verbosity_p);
            break;
        case 'FIRMWARE_VERSION':
            data = fpasim_get_wireout_firmware_version(level_p = level0, mode_p, verbosity_p);
            break;
        default:
            const msg = "[fpasim_get_wireout_by_name]: Error " + reg_name_p + " doesn't exist."
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
            break;
    }

    return data;


}

/**
 * Get the selected "ERRORS" register value by id.
 * @param {number} sel_error_p - error id. The range is [0;10].
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} Read register value.
 */
function fpasim_get_error_by_id(sel_error_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    // Select the errors to read
    const data0 = fpasim_build_error_sel(sel_error_p = sel_error_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = "ERROR_SEL", data_p = data0, level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    // read the selected errors
    const data = fpasim_get_wireout_by_name(reg_name_p = "ERRORS", level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    return data;
}