// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   fpasim_tools.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//    This script defines base functions to access (read/write) to the FPASim functions.
//    In particular, functions associated to the SPI module bridge are defined for the downstream javascript.
//
//    Note:
//      . This script only implemented function to access registers not yet implemented by the Xifu Studio application.
//
// -------------------------------------------------------------------------------------------------------------
include("./fpasim/utils_tools.dscript")

// verbosity min to display register access
const c_FPASIM_REG_VERBOSITY_MIN = 0;
// verbosity min to display (addr,data)
const c_FPASIM_ADDR_VERBOSITY_MIN = 1;
// verbosity min to display register bit
const c_FPASIM_BIT_VERBOSITY_MIN = c_FPASIM_ADDR_VERBOSITY_MIN + 1;

/*
 Trig in address
 */
const FPASIM_ADDR_TRIGIN = {};
FPASIM_ADDR_TRIGIN['TRIG'] = 0x40;

/*
 position of trig bit in trig_in
*/
const FPASIM_POS_TRIGIN = {};
FPASIM_POS_TRIGIN['reg_valid'] = 0;
FPASIM_POS_TRIGIN['make_pulse'] = 4;
FPASIM_POS_TRIGIN['rd_all'] = 8;
FPASIM_POS_TRIGIN['ctrl_valid'] = 12;
FPASIM_POS_TRIGIN['debug_valid'] = 16;
FPASIM_POS_TRIGIN['rec_valid'] = 20;
FPASIM_POS_TRIGIN['spi_valid'] = 24;

/*
  Wire in addresses
*/
const FPASIM_ADDR_WIREIN = {};
FPASIM_ADDR_WIREIN['CTRL'] = 0x00; // 0
FPASIM_ADDR_WIREIN['MAKE_PULSE'] = 0x01; // 1
//FPASIM_ADDR_WIREIN['RFU'] = 0x02; // 2
FPASIM_ADDR_WIREIN['MUX_SQ_FB_DELAY'] = 0x03; // 3
FPASIM_ADDR_WIREIN['AMP_SQ_OF_DELAY'] = 0x04; // 4
FPASIM_ADDR_WIREIN['ERROR_DELAY'] = 0x05; // 5
FPASIM_ADDR_WIREIN['RA_DELAY'] = 0x06; // 6
FPASIM_ADDR_WIREIN['TES_CONF'] = 0x07; // 7
FPASIM_ADDR_WIREIN['CONF0'] = 0x08; // 8
// FPASIM_ADDR_WIREIN['RFU'] = 0x09; // 9
// FPASIM_ADDR_WIREIN['FPASIM_STATUS'] = 0x0A; // 10
// FPASIM_ADDR_WIREIN['DATA_COUNT'] = 0x0B; // 11
FPASIM_ADDR_WIREIN['REC_CTRL'] = 0x0C; // 12
FPASIM_ADDR_WIREIN['REC_CONF0'] = 0x0D; // 13
// FPASIM_ADDR_WIREIN['RFU'] = 0x0E; // 14
// FPASIM_ADDR_WIREIN['RFU'] = 0x0F; // 15
// FPASIM_ADDR_WIREIN['RFU'] = 0x10; // 16
// FPASIM_ADDR_WIREIN['REC_DATA_COUNT'] = 0x11; // 17
FPASIM_ADDR_WIREIN['SPI_CTRL'] = 0x12; // 18
FPASIM_ADDR_WIREIN['SPI_CONF0'] = 0x13; // 19
FPASIM_ADDR_WIREIN['SPI_CONF1'] = 0x14; // 20
FPASIM_ADDR_WIREIN['SPI_WR_DATA'] = 0x15; // 21
// FPASIM_ADDR_WIREIN['SPI_RD_DATA'] = 0x16; // 22
// FPASIM_ADDR_WIREIN['SPI_STATUS'] = 0x17; // 23
FPASIM_ADDR_WIREIN['DEBUG_CTRL'] = 0x18; // 24
FPASIM_ADDR_WIREIN['ERROR_SEL'] = 0x19; // 25
// FPASIM_ADDR_WIREIN['ERRORS'] = 0x1A; // 26
// FPASIM_ADDR_WIREIN['STATUS'] = 0x1B; // 27
// FPASIM_ADDR_WIREIN['RFU'] = 0x1C; // 28
// FPASIM_ADDR_WIREIN['HARDWARE_ID'] = 0x1D; // 29
// FPASIM_ADDR_WIREIN['FIRMWARE_ID'] = 0x1E; // 30
// FPASIM_ADDR_WIREIN['FIRMWARE_VERSION'] = 0x1F; // 31


/*
  Wire out addresses
*/
const FPASIM_ADDR_WIREOUT = {};
FPASIM_ADDR_WIREOUT['CTRL'] = 0x20; // 0
FPASIM_ADDR_WIREOUT['MAKE_PULSE'] = 0x21; // 1
// FPASIM_ADDR_WIREOUT['RFU'] = 0x22; // 2
FPASIM_ADDR_WIREOUT['MUX_SQ_FB_DELAY'] = 0x23; // 3
FPASIM_ADDR_WIREOUT['AMP_SQ_OF_DELAY'] = 0x24; // 4
FPASIM_ADDR_WIREOUT['ERROR_DELAY'] = 0x25; // 5
FPASIM_ADDR_WIREOUT['RA_DELAY'] = 0x26; // 6
FPASIM_ADDR_WIREOUT['TES_CONF'] = 0x27; // 7
FPASIM_ADDR_WIREOUT['CONF0'] = 0x28; // 8
// FPASIM_ADDR_WIREOUT['RFU'] = 0x29; // 9
FPASIM_ADDR_WIREOUT['FPASIM_STATUS'] = 0x2A; // 10
FPASIM_ADDR_WIREOUT['DATA_COUNT'] = 0x2B; // 11
FPASIM_ADDR_WIREOUT['REC_CTRL'] = 0x2C; // 12
FPASIM_ADDR_WIREOUT['REC_CONF0'] = 0x2D; // 13
// FPASIM_ADDR_WIREOUT['RFU'] = 0x2E; // 14
// FPASIM_ADDR_WIREOUT['RFU'] = 0x2F; // 15
// FPASIM_ADDR_WIREOUT['RFU'] = 0x30; // 16
FPASIM_ADDR_WIREOUT['REC_DATA_COUNT'] = 0x31; // 17
FPASIM_ADDR_WIREOUT['SPI_CTRL'] = 0x32; // 18
FPASIM_ADDR_WIREOUT['SPI_CONF0'] = 0x33; // 19
FPASIM_ADDR_WIREOUT['SPI_CONF1'] = 0x34; // 20
FPASIM_ADDR_WIREOUT['SPI_WR_DATA'] = 0x35; // 21
FPASIM_ADDR_WIREOUT['SPI_RD_DATA'] = 0x36; // 22
FPASIM_ADDR_WIREOUT['SPI_STATUS'] = 0x37; // 23
FPASIM_ADDR_WIREOUT['DEBUG_CTRL'] = 0x38; // 24
FPASIM_ADDR_WIREOUT['ERROR_SEL'] = 0x39; // 25
FPASIM_ADDR_WIREOUT['ERRORS'] = 0x3A; // 26
FPASIM_ADDR_WIREOUT['STATUS'] = 0x3B; // 27
// FPASIM_ADDR_WIREOUT['RFU'] = 0x3C; // 28
FPASIM_ADDR_WIREOUT['HARDWARE_ID'] = 0x3D; // 29
FPASIM_ADDR_WIREOUT['FIRMWARE_ID'] = 0x3E; // 30
FPASIM_ADDR_WIREOUT['FIRMWARE_VERSION'] = 0x3F; // 31



/**
 * Build the word to write in the "CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rst_p - reset.
 * @param {number} en_p - enable.
 * @return {number} built word.
 */
function fpasim_build_ctrl(rst_p, en_p) {
    const data = (rst_p << 1) + en_p;

    return data;
}

/**
 * Build the word to write in the "MAKE_PULSE" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} pixel_all_p    -
 * @param {number} pixel_id_p     -
 * @param {number} time_shift_p   -
 * @param {number} pulse_height_p -
 * @return {number} built word.
 */
function fpasim_build_make_pulse(pixel_all_p, pixel_id_p, time_shift_p, pulse_height_p) {
    const data = (pixel_all_p << 31) + (pixel_id_p << 24) + (time_shift_p << 16) + (pulse_height_p)
    return data;
}


/**
 * Build the word to write in the "MUX_SQ_FB_DELAY" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} mux_sq_fb_delay_p -
 * @return {number} built word.
 */
function fpasim_build_mux_sq_fb_delay(mux_sq_fb_delay_p) {
    const data = mux_sq_fb_delay_p;
    return data;
}

/**
 * Build the word to write in the "AMP_SQ_OF_DELAY" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} amp_sq_of_delay_p -
 * @return {number} built word.
 */
function fpasim_build_amp_sq_of_delay(amp_sq_of_delay_p) {
    const data = amp_sq_of_delay_p;
    return data;
}

/**
 * Build the word to write in the "ERROR_DELAY" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} error_delay_p -
 * @return {number} built word.
 */
function fpasim_build_error_delay(error_delay_p) {
    const data = error_delay_p;
    return data;
}

/**
 * Build the word to write in the "RA_DELAY" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} ra_delay_p -
 * @return {number} built word.
 */
function fpasim_build_ra_delay(ra_delay_p) {
    const data = ra_delay_p;
    return data;
}

/**
 * Build the word to write in the "TES_CONF" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} nb_pixel_by_frame_p -
 * @param {number} nb_sample_by_pixel_p -
 * @param {number} nb_samples_by_frame_p -
 * @return {number} built word.
 */
function fpasim_build_tes_conf(nb_pixel_by_frame_p, nb_sample_by_pixel_p, nb_samples_by_frame_p) {
    const data = (nb_pixel_by_frame_p << 24) + (nb_sample_by_pixel_p << 16) + nb_samples_by_frame_p;
    return data;
}

/**
 * Build the word to write in the "CONF0" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} inter_squid_gain_p -
 * @return {number} built word.
 */
function fpasim_build_conf0(inter_squid_gain_p) {
    const data = inter_squid_gain_p;
    return data;
}


/**
 * Build the word to write in the "SPI_CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rst_p -
 * @param {number} en_p -
 * @return {number} built word.
 */
function fpasim_build_spi_ctrl(rst_p, en_p) {
    const data = (rst_p << 1) + (en_p);
    return data;
}


/**
 * Build the word to write in the "SPI_CONF0" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} spi_id_p -
 * @param {number} spi_mode_p -
 * @return {number} built word.
 */
function fpasim_build_spi_conf0(spi_id_p, spi_mode_p) {
    const data = (spi_id_p << 4) + spi_mode_p;
    return data;
}

/**
 * Build the word to write in the "SPI_CONF1" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} spi_dac_tx_en_p -
 * @return {number} built word.
 */
function fpasim_build_spi_conf1(spi_dac_tx_en_p) {
    const data = (spi_dac_tx_en_p << 0);
    return data;
}

/**
 * Build the word to write in the "SPI_WR_DATA" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} data_p -
 * @return {number} built word.
 */
function fpasim_build_spi_wr_data(data_p) {
    const data = data_p;
    return data;
}

/**
 * Build the word to write in the "REC_CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} en_p -
 * @return {number} built word.
 */
function fpasim_build_rec_ctrl(en_p) {
    const data = en_p;
    return data;
}

/**
 * Build the word to write in the "REC_CONF0" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rec_adc_nb_word_32b_p -
 * @return {number} built word.
 */
function fpasim_build_rec_conf0(rec_adc_nb_word_32b_p) {
    const data = rec_adc_nb_word_32b_p;
    return data;
}

/**
 * Build the word to write in the "debug_ctrl" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} adc1_bypass_p - 1: bypass the ADC1 (adc_amp_squid) (set the value to 0), 0: do nothing
 * @param {number} adc0_bypass_p - 1: bypass the ADC0 (adc_mux_squid) (set the value to 0), 0: do nothing
 * @param {number} dac_en_pattern_p - enable the dac pattern generator.
 * @param {number} rst_status_p - reset errors.
 * @param {number} debug_pulse_p - '1': errors are pipelined, 0': errors are latches.
 * @return {number} built word.
 */
function fpasim_build_debug_ctrl(adc1_bypass_p, adc0_bypass_p, dac_en_pattern_p, rst_status_p, debug_pulse_p) {
    const data = (adc1_bypass_p << 9) + (adc0_bypass_p << 8) + (dac_en_pattern_p << 4) + (rst_status_p << 1) + debug_pulse_p;
    return data;
}

/**
 * Build the word to write in the "ERROR_SEL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} sel_error_p -
 * @return {number} built word.
 */
function fpasim_build_error_sel(sel_error_p) {
    const data = sel_error_p;
    return data;
}


/**
 * Get the selected status register value.
 * @param {number} sel_error_p -
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_status(sel_error_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    // Select the errors to read
    const index = sel_error_p;
    fpasim_set_debug_wirein_by_name("ERROR_SEL", index, level_p, mode_p, verbosity_p);

    fpasim_get_wireout_by_name("STATUS", level_p, mode_p, verbosity_p);

    return data;
}


/**
 * Set the "CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rst_p - .
 * @param {number} en_p - .
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_ctrl(rst_p, en_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fpasim_build_ctrl(rst_p, en_p);
    const addr = FPASIM_ADDR_WIREIN["CTRL"];

    sendToFPAsim_debugSetWireIn(addr, data);

    const trig_pos = FPASIM_POS_TRIGIN['ctrl_valid'];
    const trig_addr = FPASIM_ADDR_TRIGIN['TRIG'];
    sendToFPAsim_debugSetTriggerIn(trig_addr, trig_pos);


    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_ctrl]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }
        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit("rst_p", bit_value_p = rst_p, 1, level2, mode_p);
            display_bit("en_p", bit_value_p = en_p, 1, level2, mode_p);

        }

    }


}


/**
 * Set the "SPI_CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} rst_p - reset.
 * @param {number} en_p - enable.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_spi_ctrl(rst_p, en_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fpasim_build_spi_ctrl(rst_p, en_p);
    const addr = addr = FPASIM_ADDR_WIREIN["SPI_CTRL"];

    sendToFPAsim_debugSetWireIn(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_spi_ctrl]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit("rst_p", bit_value_p = rst_p, 1, level2, mode_p);
            display_bit("en_p", bit_value_p = en_p, 1, level2, mode_p);

        }
    }


}

/**
 * Set the "SPI_CONF0" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} spi_id_p -
 * @param {number} spi_mode_p -
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_spi_conf0(spi_id_p, spi_mode_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fpasim_build_spi_conf0(spi_id_p, spi_mode_p);
    const addr = addr = FPASIM_ADDR_WIREIN["SPI_CONF0"];

    sendToFPAsim_debugSetWireIn(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_spi_conf0]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit("spi_id_p", bit_value_p = spi_id_p, 3, level2, mode_p);
            display_bit("spi_mode_p", bit_value_p = spi_mode_p, 1, level2, mode_p);

        }
    }


}

/**
 * Set the "SPI_CONF1" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 *         This function should be called before and after the dac device configuration.
 * @param {number} spi_dac_tx_en_p -
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_spi_conf1(spi_dac_tx_en_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fpasim_build_spi_conf1(spi_dac_tx_en_p);
    const addr = addr = FPASIM_ADDR_WIREIN["SPI_CONF1"];

    sendToFPAsim_debugSetWireIn(addr, data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_spi_conf1]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit("spi_dac_tx_en_p", bit_value_p = spi_dac_tx_en_p, 1, level2, mode_p);

        }
    }


}

/**
 * Set the "SPI_WR_DATA" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 *         This function should be called after the fpasim_set_spi_ctrl and fpasim_set_spi_conf0 function
 * @param {number} data_p -
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_spi_wr_data(data_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    const data = fpasim_build_spi_wr_data(data_p);
    const addr = addr = FPASIM_ADDR_WIREIN["SPI_WR_DATA"];

    sendToFPAsim_debugSetWireIn(addr, data);

    const trig_pos = FPASIM_POS_TRIGIN['spi_valid'];
    const trig_addr = FPASIM_ADDR_TRIGIN['TRIG'];
    sendToFPAsim_debugSetTriggerIn(trig_addr, trig_pos);


    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_spi_wr_data]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

    }


}

/**
 * Set the "DEBUG_CTRL" register.
 *   Note: fields ( defintion, range, ...) are defined in the "0136-FPAsim-D_commands_dictionnary.xlsx" document.
 * @param {number} adc1_bypass_p - 1: bypass the ADC1 (adc_amp_squid) (set the value to 0), 0: do nothing
 * @param {number} adc0_bypass_p - 1: bypass the ADC0 (adc_mux_squid) (set the value to 0), 0: do nothing
 * @param {number} dac_en_pattern_p - enable the dac pattern generator.
 * @param {number} rst_status_p - reset errors.
 * @param {number} debug_pulse_p - '1': errors are pipelined, 0': errors are latches.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function fpasim_set_debug_ctrl(adc1_bypass_p, adc0_bypass_p, dac_en_pattern_p, rst_status_p, debug_pulse_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = fpasim_build_debug_ctrl(adc1_bypass_p, adc0_bypass_p, dac_en_pattern_p, rst_status_p, debug_pulse_p)
    const addr = FPASIM_ADDR_WIREIN["DEBUG_CTRL"];

    sendToFPAsim_debugSetWireIn(addr, data);

    const trig_pos = FPASIM_POS_TRIGIN['debug_valid'];
    const trig_addr = FPASIM_ADDR_TRIGIN['TRIG'];
    sendToFPAsim_debugSetTriggerIn(trig_addr, trig_pos);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_set_debug_ctrl]: Set the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit("adc1_bypass_p", bit_value_p = adc1_bypass_p, 9, level2, mode_p);
            display_bit("adc0_bypass_p", bit_value_p = adc0_bypass_p, 8, level2, mode_p);
            display_bit("dac_en_pattern_p", bit_value_p = dac_en_pattern_p, 1, level2, mode_p);
            display_bit("rst_status_p", bit_value_p = rst_status_p, 1, level2, mode_p);
            display_bit("debug_pulse_p", bit_value_p = debug_pulse_p, 1, level2, mode_p);

        }
    }


}

/**
 * Set the selected register value.
 *   Note: for few registers, the sendToFPAsim_debugSetTriggerIn function is called.
 * @param {string} reg_name_p - Name of the FPASIM register.
 * @param {number} data_p - data to write in the register.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */

function fpasim_set_debug_wirein_by_name(reg_name_p, data_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    data = data_p;
    addr = 0;
    trig_addr = FPASIM_ADDR_TRIGIN['TRIG'];
    trig_pos = -1;
    error = 0;
    switch (reg_name_p) {
        case 'CTRL': // 00
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['ctrl_valid'];
            break;

        case 'MAKE_PULSE': // 01
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['make_pulse'];
            break;

        // case 'RFU': // 02
        //       break;

        case 'MUX_SQ_FB_DELAY': // 03
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;

        case 'AMP_SQ_OF_DELAY': // 04
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;

        case 'ERROR_DELAY': // 05
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;

        case 'RA_DELAY': // 06
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;

        case 'TES_CONF': // 07
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;

        case 'CONF0': // 08
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['reg_valid'];
            break;

            // case 'RFU': // 09
            //   break;

            // case 'FPASIM_STATUS': // 10
            //   break;

            // case 'DATA_COUNT': // 11
            //     break;

        case 'REC_CTRL': // 12
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['rec_valid'];
            // trig_pos = -1;
            break;

        case 'REC_CONF0': // 13
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['rec_valid'];
            break;

            // case 'RFU': // 14
            //   break;

            // case 'RFU': // 15
            //   break;

            // case 'RFU': // 16
            //   break;

            // case 'REC_DATA_COUNT': // 17
            //     break;

        case 'SPI_CTRL': // 18
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;

        case 'SPI_CONF0': // 19
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;

        case 'SPI_CONF1': // 20
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;

        case 'SPI_WR_DATA': // 21
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['spi_valid'];
            break;

        // case 'SPI_RD_DATA': // 22
            //     break;

        // case 'SPI_STATUS': // 23
        //     break;

        case 'DEBUG_CTRL': // 24
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = FPASIM_POS_TRIGIN['debug_valid'];
            break;

        case 'ERROR_SEL': // 25
            addr = FPASIM_ADDR_WIREIN[reg_name_p];
            trig_pos = -1;
            break;

            // case 'ERRORS': // 26
            //     break;

            // case 'STATUS': // 27
            //     break;

            // case 'RFU': // 28
            // break;

            // case 'HARDWARE_ID': // 29
            //     break;

            // case 'FIRMWARE_ID': // 30
            //     break;

            // case 'FIRMWARE_VERSION': // 31
            //     break;
        default:
            msg = "[KO][fpasim_set_debug_wirein_by_name]: The register " + reg_name_p + " doesn't exist."
            display(msg, level0, mode_p);
            error = 1;
            break;
    }

    if (error == 0) {

        sendToFPAsim_debugSetWireIn(addr, data);

        if (trig_pos != -1) {
            sendToFPAsim_debugSetTriggerIn(trig_addr, trig_pos);
        }
        if (verbosity_p < 0) {
            // do nothing
        } else {

            if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
                msg = "[fpasim_set_debug_wirein_by_name]: Set " + reg_name_p;
                display(msg, level0, mode_p);
            }

            if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
                display_register(addr, 32, data, 32, level1, mode_p);
            }

            if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
                if (trig_pos != -1) {
                    msg = "[fpasim_set_debug_wirein_by_name]: Set Trig (bit" + trig_pos.toString(10) + ")";
                    display(msg, level0, mode_p);
                }
            }

        }


    }

}

/**
 * Get the register value (wireout access).
 *   Note: for few registers, the sendToFPAsim_debugSetTriggerIn function is also called.
 * @param {number} addr_p - data to write in the register.
 * @return {number} read register value.
 */
function fpasim_wireout_read_command(addr_p) {
    // shift address
    const index = addr_p - 0x20;
    //---------------------------------------------------------------------
    // Read wire out registers
    //---------------------------------------------------------------------
    // waitMs(50);
    getLatestValue("FPAsim_WireOuts_x20_to_x3F");
    const data = FPAsim_WireOuts_x20_to_x3F[index];

    return data;
}

/**
 * Get the "CTRL" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['CTRL'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {

        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_ctrl]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("en", 0, 1, data, level2, mode_p);
            display_bit_from_data("rst", 1, 1, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "MAKE_PULSE" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_make_pulse(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['MAKE_PULSE'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_make_pulse]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("pulse_height", 0, 11, data, level2, mode_p);
            display_bit_from_data("time_shift", 16, 4, data, level2, mode_p);
            display_bit_from_data("pixel_id", 24, 6, data, level2, mode_p);
            display_bit_from_data("pixel_all", 31, 1, data, level2, mode_p);
        }
    }

    return data;
}


/**
 * Get the "MUX_SQ_FB_DELAY" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_mux_sq_fb_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['MUX_SQ_FB_DELAY'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_mux_sq_fb_delay]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("gain_p", 0, 6, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "AMP_SQ_OF_DELAY" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_amp_sq_of_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['AMP_SQ_OF_DELAY'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_amp_sq_of_delay]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("gain_p", 0, 6, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "ERROR_DELAY" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_error_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['ERROR_DELAY'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_error_delay]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("gain_p", 0, 6, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "RA_DELAY" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_ra_delay(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['RA_DELAY'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_ra_delay]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("gain_p", 0, 6, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "TES_CONF" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_tes_conf(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['TES_CONF'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_tes_conf]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("nb_sample_by_frame", 0, 16, data, level2, mode_p);
            display_bit_from_data("nb_sample_by_pixel", 0, 7, data, level2, mode_p);
            display_bit_from_data("nb_pixel_by_frame", 0, 6, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "CONF0" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_conf0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['CONF0'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_conf0]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("inter_squid_gain_p", 0, 8, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "FPASIM_STATUS" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_fpasim_status(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['FPASIM_STATUS'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_fpasim_status]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("tes_neg_out_pixel_id", 0, 6, data, level2, mode_p);
            display_bit_from_data("tes_neg_out_error", 7, 1, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "DATA_COUNT" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_data_count(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['DATA_COUNT'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_data_count]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("pipe_data_count", 0, 16, data, level2, mode_p);
            display_bit_from_data("make_pulse_wr_data_count", 16, 16, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "REC_CTRL" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_rec_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['REC_CTRL'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_rec_ctrl]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("rec_adc_en", 0, 1, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "REC_CONF0" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_rec_conf0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['REC_CONF0'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_rec_conf0]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("rec_adc_nb_word_32b_p", 0, 16, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "REC_DATA_COUNT" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_rec_data_count(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['REC_DATA_COUNT'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_rec_data_count]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("rec_adc_data_count_p", 0, 16, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_CTRL" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_CTRL'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_ctrl]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("rst_p", 1, 1, data, level2, mode_p);
            display_bit_from_data("en_p", 0, 1, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_CONF0" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_conf0(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_CONF0'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_conf0]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("spi_id_p", 4, 2, data, level2, mode_p);
            display_bit_from_data("spi_mode_p", 0, 1, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_CONF1" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_conf1(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_CONF1'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_conf1]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("spi_dac_tx_enable_p", 0, 1, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_WR_DATA" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_wr_data(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_WR_DATA'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_wr_data]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("wr_data_p", 0, 32, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_RD_DATA" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_rd_data(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_RD_DATA'];
    data = fpasim_wireout_read_command(addr);


    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_rd_data]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("rd_data_p", 0, 32, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "SPI_STATUS" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_spi_status(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['SPI_STATUS'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_spi_status]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("spi_ready", 0, 1, data, level2, mode_p);
            display_bit_from_data("cdce_pll_status", 4, 1, data, level2, mode_p);
            display_bit_from_data("amc_galr_n", 8, 1, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "DEBUG_CTRL" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_debug_ctrl(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['DEBUG_CTRL'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_debug_ctrl]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("adc1_bypass", 9, 1, data, level2, mode_p);
            display_bit_from_data("adc0_bypass", 8, 1, data, level2, mode_p);
            display_bit_from_data("dac_en_pattern", 4, 1, data, level2, mode_p);
            display_bit_from_data("rst_status", 1, 1, data, level2, mode_p);
            display_bit_from_data("debug_pulse", 0, 1, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the "ERROR_SEL" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_error_sel(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['ERROR_SEL'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_error_sel]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("sel_error", 1, 4, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the selected "ERRORS" register value.
 *   Note: the register to read is defined by the "ERROR_SEL" register
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_errors(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['ERRORS'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_errors]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("errors", 0, 32, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the selected "STATUS" register value.
 *   Note: the register to read is defined by the "ERROR_SEL" register
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_status(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['STATUS'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_status]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("status", 0, 32, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the selected "HARDWARE_ID" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_hardware_id(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['HARDWARE_ID'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_hardware_id]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("board_id_p", 0, 32, data, level2, mode_p);
        }
    }

    return data;
}

/**
 * Get the selected "FIRMWARE_ID" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_firmware_id(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['FIRMWARE_ID'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_firmware_id]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("firmware_id_p", 0, 32, data, level2, mode_p);
            msg = "firmware_id_p (ASCII): " + convert_hex_to_ascii(value_p = data, width_p = 32);
            display(msg_p = msg, level2, mode_p);
        }
    }



    return data;
}

/**
 * Get the selected "FIRMWARE_VERSION" register value.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} read register value.
 */
function fpasim_get_wireout_firmware_version(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    addr = FPASIM_ADDR_WIREOUT['FIRMWARE_VERSION'];
    data = fpasim_wireout_read_command(addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_FPASIM_REG_VERBOSITY_MIN) {
            msg = "[fpasim_get_wireout_firmware_version]: Get the register value ";
            display(msg, level0, mode_p);
        }

        if (verbosity_p >= c_FPASIM_ADDR_VERBOSITY_MIN) {
            display_register(addr, 32, data, 32, level1, mode_p);
        }

        if (verbosity_p >= c_FPASIM_BIT_VERBOSITY_MIN) {
            display_bit_from_data("firmware_version_p", 0, 32, data, level2, mode_p);
        }
    }

    return data;
}



/**
 * Get a register value by name.
 * @param {string} reg_name_p - register name.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {object} dic.data - data value (all read bits).
 * @return {object} dic.error - error value.
 * @return {object} dic.field_name(s) - (optional) value(s) of the differents fields, if exist.
 */
function fpasim_get_wireout_by_name(reg_name_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    data = 0;
    switch (reg_name_p) {
        case 'CTRL':  // 00
            data = fpasim_get_wireout_ctrl(level0, mode_p, verbosity_p);
            break;

        case 'MAKE_PULSE':  // 01
            data = fpasim_get_wireout_make_pulse(level0, mode_p, verbosity_p);
            break;

        // case 'RFU':  // 02
            //   break;

        case 'MUX_SQ_FB_DELAY':  // 03
            data = fpasim_get_wireout_mux_sq_fb_delay(level0, mode_p, verbosity_p);
            break;

        case 'AMP_SQ_OF_DELAY':  // 04
            data = fpasim_get_wireout_amp_sq_of_delay(level0, mode_p, verbosity_p);
            break;

        case 'ERROR_DELAY':  // 05
            data = fpasim_get_wireout_error_delay(level0, mode_p, verbosity_p);
            break;

        case 'RA_DELAY':  // 06
            data = fpasim_get_wireout_ra_delay(level0, mode_p, verbosity_p);
            break;

        case 'TES_CONF':  // 07
            data = fpasim_get_wireout_tes_conf(level0, mode_p, verbosity_p);
            break;

        case 'CONF0':  // 08
            data = fpasim_get_wireout_conf0(level0, mode_p, verbosity_p);
            break;

        // case 'RFU':  // 09
            //   break;

        case 'FPASIM_STATUS': // 10
            data = fpasim_get_wireout_fpasim_status(level0, mode_p, verbosity_p);
            break;

        case 'DATA_COUNT': // 11
            data = fpasim_get_wireout_data_count(level0, mode_p, verbosity_p);
            break;

        case 'REC_CTRL': // 12
            data = fpasim_get_wireout_rec_ctrl(level0, mode_p, verbosity_p);
            break;

        case 'REC_CONF0': // 13
            data = fpasim_get_wireout_rec_conf0(level0, mode_p, verbosity_p);
            break;

            // case 'RFU': // 14
            //   break;

            // case 'RFU': // 15
            //   break;

            // case 'RFU': // 16
            //   break;

        case 'REC_DATA_COUNT': // 17
            data = fpasim_get_wireout_rec_data_count(level0, mode_p, verbosity_p);
            break;

        case 'SPI_CTRL': // 18
            data = fpasim_get_wireout_spi_ctrl(level0, mode_p, verbosity_p);
            break;

        case 'SPI_CONF0': // 19
            data = fpasim_get_wireout_spi_conf0(level0, mode_p, verbosity_p);
            break;

        case 'SPI_CONF1': // 20
            data = fpasim_get_wireout_spi_conf1(level0, mode_p, verbosity_p);
            break;

        case 'SPI_WR_DATA': // 21
            data = fpasim_get_wireout_spi_wr_data(level0, mode_p, verbosity_p);
            break;

        case 'SPI_RD_DATA': // 22
            data = fpasim_get_wireout_spi_rd_data(level0, mode_p, verbosity_p);
            break;

        case 'SPI_STATUS': // 23
            data = fpasim_get_wireout_spi_status(level0, mode_p, verbosity_p);
            break;

        case 'DEBUG_CTRL': // 24
            data = fpasim_get_wireout_debug_ctrl(level0, mode_p, verbosity_p);
            break;

        case 'ERROR_SEL': // 25
            data = fpasim_get_wireout_error_sel(level0, mode_p, verbosity_p);
            break;

        case 'ERRORS': // 26
            data = fpasim_get_wireout_errors(level0, mode_p, verbosity_p);
            break;

        case 'STATUS': // 27
            data = fpasim_get_wireout_status(level0, mode_p, verbosity_p);
            break;

            // case 'RFU': // 28
            // break;

        case 'HARDWARE_ID': // 29
            data = fpasim_get_wireout_hardware_id(level0, mode_p, verbosity_p);
            break;

        case 'FIRMWARE_ID': // 30
            data = fpasim_get_wireout_firmware_id(level0, mode_p, verbosity_p);
            break;

        case 'FIRMWARE_VERSION': // 31
            data = fpasim_get_wireout_firmware_version(level0, mode_p, verbosity_p);
            break;

        default:
            const msg = "[fpasim_get_wireout_by_name]: Error " + reg_name_p + " doesn't exist."
            display(msg, level0, mode_p);
            break;
    }

    return data;


}

/**
 * Get the selected "ERRORS" register value by id.
 * @param {number} sel_error_p - error id. The range is [0;10].
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} Read register value.
 */
function fpasim_get_error_by_id(sel_error_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;

    // Select the errors to read
    const data0 = fpasim_build_error_sel(sel_error_p);
    fpasim_set_debug_wirein_by_name("ERROR_SEL", data0, level_p, mode_p, verbosity_p);

    // read the selected errors
    const data = fpasim_get_wireout_by_name("ERRORS", level_p, mode_p, verbosity_p);

    return data;
}