// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   dac3283.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//   This script defines base functions to access (read/write) the DAC device (FMC150 card) via the FPASim SPI module bridge.
//
//   Note:
//      . Tested with javascript
//
// -------------------------------------------------------------------------------------------------------------

// import libraries
include("./fpasim/utils_tools.dscript");
include("./fpasim/fpasim.dscript");

// define the SPI device registers (see datasheet: dac3283 device)
const DAC_ADDR = {};
DAC_ADDR['reg0'] = 0x00;
DAC_ADDR['reg1'] = 0x01;
DAC_ADDR['reg2'] = 0x02;
DAC_ADDR['reg3'] = 0x03;
DAC_ADDR['reg4'] = 0x04;
DAC_ADDR['reg5'] = 0x05;
DAC_ADDR['reg6'] = 0x06;
DAC_ADDR['reg7'] = 0x07;
DAC_ADDR['reg8'] = 0x08;
DAC_ADDR['reg9'] = 0x09;
DAC_ADDR['reg10'] = 0x0A;
DAC_ADDR['reg11'] = 0x0B;
DAC_ADDR['reg12'] = 0x0C;
DAC_ADDR['reg13'] = 0x0D;
DAC_ADDR['reg14'] = 0x0E;
DAC_ADDR['reg15'] = 0x0F;
DAC_ADDR['reg16'] = 0x10;
DAC_ADDR['reg17'] = 0x11;
DAC_ADDR['reg18'] = 0x12;
DAC_ADDR['reg19'] = 0x13;
DAC_ADDR['reg20'] = 0x14;
DAC_ADDR['reg21'] = 0x15;
DAC_ADDR['reg22'] = 0x16;
DAC_ADDR['reg23'] = 0x17;
DAC_ADDR['reg24'] = 0x18;
DAC_ADDR['reg25'] = 0x19;
DAC_ADDR['reg26'] = 0x1A;
DAC_ADDR['reg27'] = 0x1B;
DAC_ADDR['reg28'] = 0x1C;
DAC_ADDR['reg29'] = 0x1D;
DAC_ADDR['reg30'] = 0x1E;
DAC_ADDR['reg31'] = 0x1F;

// verbosity min to display register access
const c_DAC_REG_VERBOSITY_MIN = 0;
// verbosity min to display (addr,data)
const c_DAC_ADDR_VERBOSITY_MIN = 1;
// verbosity min to display register bit
const c_DAC_BIT_VERBOSITY_MIN = 2;

// address width of the spi device register
const c_DAC_SPI_ADDR_WIDTH = 8;
// data width of the spi device register
const c_DAC_SPI_DATA_WIDTH = 8;

/**
 * Enable the FPASIM SPI MODULE (bridge)
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 */
function dac_spi_enable(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;

    //---------------------------------------------------------------------
    //-- write in the SPI_CTRL register 
    //---------------------------------------------------------------------

    // en the spi links
    const rst = 0;
    const en = 1;
    fpasim_set_spi_ctrl(rst_p = rst, en_p = en, level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);

}

/**
 * Write a spi device register through the FPASIM SPI MODULE (bridge).
 *
 * @param {number} addr_p - register address of the SPI device to write.
 * @param {number} data_p - value to write in the spi device register.
 */
function dac_write_command(addr_p, data_p) {

    //---------------------------------------------------------------------
    // write in the SPI_CONF0 register
    //---------------------------------------------------------------------
    const spi_mode = 1; // 0: rd, 1: wr
    const spi_id = 2; // 0: cdce,1: adc, 2: dac, 3: amc
    fpasim_set_spi_conf0(spi_id_p = spi_id, spi_mode_p = spi_mode, level_p = 0, mode_p = 0, verbosity_p = -1);

    //---------------------------------------------------------------------
    // build the SPI commands
    //   (see the dac3283 datasheet)
    //---------------------------------------------------------------------
    // mode
    //  wr : 0
    //  rd : 1
    const mode = 0;
    // Number of Transferred Bytes Within One Communication Frame
    //  '00' : 1 byte
    //  '01' : 2 bytes
    //  '10' : 3 bytes
    //  '11' : 4 bytes
    const nb_bytes = parseInt('00', 2);

    const cmd = (mode << 7) + (nb_bytes << 5) + addr_p;
    const spi_cmd = (cmd << 8) + data_p;

    fpasim_set_spi_wr_data(data_p = spi_cmd, level_p = 0, mode_p = 0, verbosity_p = -1);

}

/**
 * Read a spi device register value.
 *
 * @param {number} addr_p - register address of the SPI device to read.
 * @return {number} read value from the spi device register.
 *
 */
function dac_read_command(addr_p) {

    //---------------------------------------------------------------------
    // write in the SPI_CONF0 register
    //---------------------------------------------------------------------
    const spi_mode = 0; // 0: rd, 1: wr
    const spi_id = 2; // 0: cdce,1: adc, 2: dac, 3: amc
    fpasim_set_spi_conf0(spi_id_p = spi_id, spi_mode_p = spi_mode, level_p = 0, mode_p = 0, verbosity_p = -1);

    //---------------------------------------------------------------------
    // build the SPI commands
    //   (see the dac3283 datasheet)
    //---------------------------------------------------------------------
    // mode
    //  wr : 0
    //  rd : 1
    const mode = 1;
    // Number of Transferred Bytes Within One Communication Frame
    //  '00' : 1 byte
    //  '01' : 2 bytes
    //  '10' : 3 bytes
    //  '11' : 4 bytes
    const nb_bytes = parseInt('00', 2);

    const cmd = (mode << 7) + (nb_bytes << 5) + addr_p;

    const data = 0x00;
    const spi_cmd = (cmd << 8) + data;
    fpasim_set_spi_wr_data(data_p = spi_cmd, level_p = 0, mode_p = 0, verbosity_p = -1);
    waitMs(10);

    //---------------------------------------------------------------------
    // Read the register value from the spi device
    //---------------------------------------------------------------------
    const data = fpasim_get_wireout_spi_rd_data(level_p = 0, mode_p = 0, verbosity_p = -1);

    // keep only the data part
    // from: cmd7 .. addr0 data7 .. data0
    // to: data7.. data0
    data = (data & 0xFF);

    return data;

}

/**
 * Set the register0 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * When asserted the FIFO is enabled. When the FIFO is bypassed
 *   DACCCLKP/N and DATACLKP/N must be aligned to within t_align.
 *   [6]: R/W: fifo_ena[0]
 *
 * Allows the FRAME input to reset the FIFO write pointer when asserted
 * [5]: R/W: fifo_reset_ena[0]
 *
 * Allows the FRAME or OSTR signal to reset the FIFO read pointer when
 * asserted. This selection is determined by multi_sync_sel in register dac_CONFIG19.
 * [4]: R/W: multi_sync_ena[0]
 *
 * When asserted the ALARM_SDO pin becomes an output. The functionality of
 * this pin is controlled by the dac_CONFIG6 alarm_mask setting.
 * [3]: R/W: alarm_out_ena[0]
 *
 * This bit changes the polarity of the ALARM signal. (0=negative logic, 1=positive logic)
 * [2]: R/W: alarm_pol[0]
 *
 * Controls the function of the mixer block.
 *     Normal : 00
 *     high pass (Fs/2) : 01
 *     Fs/4 : 10
 *     -Fs/4 : 11
 * [1:0]: R/W: mixer_func[1:0]
 */
function dac_set_config0(fifo_ena_p, fifo_reset_ena_p, multi_sync_ena_p, alarm_out_ena_p, alarm_pol_p, mixer_func_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(fifo_ena_p) === 'undefined') fifo_ena_p = 1;
    if (typeof(fifo_reset_ena_p) === 'undefined') fifo_reset_ena_p = 1;
    if (typeof(multi_sync_ena_p) === 'undefined') multi_sync_ena_p = 1;
    if (typeof(alarm_out_ena_p) === 'undefined') alarm_out_ena_p = 0;
    if (typeof(alarm_pol_p) === 'undefined') alarm_pol_p = 0;
    if (typeof(mixer_func_p) === 'undefined') mixer_func_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const reserved = 0;
    const data1 = (reserved << 7) + (fifo_ena_p << 6) + (fifo_reset_ena_p << 5) + (multi_sync_ena_p << 4);
    const data0 = (alarm_out_ena_p << 3) + (alarm_pol_p << 2) + mixer_func_p;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg0'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config0]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "fifo_ena_p", bit_value_p = fifo_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "fifo_reset_ena_p", bit_value_p = fifo_reset_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "multi_sync_ena_p", bit_value_p = multi_sync_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "alarm_out_ena_p", bit_value_p = alarm_out_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "alarm_pol_p", bit_value_p = alarm_pol_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "mixer_func_p", bit_value_p = mixer_func_p, bit_width_p = 2, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Set the register1 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * When asserted the QMC offset correction circuitry is enabled.
 * [7]: R/W: qmc_offset_ena[0]
 *
 * When asserted the QMC phase and gain correction circuitry is enabled.
 * [6]: R/W: qmc_correct_ena[0]
 *
 * When asserted FIR0 is activated enabling 2x interpolation.
 * [5]: R/W: fir0_ena[0]
 *
 * When asserted FIR1 is activated enabling 4x interpolation. fir0_ena must be set to '1' for 4x interpolation.
 * [4]: R/W: fir1_ena[0]
 *
 * When asserted enables the data pattern checker operation.
 * [2]: R/W: iotest_ena[0]
 *
 * When asserted the inputs are expected to be in 2's complement format. When
 * de-asserted the input format is expected to be offset-binary.
 * [0]: R/W: twos[0]
 *
 */
function dac_set_config1(qmc_offset_ena_p, qmc_correct_ena_p, fir0_ena_p, fir1_ena_p, iotest_ena_p, twos_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(qmc_offset_ena_p) === 'undefined') qmc_offset_ena_p = 0;
    if (typeof(qmc_correct_ena_p) === 'undefined') qmc_correct_ena_p = 0;
    if (typeof(fir0_ena_p) === 'undefined') fir0_ena_p = 0;
    if (typeof(fir1_ena_p) === 'undefined') fir1_ena_p = 1;
    if (typeof(iotest_ena_p) === 'undefined') iotest_ena_p = 0;
    if (typeof(twos_p) === 'undefined') twos_p = 1;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = (qmc_offset_ena_p << 7) + (qmc_correct_ena_p << 6) + (fir0_ena_p << 5) + (fir1_ena_p << 4);
    const data0 = (iotest_ena_p << 2) + twos_p;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg1'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config1]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "qmc_offset_ena_p", bit_value_p = qmc_offset_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "qmc_correct_ena_p", bit_value_p = qmc_correct_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "fir0_ena_p", bit_value_p = fir0_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "fir1_ena_p", bit_value_p = fir1_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "iotest_ena_p", bit_value_p = iotest_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "twos_p", bit_value_p = twos_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Set the register2 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * Serial interface created sync signal. Set to '1' to cause a sync and then clear to '0' to remove it.
 * [5]: R/W: sif_sync[0]
 *
 * When asserted this bit allows the SIF sync to be used. Normal FRAME signals are ignored.
 * [4]: R/W: sif_sync_ena[0]
 *
 * Delays the output to the DACs from 0 to 3 DAC clock cycles.
 * [1:0]: R/W: output_delay[1:0]
 *
 */
function dac_set_config2(sif_sync_p, sif_sync_ena_p, output_delay_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = (sif_sync_p << 5);
    const data0 = (sif_sync_ena_p << 4) + output_delay_p;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg2'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config2]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "sif_sync_p", bit_value_p = sif_sync_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "sif_sync_ena_p", bit_value_p = sif_sync_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "output_delay_p", bit_value_p = output_delay_p, bit_width_p = 2, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Set the register3 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This enables resetting the alarms after 64 good samples with the
 * goal of removing unnecessary errors. For instance, when checking
 * setup/hold through the pattern checker test, there may initially be
 * errors. Setting this bit removes the need for a SIF write to clear the
 * alarm register.
 * [7]: R/W: cnt64_ena[0]
 *
 * This is the default FIFO read pointer position after the FIFO read
 * pointer has been synced. With this value the initial difference
 * between write and read pointers can be controlled. This may be
 * helpful in controlling the delay through the device.
 * [4:2]: R/W: fifo_offset[2:0]
 *
 * When asserted alarms from the FIFO that represent the write and
 * read pointers being 2 away are enabled.
 * [1]: R/W: alarm_2away_ena[0]
 *
 * When asserted alarms from the FIFO that represent the write and
 * read pointers being 1 away are enabled.
 * [0]: R/W: alarm_1away_ena[0]
 */
function dac_set_config3(cnt64_ena_p, fifo_offset_p, alarm_2away_ena_p, alarm_1away_ena_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(cnt64_ena_p) === 'undefined') cnt64_ena_p = 0;
    if (typeof(fifo_offset_p) === 'undefined') fifo_offset_p = int('100', 2);
    if (typeof(alarm_2away_ena_p) === 'undefined') alarm_2away_ena_p = 0;
    if (typeof(alarm_1away_ena_p) === 'undefined') alarm_1away_ena_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = (cnt64_ena_p << 7);
    const data0 = (fifo_offset_p << 2) + (alarm_2away_ena_p << 1) + alarm_1away_ena_p;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg3'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config3]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "cnt64_ena_p", bit_value_p = cnt64_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "fifo_offset_p", bit_value_p = fifo_offset_p, bit_width_p = 2, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "alarm_2away_ena_p", bit_value_p = alarm_2away_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "alarm_1away_ena_p", bit_value_p = alarm_1away_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Set the register4 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * Scales the DACA output current in 16 equal steps.
 * (VEXTIO/Rbias)*(coarse_daca/b + 1)
 * [7:4]: R/W: coarse_daca[3:0]
 *
 * Scales the DACB output current in 16 equal steps.
 * [3:0]: R/W: coarse_dacb[3:0]
 *
 */

function dac_set_config4(coarse_daca_p, coarse_dacb_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(coarse_daca_p) === 'undefined') coarse_daca_p = int('111', 2);
    if (typeof(coarse_dacb_p) === 'undefined') coarse_dacb_p = int('111', 2);
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = (coarse_daca_p << 4);
    const data0 = (coarse_dacb_p << 0);
    const data = data1 + data0;

    const addr = DAC_ADDR['reg4'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config4]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "coarse_daca_p", bit_value_p = coarse_daca_p, bit_width_p = 4, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "coarse_dacb_p", bit_value_p = coarse_dacb_p, bit_width_p = 4, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Set the register5 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This is the output from the chip temperature sensor. The value
 * of this register in two’s complement format represents the
 * temperature in degrees Celsius. This register must be read
 * with a minimum SCLK period of 1μs. (Read Only)
 * [7:0]: R: tempdata[7:0]
 */
function dac_set_config5(tempdata_p, level_p, mode_p, verbosity_p) {

    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;


    const data = tempdata_p;

    const addr = DAC_ADDR['reg5'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config5]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "tempdata_p", bit_value_p = tempdata_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}


/**
 * Set the register6 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * These bits control the masking of the alarm outputs. This
 * means that the ALARM_SDO pin will not be asserted if the
 * appropriate bit is set. The alarm will still show up in the
 * dac_CONFIG7 bits. (0=not masked, 1= masked).
 * alarm_mask                  Masked Alarm
 *       6                     alarm_from_zerochk
 *       5                     alarm_fifo_collision
 *       4                     reserved
 *       3                     alarm_from_iotest
 *       2                     not used (expansion)
 *       1                     alarm_fifo_2away
 *       0                     alarm_fifo_1away
 * [6:0]: R/W: alarm_mask[6:0] 
 *
 */
function dac_set_config6(alarm_mask_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(alarm_mask_p) === 'undefined') alarm_mask_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = alarm_mask_p;

    const addr = DAC_ADDR['reg6'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config6]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "alarm_mask_p", bit_value_p = alarm_mask_p, bit_width_p = 7, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register7 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This alarm indicates the 8-bit FIFO write pointer address has an all
 * zeros patterns. Due to pointer address being a shift register, this is
 * not a valid address and will cause the write pointer to be stuck until
 * the next sync. This error is typically caused by timing error or
 * improper power start-up sequence. If this alarm is asserted,
 * resynchronization of FIFO is necessary. Refer to the Power-Up
 * Sequence section for more detail.
 * [6]: W: alarm_from_zerochk[0]
 *
 * Alarm occurs when the FIFO pointers over/under run each other.
 * [5]: W: alarm_fifo_collision[0]
 *
 * This is asserted when the input data pattern does not match the
 * pattern in the iotest_pattern registers.
 * [3]: W: alarm_from_iotest[0]
 *
 * Alarm occurs with the read and write pointers of the FIFO are within 2 addresses of each other.
 * [1]: W: alarm_fifo_2away[0]
 *
 * Alarm occurs with the read and write pointers of the FIFO are within 1 address of each other.
 * [0]: W: alarm_fifo1away[0]
 *
 */
function dac_set_config7(alarm_from_zerochk_p, alarm_fifo_collision_p, alarm_from_iotest_p, alarm_fifo_2away_p, alarm_fifo1away_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(alarm_from_zerochk_p) === 'undefined') alarm_from_zerochk_p = 0;
    if (typeof(alarm_fifo_collision_p) === 'undefined') alarm_fifo_collision_p = 0;
    if (typeof(alarm_from_iotest_p) === 'undefined') alarm_from_iotest_p = 0;
    if (typeof(alarm_fifo_2away_p) === 'undefined') alarm_fifo_2away_p = 0;
    if (typeof(alarm_fifo1away_p) === 'undefined') alarm_fifo1away_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = (alarm_from_zerochk_p << 6) + (alarm_fifo_collision_p << 5);
    const data0 = (alarm_from_iotest_p << 3) + (alarm_fifo_2away_p << 1) + alarm_fifo1away_p;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg7'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config7]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "alarm_from_zerochk_p", bit_value_p = alarm_from_zerochk_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "alarm_fifo_collision_p", bit_value_p = alarm_fifo_collision_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "alarm_from_iotest_p", bit_value_p = alarm_from_iotest_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "alarm_fifo_2away_p", bit_value_p = alarm_fifo_2away_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "alarm_fifo1away_p", bit_value_p = alarm_fifo1away_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register8 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * The values of these bits tell which bit in the byte-wide LVDS bus
 * failed during the pattern checker test.
 * [7:0]: R/W: iotest_results[7:0]
 *
 */
function dac_set_config8(iotest_results_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(iotest_results_p) === 'undefined') iotest_results_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = iotest_results_p;

    const addr = DAC_ADDR['reg8'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config8]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "iotest_results_p", bit_value_p = iotest_results_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register9 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This is dataword0 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern0[7:0]
 *
 */
function dac_set_config9(iotest_pattern0_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(iotest_pattern0_p) === 'undefined') iotest_pattern0_p = 0x7A;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = iotest_pattern0_p;

    const addr = DAC_ADDR['reg9'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config9]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "iotest_pattern0_p", bit_value_p = iotest_pattern0_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register10 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This is dataword1 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern1[7:0]
 *
 */
function dac_set_config10(iotest_pattern1_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(iotest_pattern1_p) === 'undefined') iotest_pattern1_p = 0xB6;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = iotest_pattern1_p;

    const addr = DAC_ADDR['reg10'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config10]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "iotest_pattern1_p", bit_value_p = iotest_pattern1_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register11 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This is dataword2 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern2[7:0]
 *
 */
function dac_set_config11(iotest_pattern2_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(iotest_pattern2_p) === 'undefined') iotest_pattern2_p = 0xB6;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = iotest_pattern2_p;

    const addr = DAC_ADDR['reg11'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config11]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "iotest_pattern2_p", bit_value_p = iotest_pattern2_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register12 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This is dataword3 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern3[7:0]
 *
 */
function dac_set_config12(iotest_pattern3_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(iotest_pattern3_p) === 'undefined') iotest_pattern3_p = 0x45;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = iotest_pattern3_p;

    const addr = DAC_ADDR['reg12'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config12]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "iotest_pattern3_p", bit_value_p = iotest_pattern3_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register13 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This is dataword4 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern4[7:0]
 *
 */
function dac_set_config13(iotest_pattern4_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(iotest_pattern4_p) === 'undefined') iotest_pattern4_p = 0x1A;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = iotest_pattern4_p;

    const addr = DAC_ADDR['reg13'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config13]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "iotest_pattern4_p", bit_value_p = iotest_pattern4_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register14 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This is dataword5 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern5[7:0]
 *
 */
function dac_set_config14(iotest_pattern5_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(iotest_pattern5_p) === 'undefined') iotest_pattern5_p = 0x16;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = iotest_pattern5_p;

    const addr = DAC_ADDR['reg14'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config14]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "iotest_pattern5_p", bit_value_p = iotest_pattern5_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register15 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This is dataword6 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern6[7:0]
 *
 */
function dac_set_config15(iotest_pattern6_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(iotest_pattern6_p) === 'undefined') iotest_pattern6_p = 0xAA;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;


    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = iotest_pattern6_p;

    const addr = DAC_ADDR['reg15'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config15]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "iotest_pattern6_p", bit_value_p = iotest_pattern6_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register16 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This is dataword7 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern7[7:0]
 *
 */
function dac_set_config16(iotest_pattern7_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(iotest_pattern7_p) === 'undefined') iotest_pattern7_p = 0xC6;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;


    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data = iotest_pattern7_p;

    const addr = DAC_ADDR['reg16'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config16]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "iotest_pattern7_p", bit_value_p = iotest_pattern7_p, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register17 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This bit controls the masking of the clock monitor alarm. This
 * means that the ALARM_SDO pin will not be asserted. The alarm
 * will still show up in the clk_alarm bit. (0=not masked, 1= masked).
 * [4]: R/W: clk_alarm_mask[0]
 *
 * This bit control the masking of the transmit enable alarm. This
 * means that the ALARM_SDO pin will not be asserted. The alarm
 * will still show up in the tx_off bit. (0=not masked, 1= masked).
 * [3]: R/W: tx_off_mask[0]
 *
 * When asserted the DATACLK monitor alarm is enabled.
 * [1]: R/W: clk_alarm_ena[0]
 *
 * When asserted a clk_alarm event will automatically disable the
 * AC outputs by setting them to midscale.
 * [0]: R/W: tx_off_ena[0]
 *
 */
function dac_set_config17(clk_alarm_mask_p, tx_off_mask_p, clk_alarm_ena_p, tx_off_ena_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(clk_alarm_mask_p) === 'undefined') clk_alarm_mask_p = 0;
    if (typeof(tx_off_mask_p) === 'undefined') tx_off_mask_p = 0;
    if (typeof(clk_alarm_ena_p) === 'undefined') clk_alarm_ena_p = 0;
    if (typeof(tx_off_ena_p) === 'undefined') tx_off_ena_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const reserved = 1;
    const data1 = (reserved << 5) + (clk_alarm_mask_p << 4);
    const data0 = (tx_off_mask_p << 3) + (reserved << 2) + (clk_alarm_ena_p << 1) + tx_off_ena_p;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg17'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config17]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "clk_alarm_mask_p", bit_value_p = clk_alarm_mask_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "tx_off_mask_p", bit_value_p = tx_off_mask_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "clk_alarm_ena_p", bit_value_p = clk_alarm_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "tx_off_ena_p", bit_value_p = tx_off_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register18 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * When asserted the output to the DACA is complemented. This
 * allows to effectively change the + and – designations of the LVDS data lines.
 * [3]: R/W: daca_complement[0]
 *
 * When asserted the output to the DACB is complemented. This
 * allows to effectively change the + and – designations of the LVDS data lines.
 * [2]: R/W: dacb_complement[0]
 *
 * Enables the syncing of the clock divider using the OSTR signal
 * or the FRAME signal passed through the FIFO. This selection is
 * determined by multi_sync_sel in register dac_CONFIG19. The
 * internal divided-down clocks will be phase aligned after syncing.
 * See Power-Up Sequence section for more detail.
 * [1]: R/W: clkdiv_sync_ena[0]
 *
 */
function dac_set_config18(daca_complement_p, dacb_complement_p, clkdiv_sync_ena_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(daca_complement_p) === 'undefined') daca_complement_p = 0;
    if (typeof(dacb_complement_p) === 'undefined') dacb_complement_p = 0;
    if (typeof(clkdiv_sync_ena_p) === 'undefined') clkdiv_sync_ena_p = 1;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = 0;
    const data0 = (daca_complement_p << 3) + (dacb_complement_p << 2) + (clkdiv_sync_ena_p << 1);
    const data = data1 + data0;

    const addr = DAC_ADDR['reg18'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config18]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "daca_complement_p", bit_value_p = daca_complement_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "dacb_complement_p", bit_value_p = dacb_complement_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "clkdiv_sync_ena_p", bit_value_p = clkdiv_sync_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register19 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * When asserted the DACA data is driven onto DACB.
 * [7]: R/W: bequalsa[0]
 *
 * When asserted the DACB data is driven onto DACA.
 * [6]: R/W: aequalsb[0]
 *
 * Selects the signal source for multiple device and clock divider synchronization.
 *    multi_sync_sel                    sync_source
 *          0                            OSTR
 *          1                            Frame through FIFO handoff
 * [1]: R/W: multi_sync_sel[0]
 *
 * Reverse the input bits for the data word. MSB becomes LSB.
 * [0]: R/W: rev[0]
 *
 */
function dac_set_config19(bequalsa_p, aequalsb_p, multi_sync_sel_p, rev_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(bequalsa_p) === 'undefined') bequalsa_p = 0;
    if (typeof(aequalsb_p) === 'undefined') aequalsb_p = 0;
    if (typeof(multi_sync_sel_p) === 'undefined') multi_sync_sel_p = 0;
    if (typeof(rev_p) === 'undefined') rev_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = (bequalsa_p << 7) + (aequalsb_p << 6);
    const data0 = (multi_sync_sel_p << 1) + rev_p;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg19'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config19]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "bequalsa_p", bit_value_p = bequalsa_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "aequalsb_p", bit_value_p = aequalsb_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "multi_sync_sel_p", bit_value_p = multi_sync_sel_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "rev_p", bit_value_p = rev_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register20-23 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * Lower 8 bits of the DAC A offset correction. The offset is
 * measured in DAC LSBs. Writing this register causes an
 * autosync to be generated. This loads the values of all four
 * qmc_offset registers (dac_CONFIG20-dac_CONFIG23) into the offset
 * block at the same time. When updating the offset values
 * dac_CONFIG20 should be written last. Programming any of the
 * other three registers will not affect the offset setting.
 * [12:0]: R/W: qmc_offseta
 *
 * Lower 8 bits of the DAC B offset correction. The offset is measured in DAC LSBs.
 * [12:0]: R/W: qmc_offsetb
 *
 * When asserted the SIF interface becomes a 4 pin interface. The
 * ALARM pin is turned into a dedicated output for the reading of data.
 * [2]: R/W: sif4_ena[0]
 *
 * When asserted puts the clock path through DAC A to sleep. This
 * is useful for sleeping individual DACs. Even if the DAC is asleep
 * the clock needs to pass through it for the logic to work.
 * However, if the chip is being put into a power down mode, then
 * all parts of the DAC can be turned off.
 * [1]: R/W: clkpath_sleep_a[0]
 *
 * When asserted puts the clock path through DAC B to sleep.
 * [0]: R/W: clkpath_sleep_b[0]
 */
function dac_set_config20(qmc_offseta_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(qmc_offseta_p) === 'undefined') qmc_offseta_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const qmc_offseta = (qmc_offseta_p & 0x00FF);
    const data = qmc_offseta;

    const addr = DAC_ADDR['reg20'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config20]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "qmc_offseta", bit_value_p = qmc_offseta, bit_width_p = 16, level_p = level2, mode_p = mode_p);
        }
    }
}

function dac_set_config21(qmc_offsetb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(qmc_offsetb_p) === 'undefined') qmc_offsetb_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const qmc_offsetb = (qmc_offsetb_p & 0x00FF);
    const data = qmc_offsetb;

    const addr = DAC_ADDR['reg21'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config21]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "qmc_offsetb", bit_value_p = qmc_offsetb, bit_width_p = 16, level_p = level2, mode_p = mode_p);
        }
    }
}

function dac_set_config22(qmc_offseta_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(qmc_offseta_p) === 'undefined') qmc_offseta_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const qmc_offseta = ((qmc_offseta_p & 0x1F00) >> 8);
    const data1 = (qmc_offseta << 4);
    const data0 = 0;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg22'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config22]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "qmc_offseta", bit_value_p = qmc_offseta, bit_width_p = 5, level_p = level2, mode_p = mode_p);
        }
    }
}

function dac_set_config23(qmc_offsetb_p, sif4_ena_p, clkpath_sleep_a_p, clkpath_sleep_b_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(qmc_offsetb_p) === 'undefined') qmc_offsetb_p = 0;
    if (typeof(sif4_ena_p) === 'undefined') sif4_ena_p = 0;
    if (typeof(clkpath_sleep_a_p) === 'undefined') clkpath_sleep_a_p = 0;
    if (typeof(clkpath_sleep_b_p) === 'undefined') clkpath_sleep_b_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;


    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const qmc_offsetb = ((qmc_offsetb_p & 0x1F00) >> 8);
    const data1 = (qmc_offsetb << 4);
    const data0 = (sif4_ena_p << 2) + (clkpath_sleep_a_p << 1) + clkpath_sleep_b_p;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg23'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config23]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "qmc_offsetb", bit_value_p = qmc_offsetb, bit_width_p = 5, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "sif4_ena_p", bit_value_p = sif4_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "clkpath_sleep_a_p", bit_value_p = clkpath_sleep_a_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "clkpath_sleep_b_p", bit_value_p = clkpath_sleep_b_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register24 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * Turns on the temperature sensor when asserted.
 * [7]: R/W: tsense_ena[0]
 *
 * When asserted the clock input receiver gets put into sleep mode.
 * This also affects the OSTR receiver.
 * [6]: R/W: clkrecv_sleep[0]
 *
 * When asserted DACB is put into sleep mode.
 * [3]: R/W: sleepb[0]
 *
 * When asserted DACA is put into sleep mode.
 * [2]: R/W: sleepa[0]
 *
 */
function dac_set_config24(tsense_ena_p, clkrecv_sleep_p, sleepb_p, sleepa_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(tsense_ena_p) === 'undefined') tsense_ena_p = 1;
    if (typeof(clkrecv_sleep_p) === 'undefined') clkrecv_sleep_p = 0;
    if (typeof(sleepb_p) === 'undefined') sleepb_p = 0;
    if (typeof(sleepa_p) === 'undefined') sleepa_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const reserved = 0x1;
    const data1 = (tsense_ena_p << 7) + (clkrecv_sleep_p << 6);
    const data0 = (sleepb_p << 3) + (sleepa_p << 2) + (reserved << 1) + reserved;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg24'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config24]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "tsense_ena_p", bit_value_p = tsense_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "clkrecv_sleep_p", bit_value_p = clkrecv_sleep_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "sleepb_p", bit_value_p = sleepb_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "sleepa_p", bit_value_p = sleepa_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register25 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * Allows the device to use an external reference or the internal reference.
 *  (0=internal, 1=external)
 * [2]: R/W: extref_ena[0]
 *
 */
function dac_set_config25(extref_ena_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(extref_ena_p) === 'undefined') extref_ena_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = 0;
    const data0 = (extref_ena_p << 2);
    const data = data1 + data0;

    const addr = DAC_ADDR['reg25'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config25]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "extref_ena_p", bit_value_p = extref_ena_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register26 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * [0]: R/W
 *
 */
// function dac_set_config26(level_p,mode_p,verbosity_p)
// {
//     // default function parameter values
//     if (typeof(level_p)==='undefined') level_p = 0;
//     if (typeof(mode_p)==='undefined') mode_p = 0;
//     if (typeof(verbosity_p)==='undefined') verbosity_p = 0;
//     level0 = level_p;
//     level1 = level_p + 1;
//     level2 = level_p + 2;

//     data1 = 0;
//     data0 = 0;
//     data = data1 + data0;

//      addr = DAC_ADDR['reg26'];
//     dac_write_command(addr_p=addr,data_p=data);

//     if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN)
//     {
//       msg = "[dac_set_config26]: Set the register value ";
//       display(msg_p=msg, level_p=level0, mode_p=mode_p);
//     }

//    if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN)
//     {
//      display_register(addr_p=addr,addr_width_p=32,data_p=data,data_width_p=32,level_p=level1,mode_p=mode_p);
//     }

//    // if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN)
//    //  {
//    //    display_bit(bit_name_p="extref_ena_p",bit_value_p=extref_ena_p,bit_width_p=1,level_p=level2,mode_p=mode_p);
//    //  }
// }

/**
 * Set the register27-30 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * Lower 8 bits of the 11-bit DAC A QMC gain word. The upper 3
 * bits are located in the dac_CONFIG30 register. The full 11-bit
 * qmc_gaina(10:0) value is formatted as UNSIGNED with a range
 * of 0 to 1.9990 and a default gain of 1. The implied decimal point
 * for the multiplication is between bits 9 and 10. Writing this
 * register causes an autosync to be generated. This loads the
 * values of all four qmc_phase/gain registers (dac_CONFIG27-
 * dac_CONFIG30) into the QMC block at the same time. When
 * updating the QMC phase and/or gain values dac_CONFIG27
 * should be written last. Programming any of the other three
 * registers will not affect the QMC settings.
 * [10:0]: R/W: qmc_gaina
 *
 * Lower 8 bits of the 11-bit DAC B QMC gain word. The upper 3
 * bits are located in the dac_CONFIG30 register. Refer to dac_CONFIG27
 * for formatting.
 * [10:0]: R/W: qmc_gainb
 *
 * Lower 8-bits of the 10-bit QMC phase word. The upper 2 bits are
 * in the dac_CONFIG30 register. The full 10-bit qmc_phase(9:0) word
 * is formatted as two's complement and scaled to occupy a range
 * of –0.125 to 0.12475 (note this value does not correspond to
 * degrees) and a default phase correction of 0. To accomplish
 * QMC phase correction, this value is multiplied by the current 'Q'
 * sample, then summed into the ‘I’ sample.
 * [9:0]: R/W: qmc_phase
 *
 */
function dac_set_config27(qmc_gaina_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(qmc_gaina_p) === 'undefined') qmc_gaina_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const qmc_gaina = (qmc_gaina_p & 0x00FF);
    const data1 = qmc_gaina;
    const data0 = 0;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg27'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config27]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "qmc_gaina", bit_value_p = qmc_gaina, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

function dac_set_config28(qmc_gainb_p, level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(qmc_gainb_p) === 'undefined') qmc_gainb_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const qmc_gainb = (qmc_gainb_p & 0x00FF);
    const data1 = qmc_gainb;
    const data0 = 0;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg28'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config28]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "qmc_gainb", bit_value_p = qmc_gainb, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

function dac_set_config29(qmc_phase_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(qmc_phase_p) === 'undefined') qmc_phase_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const qmc_phase = (qmc_phase_p & 0x00FF);
    const data1 = qmc_phase;
    const data0 = 0;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg29'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config29]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "qmc_phase", bit_value_p = qmc_phase, bit_width_p = 8, level_p = level2, mode_p = mode_p);
        }
    }
}

function dac_set_config30(qmc_phase_p, qmc_gaina_p, qmc_gainb_p, level_p, mode_p, verbosity_p)

{
    // default function parameter values
    if (typeof(qmc_phase_p) === 'undefined') qmc_phase_p = 0;
    if (typeof(qmc_gaina_p) === 'undefined') qmc_gaina_p = parseInt('10000000000', 2);
    if (typeof(qmc_gainb_p) === 'undefined') qmc_gainb_p = parseInt('10000000000', 2);
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const qmc_phase = ((qmc_phase_p & 0x3F00) >> 8);
    const qmc_gaina = ((qmc_gaina_p & 0x5F00) >> 8);
    const qmc_gainb = ((qmc_gainb_p & 0x5F00) >> 8);

    const data1 = (qmc_phase << 6);
    const data0 = (qmc_gaina << 3) + (qmc_gainb);
    const data = data1 + data0;

    const addr = DAC_ADDR['reg30'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config30]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "qmc_phase", bit_value_p = qmc_phase, bit_width_p = 6, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "qmc_gaina", bit_value_p = qmc_gaina, bit_width_p = 6, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "qmc_gainb", bit_value_p = qmc_gainb, bit_width_p = 6, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 * Set the register31 of the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 * This bit is set to '1' when DATACLK is stopped for 4 clock
 * cycles. Once set, the bit needs to be cleared by writing a '0'.
 * [7]: R: clk_alarm[0]
 *
 * This bit is set to '1' when the clk_alarm is triggered. When set
 * the DAC outputs are forced to mid-level. Once set, the bit needs
 * to be cleared by writing a '0'.
 * [6]: R: tx_off[0]
 * 
 * A hardwired register that contains the version of the chip. (Read Only)
 * [5:0]: R: version[5:0]
 *
 */
function dac_set_config31(clk_alarm_p, tx_off_p, version_p, level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(clk_alarm_p) === 'undefined') clk_alarm_p = 0;
    if (typeof(tx_off_p) === 'undefined') tx_off_p = 0;
    if (typeof(version_p) === 'undefined') version_p = parseInt('010010', 2);
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const data1 = (clk_alarm_p << 7) + (tx_off_p << 6);
    const data0 = version_p;
    const data = data1 + data0;

    const addr = DAC_ADDR['reg31'];
    dac_write_command(addr_p = addr, data_p = data);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_set_config31]: Set the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit(bit_name_p = "clk_alarm_p", bit_value_p = clk_alarm_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "tx_off_p", bit_value_p = tx_off_p, bit_width_p = 1, level_p = level2, mode_p = mode_p);
            display_bit(bit_name_p = "version_p", bit_value_p = version_p, bit_width_p = 6, level_p = level2, mode_p = mode_p);
        }
    }
}

/**
 *  Get the register0 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * When asserted the FIFO is enabled. When the FIFO is bypassed
 *   DACCCLKP/N and DATACLKP/N must be aligned to within t_align.
 *   [6]: R/W: fifo_ena[0]
 *
 * Allows the FRAME input to reset the FIFO write pointer when asserted
 * [5]: R/W: fifo_reset_ena[0]
 *
 * Allows the FRAME or OSTR signal to reset the FIFO read pointer when
 * asserted. This selection is determined by multi_sync_sel in register dac_CONFIG19.
 * [4]: R/W: multi_sync_ena[0]
 *
 * When asserted the ALARM_SDO pin becomes an output. The functionality of
 * this pin is controlled by the dac_CONFIG6 alarm_mask setting.
 * [3]: R/W: alarm_out_ena[0]
 *
 * This bit changes the polarity of the ALARM signal. (0=negative logic, 1=positive logic)
 * [2]: R/W: alarm_pol[0]
 *
 * Controls the function of the mixer block.
 *     Normal : 00
 *     high pass (Fs/2) : 01
 *     Fs/4 : 10
 *     -Fs/4 : 11
 * [1:0]: R/W: mixer_func[1:0]
 */
function dac_get_config0(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;


    const addr = DAC_ADDR['reg0'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config0]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "fifo_ena_p", bit_pos_p = 6, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "fifo_reset_ena_p", bit_pos_p = 5, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "multi_sync_ena_p", bit_pos_p = 4, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "alarm_out_ena_p", bit_pos_p = 3, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "alarm_pol_p", bit_pos_p = 2, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "mixer_func_p", bit_pos_p = 0, bit_width_p = 2, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register1 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * When asserted the QMC offset correction circuitry is enabled.
 * [7]: R/W: qmc_offset_ena[0]
 *
 * When asserted the QMC phase and gain correction circuitry is enabled.
 * [6]: R/W: qmc_correct_ena[0]
 *
 * When asserted FIR0 is activated enabling 2x interpolation.
 * [5]: R/W: fir0_ena[0]
 *
 * When asserted FIR1 is activated enabling 4x interpolation. fir0_ena must be set to '1' for 4x interpolation.
 * [4]: R/W: fir1_ena[0]
 *
 * When asserted enables the data pattern checker operation.
 * [2]: R/W: iotest_ena[0]
 *
 * When asserted the inputs are expected to be in 2's complement format. When
 * de-asserted the input format is expected to be offset-binary.
 * [0]: R/W: twos[0]
 *
 */
function dac_get_config1(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg1'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config1]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "qmc_offset_ena_p", bit_pos_p = 7, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "qmc_correct_ena_p", bit_pos_p = 6, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "fir0_ena_p", bit_pos_p = 5, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "fir1_ena_p", bit_pos_p = 4, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "iotest_ena_p", bit_pos_p = 2, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "twos_p", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register2 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * Serial interface created sync signal. Set to '1' to cause a sync and then clear to '0' to remove it.
 * [5]: R/W: sif_sync[0]
 *
 * When asserted this bit allows the SIF sync to be used. Normal FRAME signals are ignored.
 * [4]: R/W: sif_sync_ena[0]
 *
 * Delays the output to the DACs from 0 to 3 DAC clock cycles.
 * [1:0]: R/W: output_delay[1:0]
 *
 */
function dac_get_config2(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg2'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config2]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "sif_sync_p", bit_post_p = 5, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "sif_sync_ena_p", bit_post_p = 4, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "output_delay_p", bit_post_p = 0, bit_width_p = 2, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register3 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This enables resetting the alarms after 64 good samples with the
 * goal of removing unnecessary errors. For instance, when checking
 * setup/hold through the pattern checker test, there may initially be
 * errors. Setting this bit removes the need for a SIF write to clear the
 * alarm register.
 * [7]: R/W: cnt64_ena[0]
 *
 * This is the default FIFO read pointer position after the FIFO read
 * pointer has been synced. With this value the initial difference
 * between write and read pointers can be controlled. This may be
 * helpful in controlling the delay through the device.
 * [4:2]: R/W: fifo_offset[2:0]
 *
 * When asserted alarms from the FIFO that represent the write and
 * read pointers being 2 away are enabled.
 * [1]: R/W: alarm_2away_ena[0]
 *
 * When asserted alarms from the FIFO that represent the write and
 * read pointers being 1 away are enabled.
 * [0]: R/W: alarm_1away_ena[0]
 */
function dac_get_config3(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg3'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config3]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "cnt64_ena_p", bit_pos_p = 7, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "fifo_offset_p", bit_pos_p = 2, bit_width_p = 2, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "alarm_2away_ena_p", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "alarm_1away_ena_p", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register4 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * Scales the DACA output current in 16 equal steps.
 * (VEXTIO/Rbias)*(coarse_daca/b + 1)
 * [7:4]: R/W: coarse_daca[3:0]
 *
 * Scales the DACB output current in 16 equal steps.
 * [3:0]: R/W: coarse_dacb[3:0]
 *
 */

function dac_get_config4(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg4'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config4]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "coarse_daca_p", bit_pos_p = 4, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "coarse_dacb_p", bit_pos_p = 0, bit_width_p = 4, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register5 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This is the output from the chip temperature sensor. The value
 * of this register in two’s complement format represents the
 * temperature in degrees Celsius. This register must be read
 * with a minimum SCLK period of 1μs. (Read Only)
 * [7:0]: R: tempdata[7:0]
 */
function dac_get_config5(level_p, mode_p, verbosity_p) {

    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg5'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config5]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "tempdata_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register6 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * These bits control the masking of the alarm outputs. This
 * means that the ALARM_SDO pin will not be asserted if the
 * appropriate bit is set. The alarm will still show up in the
 * dac_CONFIG7 bits. (0=not masked, 1= masked).
 * alarm_mask                  Masked Alarm
 *       6                     alarm_from_zerochk
 *       5                     alarm_fifo_collision
 *       4                     reserved
 *       3                     alarm_from_iotest
 *       2                     not used (expansion)
 *       1                     alarm_fifo_2away
 *       0                     alarm_fifo_1away
 * [6:0]: R/W: alarm_mask[6:0] 
 *
 */
function dac_get_config6(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg6'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config6]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "alarm_mask_p", bit_pos_p = 0, bit_width_p = 7, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register7 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This alarm indicates the 8-bit FIFO write pointer address has an all
 * zeros patterns. Due to pointer address being a shift register, this is
 * not a valid address and will cause the write pointer to be stuck until
 * the next sync. This error is typically caused by timing error or
 * improper power start-up sequence. If this alarm is asserted,
 * resynchronization of FIFO is necessary. Refer to the Power-Up
 * Sequence section for more detail.
 * [6]: W: alarm_from_zerochk[0]
 *
 * Alarm occurs when the FIFO pointers over/under run each other.
 * [5]: W: alarm_fifo_collision[0]
 *
 * This is asserted when the input data pattern does not match the
 * pattern in the iotest_pattern registers.
 * [3]: W: alarm_from_iotest[0]
 *
 * Alarm occurs with the read and write pointers of the FIFO are within 2 addresses of each other.
 * [1]: W: alarm_fifo_2away[0]
 *
 * Alarm occurs with the read and write pointers of the FIFO are within 1 address of each other.
 * [0]: W: alarm_fifo1away[0]
 *
 */
function dac_get_config7(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;


    const addr = DAC_ADDR['reg7'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config7]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "alarm_from_zerochk_p", bit_pos_p = 6, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "alarm_fifo_collision_p", bit_pos_p = 5, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "alarm_from_iotest_p", bit_pos_p = 3, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "alarm_fifo_2away_p", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "alarm_fifo1away_p", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register8 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * The values of these bits tell which bit in the byte-wide LVDS bus
 * failed during the pattern checker test.
 * [7:0]: R/W: iotest_results[7:0]
 *
 */
function dac_get_config8(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg8'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config8]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "iotest_results_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register9 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This is dataword0 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern0[7:0]
 *
 */
function dac_get_config9(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg9'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config9]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "iotest_pattern0_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register10 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This is dataword1 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern1[7:0]
 *
 */
function dac_get_config10(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg10'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config10]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "iotest_pattern1_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * get the register11 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This is dataword2 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern2[7:0]
 *
 */
function dac_get_config11(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg11'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config11]: get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "iotest_pattern2_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}


/**
 * Get the register12 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This is dataword3 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern3[7:0]
 *
 */
function dac_get_config12(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;


    const addr = DAC_ADDR['reg12'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config12]: get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "iotest_pattern3_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register13 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This is dataword4 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern4[7:0]
 *
 */
function dac_get_config13(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg13'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {

        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config13]: get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "iotest_pattern4_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register14 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This is dataword5 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern5[7:0]
 *
 */
function dac_get_config14(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;


    const addr = DAC_ADDR['reg14'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config14]: get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "iotest_pattern5_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register15 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This is dataword6 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern6[7:0]
 *
 */
function dac_get_config15(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;


    const addr = DAC_ADDR['reg15'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config15]: get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "iotest_pattern6_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register16 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This is dataword7 in the IO test pattern. It is used with the seven
 * other words to test the input data.
 * [7:0]: R/W: iotest_pattern7[7:0]
 *
 */

function dac_get_config16(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg16'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config16]: get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "iotest_pattern7_p", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register17 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This bit controls the masking of the clock monitor alarm. This
 * means that the ALARM_SDO pin will not be asserted. The alarm
 * will still show up in the clk_alarm bit. (0=not masked, 1= masked).
 * [4]: R/W: clk_alarm_mask[0]
 *
 * This bit control the masking of the transmit enable alarm. This
 * means that the ALARM_SDO pin will not be asserted. The alarm
 * will still show up in the tx_off bit. (0=not masked, 1= masked).
 * [3]: R/W: tx_off_mask[0]
 *
 * When asserted the DATACLK monitor alarm is enabled.
 * [1]: R/W: clk_alarm_ena[0]
 *
 * When asserted a clk_alarm event will automatically disable the
 * AC outputs by setting them to midscale.
 * [0]: R/W: tx_off_ena[0]
 *
 */
function dac_get_config17(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg17'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config17]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "clk_alarm_mask_p", bit_post_p = 4, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "tx_off_mask_p", bit_post_p = 3, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "clk_alarm_ena_p", bit_post_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "tx_off_ena_p", bit_post_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register18 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * When asserted the output to the DACA is complemented. This
 * allows to effectively change the + and – designations of the LVDS data lines.
 * [3]: R/W: daca_complement[0]
 *
 * When asserted the output to the DACB is complemented. This
 * allows to effectively change the + and – designations of the LVDS data lines.
 * [2]: R/W: dacb_complement[0]
 *
 * Enables the syncing of the clock divider using the OSTR signal
 * or the FRAME signal passed through the FIFO. This selection is
 * determined by multi_sync_sel in register dac_CONFIG19. The
 * internal divided-down clocks will be phase aligned after syncing.
 * See Power-Up Sequence section for more detail.
 * [1]: R/W: clkdiv_sync_ena[0]
 *
 */
function dac_get_config18(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg18'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config18]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "daca_complement_p", bit_pos_p = 3, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "dacb_complement_p", bit_pos_p = 2, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "clkdiv_sync_ena_p", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}


/**
 * Get the register19 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * When asserted the DACA data is driven onto DACB.
 * [7]: R/W: bequalsa[0]
 *
 * When asserted the DACB data is driven onto DACA.
 * [6]: R/W: aequalsb[0]
 *
 * Selects the signal source for multiple device and clock divider synchronization.
 *    multi_sync_sel                    sync_source
 *          0                            OSTR
 *          1                            Frame through FIFO handoff
 * [1]: R/W: multi_sync_sel[0]
 *
 * Reverse the input bits for the data word. MSB becomes LSB.
 * [0]: R/W: rev[0]
 *
 */
function dac_get_config19(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg19'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config19]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "bequalsa_p", bit_pos_p = 7, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "aequalsb_p", bit_pos_p = 6, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "multi_sync_sel_p", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "rev_p", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register20 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * [7:0]: qmc_offseta[7:0]
 *
 */
function dac_get_config20(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg20'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config20]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "qmc_offseta[7:0]", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}


/**
 * Get the register21 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * [7:0]: qmc_offsetb[7:0]
 *
 */
function dac_get_config21(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg21'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config21]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "qmc_offsetb[7:0]", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register22 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * [7:3]: qmc_offseta[12:8]
 */
function dac_get_config22(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg22'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config22]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "qmc_offseta[12:8]", bit_pos_p = 3, bit_width_p = 5, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register23 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 *
 * [7:3]: qmc_offsetb[12:8]
 * [2]: sif4_ena[0]
 * [1]: clkpath_sleep_a[0]
 * [0]: clkpath_sleep_b[0]
 */
function dac_get_config23(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg23'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config23]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "qmc_offsetb[12:8]", bit_pos_p = 3, bit_width_p = 5, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "sif4_ena", bit_pos_p = 2, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "clkpath_sleep_a", bit_pos_p = 1, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "clkpath_sleep_b", bit_pos_p = 0, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}




/**
 * Get the register24 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * Turns on the temperature sensor when asserted.
 * [7]: R/W: tsense_ena[0]
 *
 * When asserted the clock input receiver gets put into sleep mode.
 * This also affects the OSTR receiver.
 * [6]: R/W: clkrecv_sleep[0]
 *
 * When asserted DACB is put into sleep mode.
 * [3]: R/W: sleepb[0]
 *
 * When asserted DACA is put into sleep mode.
 * [2]: R/W: sleepa[0]
 *
 */
function dac_get_config24(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg24'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config24]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "tsense_ena_p", bit_pos_p = 7, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "clkrecv_sleep_p", bit_pos_p = 6, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "sleepb_p", bit_pos_p = 3, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "sleepa_p", bit_pos_p = 2, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register25 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * Allows the device to use an external reference or the internal reference.
 *  (0=internal, 1=external)
 * [2]: R/W: extref_ena[0]
 *
 */
function dac_get_config25(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg25'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config25]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "extref_ena_p", bit_pos_p = 2, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register26 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * reserved funcion
 */

/**
 * Get the register27 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * Lower 8 bits of the 11-bit DAC A QMC gain word. The upper 3
 * bits are located in the dac_CONFIG30 register. The full 11-bit
 * qmc_gaina(10:0) value is formatted as UNSIGNED with a range
 * of 0 to 1.9990 and a default gain of 1. The implied decimal point
 * for the multiplication is between bits 9 and 10. Writing this
 * register causes an autosync to be generated. This loads the
 * values of all four qmc_phase/gain registers (dac_CONFIG27-
 * dac_CONFIG30) into the QMC block at the same time. When
 * updating the QMC phase and/or gain values dac_CONFIG27
 * should be written last. Programming any of the other three
 * registers will not affect the QMC settings.
 * [7:0]: R/W: qmc_gaina
 *
 */

function dac_get_config27(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg27'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config27]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "qmc_gaina[7:0]", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register28 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * Lower 8 bits of the 11-bit DAC B QMC gain word. The upper 3
 * bits are located in the dac_CONFIG30 register. Refer to dac_CONFIG27
 * for formatting.
 * [7:0]: R/W: qmc_gainb
 *
 */

function dac_get_config28(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg28'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config28]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "qmc_gainb[7:0]", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register29 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * Lower 8-bits of the 10-bit QMC phase word. The upper 2 bits are
 * in the dac_CONFIG30 register. The full 10-bit qmc_phase(9:0) word
 * is formatted as two's complement and scaled to occupy a range
 * of –0.125 to 0.12475 (note this value does not correspond to
 * degrees) and a default phase correction of 0. To accomplish
 * QMC phase correction, this value is multiplied by the current 'Q'
 * sample, then summed into the ‘I’ sample.
 * [7:0]: R/W: qmc_phase
 *
 */

function dac_get_config29(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg29'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config29]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "qmc_phase[7:0]", bit_pos_p = 0, bit_width_p = 8, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Get the register30 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * 3 upper bits of qmc_gaina.Refer to dac_CONFIG27
 * for formatting.
 * [10:8]: R/W: qmc_gaina
 *
 * 3 upper bits of qmc_gainb. Refer to dac_CONFIG28
 * for formatting.
 * [10:8]: R/W: qmc_gainb
 *
 * 2 upper bits of qmc_phase. Refer to dac_CONFIG29
 * for formatting.
 * [9:8]: R/W: qmc_phase
 */

function dac_get_config30(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg30'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config30]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "qmc_phase[9:8]", bit_pos_p = 6, bit_width_p = 2, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "qmc_gaina[10:8]", bit_pos_p = 3, bit_width_p = 3, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "qmc_gainb[10:8]", bit_pos_p = 0, bit_width_p = 3, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}


/**
 * Get the register31 value from the spi device.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 * @return {number} register value.
 *
 * This bit is set to '1' when DATACLK is stopped for 4 clock
 * cycles. Once set, the bit needs to be cleared by writing a '0'.
 * [7]: R: clk_alarm[0]
 *
 * This bit is set to '1' when the clk_alarm is triggered. When set
 * the DAC outputs are forced to mid-level. Once set, the bit needs
 * to be cleared by writing a '0'.
 * [6]: R: tx_off[0]
 * 
 * A hardwired register that contains the version of the chip. (Read Only)
 * [5:0]: R: version[5:0]
 *
 */
function dac_get_config31(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const addr = DAC_ADDR['reg31'];
    const data = dac_read_command(addr_p = addr);

    if (verbosity_p < 0) {
        // do nothing
    } else {
        if (verbosity_p >= c_DAC_REG_VERBOSITY_MIN) {
            const msg = "[dac_get_config31]: Get the register value ";
            display(msg_p = msg, level_p = level0, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_ADDR_VERBOSITY_MIN) {
            display_register(addr_p = addr, addr_width_p = c_DAC_SPI_ADDR_WIDTH, data_p = data, data_width_p = c_DAC_SPI_DATA_WIDTH, level_p = level1, mode_p = mode_p);
        }

        if (verbosity_p >= c_DAC_BIT_VERBOSITY_MIN) {
            display_bit_from_data(bit_name_p = "clk_alarm_p", bit_pos_p = 7, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "tx_off_p", bit_pos_p = 6, bit_width_p = 1, data_p = data, level_p = level2, mode_p = mode_p);
            display_bit_from_data(bit_name_p = "version_p", bit_pos_p = 0, bit_width_p = 6, data_p = data, level_p = level2, mode_p = mode_p);
        }
    }
    return data;
}

/**
 * Read and Display the configuration of all spi device registers.
 *
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */
function dac_display_all_config(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    dac_get_config0(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config1(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config2(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config3(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config4(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config5(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config6(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config7(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config8(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config9(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config10(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config11(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config12(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config13(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config14(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config15(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config16(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config17(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config18(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config19(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config20(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config21(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config22(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config23(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config24(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config25(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    // dac_get_config26(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config27(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config28(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config29(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config30(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
    dac_get_config31(level_p = level0, mode_p = mode_p, verbosity_p = verbosity_p);
}


/**
 * Default Configuration of the dac3283 (dac) spi device (FMC150 board).
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */
function DAC3283_configure(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;


    const level0 = level_p;
    const level1 = level_p + 1;

    const msg = "DAC3283_configure";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);

    // Enable the SPI on the FPGA board
    dac_spi_enable(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    //---------------------------------------------------------------------
    // write in the SPI_CONF1 register
    //---------------------------------------------------------------------
    const spi_dac_tx_enable = 0;
    // const data = (spi_dac_tx_enable << 0)

    const msg = "Set SPI_CONF1: Disable the DAC TX pin";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    // addr = FPASIM_ADDR_WIREIN['SPI_CONF1'];
    // sendToFPA_debugSetWireIn(addr, data);
    fpasim_set_spi_conf1(spi_dac_tx_en_p = spi_dac_tx_enable, level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    //###############################################################
    // dac_config0
    //###############################################################
    // When asserted the FIFO is enabled. When the FIFO is bypassed
    //   DACCCLKP/N and DATACLKP/N must be aligned to within t_align.
    //   [6]: R/W: fifo_ena[0]
    //
    // Allows the FRAME input to reset the FIFO write pointer when asserted
    // [5]: R/W: fifo_reset_ena[0]
    //
    // Allows the FRAME or OSTR signal to reset the FIFO read pointer when
    // asserted. This selection is determined by multi_sync_sel in register dac_CONFIG19.
    // [4]: R/W: multi_sync_ena[0]
    //
    // When asserted the ALARM_SDO pin becomes an output. The functionality of
    // this pin is controlled by the dac_CONFIG6 alarm_mask setting.
    // [3]: R/W: alarm_out_ena[0]
    //
    // This bit changes the polarity of the ALARM signal. (0=negative logic, 1=positive logic)
    // [2]: R/W: alarm_pol[0]
    //
    // Controls the function of the mixer block.
    //     Normal : 00
    //     high pass (Fs/2) : 01
    //     Fs/4 : 10
    //     -Fs/4 : 11
    // [1:0]: R/W: mixer_func[1:0]

    const fifo_ena = 1; // When asserted the FIFO is enabled. When the FIFO is bypassed DACCCLKP/N and DATACLKP/N must be aligned to within t_align
    const fifo_reset_ena = 1;
    const multi_sync_ena = 1;
    const alarm_out_ena = 0;
    const alarm_pol = 0;
    const mixer_func = parseInt('00', 2); // Controls the function of the mixer block.

    dac_set_config0(
        fifo_ena_p = fifo_ena, fifo_reset_ena_p = fifo_reset_ena,
        multi_sync_ena_p = multi_sync_ena, alarm_out_ena_p = alarm_out_ena,
        alarm_pol_p = alarm_pol, mixer_func_p = mixer_func,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config1
    //###############################################################
    // When asserted the QMC offset correction circuitry is enabled.
    // [7]: R/W: qmc_offset_ena[0]
    //
    // When asserted the QMC phase and gain correction circuitry is enabled.
    // [6]: R/W: qmc_correct_ena[0]
    //
    // When asserted FIR0 is activated enabling 2x interpolation.
    // [5]: R/W: fir0_ena[0]
    //
    // When asserted FIR1 is activated enabling 4x interpolation. fir0_ena must be set to '1' for 4x interpolation.
    // [4]: R/W: fir1_ena[0]
    //
    // When asserted enables the data pattern checker operation.
    // [2]: R/W: iotest_ena[0]
    //
    // When asserted the inputs are expected to be in 2's complement format. When
    // de-asserted the input format is expected to be offset-binary.
    // [0]: R/W: twos[0]
    const qmc_offset_ena = 0;
    const qmc_correct_ena = 0;
    const fir0_ena = 0;
    const fir1_ena = 0;
    const iotest_ena = 0;
    const twos = 1;

    dac_set_config1(qmc_offset_ena_p = qmc_offset_ena, qmc_correct_ena_p = qmc_correct_ena,
        fir0_ena_p = fir0_ena, fir1_ena_p = fir1_ena,
        iotest_ena_p = iotest_ena, twos_p = twos,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    //###############################################################
    // dac_config2
    //###############################################################
    // Serial interface created sync signal. Set to '1' to cause a sync and then clear to '0' to remove it.
    // [5]: R/W: sif_sync[0]
    //
    // When asserted this bit allows the SIF sync to be used. Normal FRAME signals are ignored.
    // [4]: R/W: sif_sync_ena[0]
    //
    // Delays the output to the DACs from 0 to 3 DAC clock cycles.
    // [1:0]: R/W: output_delay[1:0]
    const sif_sync = 0;
    const sif_sync_ena = 0;
    const output_delay = 0;

    dac_set_config2(sif_sync_p = sif_sync, sif_sync_ena_p = sif_sync_ena,
        output_delay_p = output_delay,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config3
    //###############################################################
    // This enables resetting the alarms after 64 good samples with the
    // goal of removing unnecessary errors. For instance, when checking
    // setup/hold through the pattern checker test, there may initially be
    // errors. Setting this bit removes the need for a SIF write to clear the
    // alarm register.
    // [7]: R/W: cnt64_ena[0]
    //
    // This is the default FIFO read pointer position after the FIFO read
    // pointer has been synced. With this value the initial difference
    // between write and read pointers can be controlled. This may be
    // helpful in controlling the delay through the device.
    // [4:2]: R/W: fifo_offset[2:0]
    //
    // When asserted alarms from the FIFO that represent the write and
    // read pointers being 2 away are enabled.
    // [1]: R/W: alarm_2away_ena[0]
    //
    // When asserted alarms from the FIFO that represent the write and
    // read pointers being 1 away are enabled.
    // [0]: R/W: alarm_1away_ena[0]
    const cnt64_ena = 1;
    const fifo_offset = parseInt('100', 2);
    const alarm_2away_ena = 0;
    const alarm_1away_ena = 0;

    dac_set_config3(cnt64_ena_p = cnt64_ena, fifo_offset_p = fifo_offset,
        alarm_2away_ena_p = alarm_2away_ena, alarm_1away_ena_p = alarm_1away_ena,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config4
    //###############################################################
    // Scales the DACA output current in 16 equal steps.
    // (VEXTIO/Rbias)*(coarse_daca/b + 1)
    // [7:4]: R/W: coarse_daca[3:0]
    //
    // Scales the DACB output current in 16 equal steps.
    // [3:0]: R/W: coarse_dacb[3:0]
    const coarse_daca = parseInt('1111', 2);
    const coarse_dacb = parseInt('1111', 2);

    dac_set_config4(
        coarse_daca_p = coarse_daca, coarse_dacb_p = coarse_dacb,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config5 (Read only)
    //###############################################################
    // This is the output from the chip temperature sensor. The value
    // of this register in two’s complement format represents the
    // temperature in degrees Celsius. This register must be read
    // with a minimum SCLK period of 1μs. (Read Only)
    // [7:0]: R: tempdata[7:0]
    // tempdata = 0
    // dac_set_config5(tempdata_p=tempdata)

    //###############################################################
    // dac_config6
    //###############################################################
    // These bits control the masking of the alarm outputs. This
    // means that the ALARM_SDO pin will not be asserted if the
    // appropriate bit is set. The alarm will still show up in the
    // dac_CONFIG7 bits. (0=not masked, 1= masked).
    // alarm_mask                  Masked Alarm
    //       6                     alarm_from_zerochk
    //       5                     alarm_fifo_collision
    //       4                     reserved
    //       3                     alarm_from_iotest
    //       2                     not used (expansion)
    //       1                     alarm_fifo_2away
    //       0                     alarm_fifo_1away
    // [6:0]: R/W: alarm_mask[6:0] 
    const alarm_mask = 0;

    dac_set_config6(
        alarm_mask_p = alarm_mask,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config7
    //###############################################################
    // This alarm indicates the 8-bit FIFO write pointer address has an all
    // zeros patterns. Due to pointer address being a shift register, this is
    // not a valid address and will cause the write pointer to be stuck until
    // the next sync. This error is typically caused by timing error or
    // improper power start-up sequence. If this alarm is asserted,
    // resynchronization of FIFO is necessary. Refer to the Power-Up
    // Sequence section for more detail.
    // [6]: W: alarm_from_zerochk[0]
    //
    // Alarm occurs when the FIFO pointers over/under run each other.
    // [5]: W: alarm_fifo_collision[0]
    //
    // This is asserted when the input data pattern does not match the
    // pattern in the iotest_pattern registers.
    // [3]: W: alarm_from_iotest[0]
    //
    // Alarm occurs with the read and write pointers of the FIFO are within 2 addresses of each other.
    // [1]: W: alarm_fifo_2away[0]
    //
    // Alarm occurs with the read and write pointers of the FIFO are within 1 address of each other.
    // [0]: W: alarm_fifo1away[0]
    const alarm_from_zerochk = 0;
    const alarm_fifo_collision = 0;
    const alarm_from_iotest = 0;
    const alarm_fifo_2away = 0;
    const alarm_fifo1away = 0;

    dac_set_config7(
        alarm_from_zerochk_p = alarm_from_zerochk,
        alarm_fifo_collision_p = alarm_fifo_collision,
        alarm_from_iotest_p = alarm_from_iotest,
        alarm_fifo_2away_p = alarm_fifo_2away,
        alarm_fifo1away_p = alarm_fifo1away,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );


    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config8
    //###############################################################
    // The values of these bits tell which bit in the byte-wide LVDS bus
    // failed during the pattern checker test.
    // [7:0]: R/W: iotest_results[7:0]
    const iotest_results = parseInt('00000000', 2);

    dac_set_config8(
        iotest_results_p = iotest_results,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config9
    //###############################################################
    // This is dataword0 in the IO test pattern. It is used with the seven
    // other words to test the input data.
    // [7:0]: R/W: iotest_pattern0[7:0]
    // iotest_pattern0 = 0x54; // this value should match the pkg_fpasim.vhd/pkg_DAC_PATTERN0
    const iotest_pattern0 = 0x55; // this value should match the pkg_fpasim.vhd/pkg_DAC_PATTERN0

    dac_set_config9(
        iotest_pattern0_p = iotest_pattern0,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config10
    //###############################################################
    // This is dataword1 in the IO test pattern. It is used with the seven
    // other words to test the input data.
    // [7:0]: R/W: iotest_pattern1[7:0]
    const iotest_pattern1 = 0x55; // this value should match the pkg_fpasim.vhd/pkg_DAC_PATTERN1

    dac_set_config10(
        iotest_pattern1_p = iotest_pattern1,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config11
    //###############################################################
    // This is dataword2 in the IO test pattern. It is used with the seven
    // other words to test the input data.
    // [7:0]: R/W: iotest_pattern2[7:0]
    const iotest_pattern2 = 0x01; // this value should match the pkg_fpasim.vhd/pkg_DAC_PATTERN2

    dac_set_config11(
        iotest_pattern2_p = iotest_pattern2,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config12
    //###############################################################
    // This is dataword3 in the IO test pattern. It is used with the seven
    // other words to test the input data.
    // [7:0]: R/W: iotest_pattern3[7:0]
    const iotest_pattern3 = 0x02; // this value should match the pkg_fpasim.vhd/pkg_DAC_PATTERN3

    dac_set_config12(
        iotest_pattern3_p = iotest_pattern3,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config13
    //###############################################################
    // This is dataword4 in the IO test pattern. It is used with the seven
    // other words to test the input data.
    // [7:0]: R/W: iotest_pattern4[7:0]
    const iotest_pattern4 = 0xAA; // this value should match the pkg_fpasim.vhd/pkg_DAC_PATTERN4

    dac_set_config13(
        iotest_pattern4_p = iotest_pattern4,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config14
    //###############################################################
    // This is dataword5 in the IO test pattern. It is used with the seven
    // other words to test the input data.
    // [7:0]: R/W: iotest_pattern5[7:0]
    const iotest_pattern5 = 0xAA; // this value should match the pkg_fpasim.vhd/pkg_DAC_PATTERN5

    dac_set_config14(
        iotest_pattern5_p = iotest_pattern5,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config15
    //###############################################################
    // This is dataword6 in the IO test pattern. It is used with the seven
    // other words to test the input data.
    // [7:0]: R/W: iotest_pattern6[7:0]
    const iotest_pattern6 = 0x03; // this value should match the pkg_fpasim.vhd/pkg_DAC_PATTERN6

    dac_set_config15(
        iotest_pattern6_p = iotest_pattern6,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config16
    //###############################################################
    // This is dataword7 in the IO test pattern. It is used with the seven
    // other words to test the input data.
    // [7:0]: R/W: iotest_pattern7[7:0]
    const iotest_pattern7 = 0x04; // this value should match the pkg_fpasim.vhd/pkg_DAC_PATTERN7

    dac_set_config16(
        iotest_pattern7_p = iotest_pattern7,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config17
    //###############################################################
    // This bit controls the masking of the clock monitor alarm. This
    // means that the ALARM_SDO pin will not be asserted. The alarm
    // will still show up in the clk_alarm bit. (0=not masked, 1= masked).
    // [4]: R/W: clk_alarm_mask[0]
    //
    // This bit control the masking of the transmit enable alarm. This
    // means that the ALARM_SDO pin will not be asserted. The alarm
    // will still show up in the tx_off bit. (0=not masked, 1= masked).
    // [3]: R/W: tx_off_mask[0]
    //
    // When asserted the DATACLK monitor alarm is enabled.
    // [1]: R/W: clk_alarm_ena[0]
    //
    // When asserted a clk_alarm event will automatically disable the
    // AC outputs by setting them to midscale.
    // [0]: R/W: tx_off_ena[0]
    const clk_alarm_mask = 0;
    const tx_off_mask = 0;
    const clk_alarm_ena = 0;
    const tx_off_ena = 0;

    dac_set_config17(
        clk_alarm_mask_p = clk_alarm_mask, tx_off_mask_p = tx_off_mask,
        clk_alarm_ena_p = clk_alarm_ena, tx_off_ena_p = tx_off_ena,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config18
    //###############################################################
    // When asserted the output to the DACA is complemented. This
    // allows to effectively change the + and – designations of the LVDS data lines.
    // [3]: R/W: daca_complement[0]
    //
    // When asserted the output to the DACB is complemented. This
    // allows to effectively change the + and – designations of the LVDS data lines.
    // [2]: R/W: dacb_complement[0]
    //
    // Enables the syncing of the clock divider using the OSTR signal
    // or the FRAME signal passed through the FIFO. This selection is
    // determined by multi_sync_sel in register dac_CONFIG19. The
    // internal divided-down clocks will be phase aligned after syncing.
    // See Power-Up Sequence section for more detail.
    // [1]: R/W: clkdiv_sync_ena[0]
    const daca_complement = 0;
    const dacb_complement = 0;
    const clkdiv_sync_ena = 1;

    dac_set_config18(daca_complement_p = daca_complement,
        dacb_complement_p = dacb_complement,
        clkdiv_sync_ena_p = clkdiv_sync_ena,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config19
    //###############################################################
    // When asserted the DACA data is driven onto DACB.
    // [7]: R/W: bequalsa[0]
    //
    // When asserted the DACB data is driven onto DACA.
    // [6]: R/W: aequalsb[0]
    //
    // Selects the signal source for multiple device and clock divider synchronization.
    //    multi_sync_sel                    sync_source
    //          0                            OSTR
    //          1                            Frame through FIFO handoff
    // [1]: R/W: multi_sync_sel[0]
    //
    // Reverse the input bits for the data word. MSB becomes LSB.
    // [0]: R/W: rev[0]
    const bequalsa = 0;
    const aequalsb = 0;
    const multi_sync_sel = 1;
    const rev = 0;

    dac_set_config19(bequalsa_p = bequalsa, aequalsb_p = aequalsb,
        multi_sync_sel_p = multi_sync_sel, rev_p = rev,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config20 - 23
    //###############################################################
    // Lower 8 bits of the DAC A offset correction. The offset is
    // measured in DAC LSBs. Writing this register causes an
    // autosync to be generated. This loads the values of all four
    // qmc_offset registers (dac_CONFIG20-dac_CONFIG23) into the offset
    // block at the same time. When updating the offset values
    // dac_CONFIG20 should be written last. Programming any of the
    // other three registers will not affect the offset setting.
    // [12:0]: R/W: qmc_offseta
    //
    // Lower 8 bits of the DAC B offset correction. The offset is measured in DAC LSBs.
    // [12:0]: R/W: qmc_offsetb
    //
    // When asserted the SIF interface becomes a 4 pin interface. The
    // ALARM pin is turned into a dedicated output for the reading of data.
    // [2]: R/W: sif4_ena[0]
    //
    // When asserted puts the clock path through DAC A to sleep. This
    // is useful for sleeping individual DACs. Even if the DAC is asleep
    // the clock needs to pass through it for the logic to work.
    // However, if the chip is being put into a power down mode, then
    // all parts of the DAC can be turned off.
    // [1]: R/W: clkpath_sleep_a[0]
    //
    // When asserted puts the clock path through DAC B to sleep.
    // [0]: R/W: clkpath_sleep_b[0]
    const qmc_offseta = 0;
    const qmc_offsetb = 0;
    const sif4_ena = 1;
    const clkpath_sleep_a = 0;
    const clkpath_sleep_b = 0;

    dac_set_config21(
        qmc_offsetb_p = qmc_offsetb,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    dac_set_config22(
        qmc_offseta_p = qmc_offseta,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    dac_set_config23(
        qmc_offsetb_p = qmc_offsetb, sif4_ena_p = sif4_ena,
        clkpath_sleep_a_p = clkpath_sleep_a, clkpath_sleep_b_p = clkpath_sleep_b,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    
    dac_set_config20(
        qmc_offseta_p = qmc_offseta,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    //###############################################################
    // dac_config24
    //###############################################################
    // Turns on the temperature sensor when asserted.
    // [7]: R/W: tsense_ena[0]
    //
    // When asserted the clock input receiver gets put into sleep mode.
    // This also affects the OSTR receiver.
    // [6]: R/W: clkrecv_sleep[0]
    //
    // When asserted DACB is put into sleep mode.
    // [3]: R/W: sleepb[0]
    //
    // When asserted DACA is put into sleep mode.
    // [2]: R/W: sleepa[0]
    const tsense_ena = 1;
    const clkrecv_sleep = 0;
    const sleepb = 0;
    const sleepa = 0;


    dac_set_config24(tsense_ena_p = tsense_ena, clkrecv_sleep_p = clkrecv_sleep,
        sleepb_p = sleepb, sleepa_p = sleepa,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config25
    //###############################################################
    // Allows the device to use an external reference or the internal reference.
    //  (0=internal, 1=external)
    // [2]: R/W: extref_ena[0]
    const extref_ena = 0;


    dac_set_config25(
        extref_ena_p = extref_ena,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //###############################################################
    // dac_config26
    //###############################################################
    // [0]: R/W

    // dac_set_config26(level_p=level1,mode_p=mode_p,verbosity_p=verbosity_p);


    //###############################################################
    // dac_config27 - 30
    //###############################################################
    // Lower 8 bits of the 11-bit DAC A QMC gain word. The upper 3
    // bits are located in the dac_CONFIG30 register. The full 11-bit
    // qmc_gaina(10:0) value is formatted as UNSIGNED with a range
    // of 0 to 1.9990 and a default gain of 1. The implied decimal point
    // for the multiplication is between bits 9 and 10. Writing this
    // register causes an autosync to be generated. This loads the
    // values of all four qmc_phase/gain registers (dac_CONFIG27-
    // dac_CONFIG30) into the QMC block at the same time. When
    // updating the QMC phase and/or gain values dac_CONFIG27
    // should be written last. Programming any of the other three
    // registers will not affect the QMC settings.
    // [10:0]: R/W: qmc_gaina
    //
    // Lower 8 bits of the 11-bit DAC B QMC gain word. The upper 3
    // bits are located in the dac_CONFIG30 register. Refer to dac_CONFIG27
    // for formatting.
    // [10:0]: R/W: qmc_gainb
    //
    // Lower 8-bits of the 10-bit QMC phase word. The upper 2 bits are
    // in the dac_CONFIG30 register. The full 10-bit qmc_phase(9:0) word
    // is formatted as two's complement and scaled to occupy a range
    // of –0.125 to 0.12475 (note this value does not correspond to
    // degrees) and a default phase correction of 0. To accomplish
    // QMC phase correction, this value is multiplied by the current 'Q'
    // sample, then summed into the ‘I’ sample.
    // [9:0]: R/W: qmc_phase
    const qmc_gaina = parseInt('10000000000', 2);
    const qmc_gainb = parseInt('10000000000', 2);
    const qmc_phase = parseInt('000000000', 2);
    // const qmc_gaina = parseInt('01111111111', 2);
    // const qmc_gainb = parseInt('01111111111', 2);
    // const qmc_phase = parseInt('000000000', 2);

    dac_set_config28(
        qmc_gainb_p = qmc_gainb,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    dac_set_config29(
        qmc_phase_p = qmc_phase,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    dac_set_config30(
        qmc_phase_p = qmc_phase,
        qmc_gaina_p = qmc_gaina,
        qmc_gainb_p = qmc_gainb,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    dac_set_config27(
        qmc_gaina_p = qmc_gaina,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    //###############################################################
    // dac_config31
    //###############################################################
    // This bit is set to '1' when DATACLK is stopped for 4 clock
    // cycles. Once set, the bit needs to be cleared by writing a '0'.
    // [7]: R: clk_alarm[0]
    //
    // This bit is set to '1' when the clk_alarm is triggered. When set
    // the DAC outputs are forced to mid-level. Once set, the bit needs
    // to be cleared by writing a '0'.
    // [6]: R: tx_off[0]
    // 
    // A hardwired register that contains the version of the chip. (Read Only)
    // [5:0]: R: version[5:0]
    const clk_alarm = 0;
    const tx_off = 1;
    const version = parseInt('10010', 2);

    dac_set_config31(
        clk_alarm_p = clk_alarm,
        tx_off_p = tx_off,
        version_p = version,
        level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    //---------------------------------------------------------------------
    // write in the SPI_CONF1 register
    //---------------------------------------------------------------------
    const spi_dac_tx_enable = 1;
    // const data = (spi_dac_tx_enable << 0)

    const msg = "Set SPI_CONF1: Enable the DAC TX pin";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    // addr = FPASIM_ADDR_WIREIN['SPI_CONF1'];
    // sendToFPA_debugSetWireIn(addr, data);

    fpasim_set_spi_conf1(spi_dac_tx_en_p = spi_dac_tx_enable, level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
}

/**
 * Enable the dac pattern checker of the dac3283 (dac) spi device (FMC150 board).
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */

// function DAC3283_enable_pattern(level_p, mode_p, verbosity_p) {
//     // default function parameter values
//     if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;
//     if (typeof(level_p) === 'undefined') level_p = 0;
//     if (typeof(mode_p) === 'undefined') mode_p = 0;


//     const level0 = level_p;
//     const level1 = level_p + 1;

//     const msg = "[DAC3283_enable_pattern]";
//     display(msg_p = msg, level_p = level0, mode_p = mode_p);

//     // Enable the SPI on the FPGA board
//     const msg = "Enable the FPASim spi bridge";
//     display(msg_p = msg, level_p = level1, mode_p = mode_p);
//     dac_spi_enable(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

//     const msg = "";
//     display(msg_p = msg, level_p = level1, mode_p = mode_p);


//     //###############################################################
//     // dac_config1
//     //###############################################################
//     // When asserted the QMC offset correction circuitry is enabled.
//     // [7]: R/W: qmc_offset_ena[0]
//     //
//     // When asserted the QMC phase and gain correction circuitry is enabled.
//     // [6]: R/W: qmc_correct_ena[0]
//     //
//     // When asserted FIR0 is activated enabling 2x interpolation.
//     // [5]: R/W: fir0_ena[0]
//     //
//     // When asserted FIR1 is activated enabling 4x interpolation. fir0_ena must be set to '1' for 4x interpolation.
//     // [4]: R/W: fir1_ena[0]
//     //
//     // When asserted enables the data pattern checker operation.
//     // [2]: R/W: iotest_ena[0]
//     //
//     // When asserted the inputs are expected to be in 2's complement format. When
//     // de-asserted the input format is expected to be offset-binary.
//     // [0]: R/W: twos[0]
//     const qmc_offset_ena = 0;
//     const qmc_correct_ena = 0;
//     const fir0_ena = 0;
//     const fir1_ena = 0;
//     const iotest_ena = 1;
//     const twos = 1;

//     const msg = "Enable the spi dac pattern checker";
//     display(msg_p = msg, level_p = level1, mode_p = mode_p);

//     dac_set_config1(qmc_offset_ena_p = qmc_offset_ena, qmc_correct_ena_p = qmc_correct_ena,
//         fir0_ena_p = fir0_ena, fir1_ena_p = fir1_ena,
//         iotest_ena_p = iotest_ena, twos_p = twos,
//         level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
//     );

//     const msg = "";
//     display(msg_p = msg, level_p = level1, mode_p = mode_p);



// }

/**
 * Enable the dac pattern checker of the dac3283 (dac) spi device (FMC150 board).
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */

// function DAC3283_disable_pattern(level_p, mode_p, verbosity_p) {
//     // default function parameter values
//     if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;
//     if (typeof(level_p) === 'undefined') level_p = 0;
//     if (typeof(mode_p) === 'undefined') mode_p = 0;


//     const level0 = level_p;
//     const level1 = level_p + 1;

//     const msg = "[DAC3283_disable_pattern]";
//     display(msg_p = msg, level_p = level0, mode_p = mode_p);


//     //###############################################################
//     // dac_config1
//     //###############################################################
//     // When asserted the QMC offset correction circuitry is enabled.
//     // [7]: R/W: qmc_offset_ena[0]
//     //
//     // When asserted the QMC phase and gain correction circuitry is enabled.
//     // [6]: R/W: qmc_correct_ena[0]
//     //
//     // When asserted FIR0 is activated enabling 2x interpolation.
//     // [5]: R/W: fir0_ena[0]
//     //
//     // When asserted FIR1 is activated enabling 4x interpolation. fir0_ena must be set to '1' for 4x interpolation.
//     // [4]: R/W: fir1_ena[0]
//     //
//     // When asserted enables the data pattern checker operation.
//     // [2]: R/W: iotest_ena[0]
//     //
//     // When asserted the inputs are expected to be in 2's complement format. When
//     // de-asserted the input format is expected to be offset-binary.
//     // [0]: R/W: twos[0]
//     const qmc_offset_ena = 0;
//     const qmc_correct_ena = 0;
//     const fir0_ena = 0;
//     const fir1_ena = 0;
//     const iotest_ena = 0;
//     const twos = 1;

//     const msg = "Disable the spi dac pattern checker";
//     display(msg_p = msg, level_p = level1, mode_p = mode_p);

//     dac_set_config1(qmc_offset_ena_p = qmc_offset_ena, qmc_correct_ena_p = qmc_correct_ena,
//         fir0_ena_p = fir0_ena, fir1_ena_p = fir1_ena,
//         iotest_ena_p = iotest_ena, twos_p = twos,
//         level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p
//     );

//     const msg = "";
//     display(msg_p = msg, level_p = level1, mode_p = mode_p);



// }

/**
 * Monitor the dacclk.
 * @param {number} level_p - level of indentation at the beginning.
 * @param {number} mode_p - define the print output.
 * @param {number} verbosity_p - level of verbosity.
 *
 */
function DAC3283_get_dacclk_errors(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;


    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    const msg = "[DAC3283_get_dacclk_errors]";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    // Enable the SPI on the FPGA board
    const msg = "Enable the FPASim SPI bridge";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    dac_spi_enable(level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);

    const msg = "";
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    //###############################################################
    // dac_config17
    //###############################################################
    // This bit controls the masking of the clock monitor alarm. This
    // means that the ALARM_SDO pin will not be asserted. The alarm
    // will still show up in the clk_alarm bit. (0=not masked, 1= masked).
    // [4]: R/W: clk_alarm_mask[0]
    //
    // This bit control the masking of the transmit enable alarm. This
    // means that the ALARM_SDO pin will not be asserted. The alarm
    // will still show up in the tx_off bit. (0=not masked, 1= masked).
    // [3]: R/W: tx_off_mask[0]
    //
    // When asserted the DATACLK monitor alarm is enabled.
    // [1]: R/W: clk_alarm_ena[0]
    //
    // When asserted a clk_alarm event will automatically disable the
    // AC outputs by setting them to midscale.
    // [0]: R/W: tx_off_ena[0]
    const clk_alarm_mask = 1;
    const tx_off_mask = 1;
    const clk_alarm_ena = 0;
    const tx_off_ena = 0;

    const msg = "(clk_alarm,tx_off) bits: are masked and disabled";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    dac_set_config17(
        clk_alarm_mask_p = clk_alarm_mask, tx_off_mask_p = tx_off_mask,
        clk_alarm_ena_p = clk_alarm_ena, tx_off_ena_p = tx_off_ena,
        level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    //###############################################################
    // dac_config17
    //###############################################################
    // This bit controls the masking of the clock monitor alarm. This
    // means that the ALARM_SDO pin will not be asserted. The alarm
    // will still show up in the clk_alarm bit. (0=not masked, 1= masked).
    // [4]: R/W: clk_alarm_mask[0]
    //
    // This bit control the masking of the transmit enable alarm. This
    // means that the ALARM_SDO pin will not be asserted. The alarm
    // will still show up in the tx_off bit. (0=not masked, 1= masked).
    // [3]: R/W: tx_off_mask[0]
    //
    // When asserted the DATACLK monitor alarm is enabled.
    // [1]: R/W: clk_alarm_ena[0]
    //
    // When asserted a clk_alarm event will automatically disable the
    // AC outputs by setting them to midscale.
    // [0]: R/W: tx_off_ena[0]
    const clk_alarm_mask = 1;
    const tx_off_mask = 1;
    const clk_alarm_ena = 1;
    const tx_off_ena = 1;

    const msg = "(clk_alarm,tx_off) bits: masked and enabled";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    dac_set_config17(
        clk_alarm_mask_p = clk_alarm_mask, tx_off_mask_p = tx_off_mask,
        clk_alarm_ena_p = clk_alarm_ena, tx_off_ena_p = tx_off_ena,
        level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    //###############################################################
    // dac_config17
    //###############################################################
    // This bit controls the masking of the clock monitor alarm. This
    // means that the ALARM_SDO pin will not be asserted. The alarm
    // will still show up in the clk_alarm bit. (0=not masked, 1= masked).
    // [4]: R/W: clk_alarm_mask[0]
    //
    // This bit control the masking of the transmit enable alarm. This
    // means that the ALARM_SDO pin will not be asserted. The alarm
    // will still show up in the tx_off bit. (0=not masked, 1= masked).
    // [3]: R/W: tx_off_mask[0]
    //
    // When asserted the DATACLK monitor alarm is enabled.
    // [1]: R/W: clk_alarm_ena[0]
    //
    // When asserted a clk_alarm event will automatically disable the
    // AC outputs by setting them to midscale.
    // [0]: R/W: tx_off_ena[0]
    const clk_alarm_mask = 0;
    const tx_off_mask = 0;
    const clk_alarm_ena = 1;
    const tx_off_ena = 1;

    const msg = "(clk_alarm,tx_off) bits: unmasked and enabled";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    dac_set_config17(
        clk_alarm_mask_p = clk_alarm_mask, tx_off_mask_p = tx_off_mask,
        clk_alarm_ena_p = clk_alarm_ena, tx_off_ena_p = tx_off_ena,
        level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p
    );

    const msg = "";
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    /*
     * Tempo
     *
     */
    const msg = "wait for 10ms";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    waitMs(10);
    const msg = "";
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    /**
     * Get the register31 value from the spi device.
     *
     * @param {number} level_p - level of indentation at the beginning.
     * @param {number} mode_p - define the print output.
     * @param {number} verbosity_p - level of verbosity.
     * @return {number} register value.
     *
     * This bit is set to '1' when DATACLK is stopped for 4 clock
     * cycles. Once set, the bit needs to be cleared by writing a '0'.
     * [7]: R: clk_alarm[0]
     *
     * This bit is set to '1' when the clk_alarm is triggered. When set
     * the DAC outputs are forced to mid-level. Once set, the bit needs
     * to be cleared by writing a '0'.
     * [6]: R: tx_off[0]
     * 
     * A hardwired register that contains the version of the chip. (Read Only)
     * [5:0]: R: version[5:0]
     *
     */
    // msg = "check clk_alarm and tx_off";
    // display_title(msg_p = msg, level_p = level1, mode_p = mode_p);

    const data = dac_get_config31(level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    const clk_alarm = (data >> 7) & 0x1;
    const tx_off = (data >> 7) & 0x1;

    if ((clk_alarm == 1) && (tx_off == 1)) {

        const msg = "[KO]: clk_alarm=1 and tx_off=1";
        display(msg_p = msg, level_p = level1, mode_p = mode_p);
        return 1;
    } else {
        const msg = "[OK]: clk_alarm=0 and tx_off=0";
        display(msg_p = msg, level_p = level1, mode_p = mode_p);
        return 0;
    }

}