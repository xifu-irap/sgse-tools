// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   fpasim_test_check_tmtc_link.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//   This test does the following tests:
//      . test_wire: test the FPASim registers
//          . For the main registers: write -> read back -> check
//      . test_ram_conf: test the FPASim RAM configuration
//          . Write -> read back -> check
//      . test_recording: test the link adc device -> FPASim
//          . configure the adc device into a pattern generator
//          . records ADC samples
//          . compare the recorded ADC samples with the generated one.
//      . test_dac_pattern: test the link FPASim -> dac device.
//          . configure the dac device into a pattern checker.
//          . configure the FPASim into a pattern generator.
//          . compare the generated DAC samples with the checked one.
//
//   Note:
//      . Tested with javascript
//
// -------------------------------------------------------------------------------------------------------------

// import javascript
include("./fpasim/utils_tools.dscript");
include("./fpasim/fpasim_tools.dscript");

/**
 * Configure the registers of the FPAsim function with default values
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function configure_fpasim(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;
    /*
     ***************************************************************************
     * Configure the FPASIM functions
     ***************************************************************************
     */

    const msg = "Configure the fpasim function";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);


    // set the register: MUX_SQ_FB_DELAY
    const mux_sq_fb_delay = 0x0;
    const msg = "Set register: MUX_SQ_FB_DELAY";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureMuxDelay(mux_sq_fb_delay);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);



    // set the register: AMP_SQ_OF_DELAY
    const amp_sq_of_delay = 0x0;
    const msg = "Set register: AMP_SQ_OF_DELAY";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureAmpDelay(amp_sq_of_delay);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    // set the register: ERROR_DELAY
    const error_delay = 0x0;
    const msg = "Set register: ERROR_DELAY";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureErrorDelay(error_delay);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    // set the register: RA_DELAY
    const ra_delay = 0x0;
    const msg = "Set register: RA_DELAY";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureRaDelay(ra_delay);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    // set the register: TES_CONF (Mandatory)
    nbPixels = 34;
    nbSamplesPerPixel = 40;
    totalFrameSize = nbPixels * nbSamplesPerPixel;

    nbPixels = nbPixels - 1; // add -1 because we start from 0
    nbSamplesPerPixel = nbSamplesPerPixel - 1; // add -1 because we start from 0
    totalFrameSize = totalFrameSize - 1; // add -1 because we start from 0

    const msg = "Set register: TES_CONF";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureTES_conf(nbPixels = nbPixels, nbSamplesPerPixel = nbSamplesPerPixel, totalFrameSize = totalFrameSize);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    // set the register: CONF0
    const inter_squid_gain = 0xFF;
    const msg = "Set register: CONF0";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    const data = fpasim_build_conf0(inter_squid_gain_p = inter_squid_gain);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'CONF0', data_p = data, level_p = level1, mode_p = mode_p)

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
}

/**
 * Test the wire register:
 *   For each defined wire register, the steps are:
 *      . write the register (wire_in)
 *      . read the register (wire_out)
 *      . check if the written data and the read data are equal.
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function test_wire(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    //
    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    cnt_error_wire = 0

    /*
     ***************************************************************************
     * check: CTRL
     ***************************************************************************
     */
    const data0 = 0xFFFF0000;

    const msg = "Set register: CTRL";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureControl(data0);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "CTRL", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: Ctrl";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * check: MAKE_PULSE
     ***************************************************************************
     */
    const pixel_all = 0x0;
    const pixelId = 0x1;
    const timeShift = 0x2;
    const pulseheight = 0x3;

    const msg = "Set register: MAKE_PULSE";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_makePulse(pixelId = pixelId, timeShift = timeShift, pulseHeigth = pulseheight);
    // build the data to send
    const data0 = fpasim_build_make_pulse(pixel_all_p = pixel_all, pixel_id_p = pixelId, time_shift_p = timeShift, pulse_height_p = pulseheight);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "MAKE_PULSE", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: Make_Pulse";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    /*
     ***************************************************************************
     * check: MUX_SQ_FB_DELAY
     ***************************************************************************
     */

    const mux_sq_fb_delay = 0x5;

    const msg = "Set register: MUX_SQ_FB_DELAY";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureMuxDelay(mux_sq_fb_delay);
    // build the data to send
    const data0 = fpasim_build_mux_sq_fb_delay(mux_sq_fb_delay_p = mux_sq_fb_delay);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "MUX_SQ_FB_DELAY", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: MUX_SQ_FB_DELAY";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * check: AMP_SQ_OF_DELAY
     ***************************************************************************
     */

    const amp_sq_of_delay = 0x6;

    const msg = "Set register: AMP_SQ_OF_DELAY";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureAmpDelay(amp_sq_of_delay);
    // build the data to send
    const data0 = fpasim_build_amp_sq_of_delay(amp_sq_of_delay_p = amp_sq_of_delay);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "AMP_SQ_OF_DELAY", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: AMP_SQ_OF_DELAY";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    /*
     ***************************************************************************
     * check: ERROR_DELAY
     ***************************************************************************
     */

    const error_delay = 0x7;

    const msg = "Set register: ERROR_DELAY";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureErrorDelay(error_delay);
    // build the data to send
    const data0 = fpasim_build_error_delay(error_delay_p = error_delay);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "ERROR_DELAY", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: ERROR_DELAY";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * check: RA_DELAY
     ***************************************************************************
     */
    const ra_delay = 0x8;
    // build the data to send
    const data0 = fpasim_build_ra_delay(ra_delay_p = ra_delay);

    const msg = "Set register: RA_DELAY";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureRaDelay(ra_delay);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "RA_DELAY", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: RA_DELAY";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * check: TES_CONF
     ***************************************************************************
     */
    const nbPixels = 34 - 1; // add -1 because we start from 0
    const nbSamplesPerPixel = 40 - 1; // add -1 because we start from 0
    const totalFrameSize = nbPixels * nbSamplesPerPixel - 1; // add -1 because we start from 0

    const msg = "Set register: TES_CONF";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureTES_conf(nbPixels = nbPixels, nbSamplesPerPixel = nbSamplesPerPixel, totalFrameSize = totalFrameSize);
    // build the data to send
    const data0 = fpasim_build_tes_conf(nb_pixel_by_frame_p = nbPixels, nb_sample_by_pixel_p = nbSamplesPerPixel, nb_samples_by_frame_p = totalFrameSize);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "TES_CONF", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: TES_CONF";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * check: CONF0
     ***************************************************************************
     */

    const inter_squid_gain = 0xFF;
    // build the data to send
    const data0 = fpasim_build_conf0(inter_squid_gain_p = inter_squid_gain);

    const msg = "Set register: CONF0";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'CONF0', data_p = data0, level_p = level2, mode_p = mode_p);

    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "CONF0", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: CONF0";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    /*
     ***************************************************************************
     * check: REC_CONF0
     ***************************************************************************
     */
    const rec_adc_nb_word_32b = 0x0000ABCD;
    data0 = fpasim_build_rec_conf0(rec_adc_nb_word_32b_p = rec_adc_nb_word_32b);

    const msg = "Set register: REC_CONF0";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    // build the data to send
    fpasim_set_debug_wirein_by_name(reg_name_p = 'REC_CONF0', data_p = data0, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "REC_CONF0", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: REC_CONF0";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * check: REC_CTRL
     ***************************************************************************
     */

    const mask_en = 0xFFFFFFFE // don't touch the en bit
    const rec_ctrl_data = 0x9ABCEF0 & mask_en;
    const data0 = rec_ctrl_data;

    const msg = "Set register: REC_CTRL";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    // build the data to send
    fpasim_set_debug_wirein_by_name(reg_name_p = 'REC_CTRL', data_p = data0, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "REC_CTRL", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: REC_CTRL";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    /*
     ***************************************************************************
     * check: SPI_CTRL
     ***************************************************************************
     */
    const en = 0;
    const rst = 1;
    // build the data to send
    const data0 = fpasim_build_spi_ctrl(rst_p = rst, en_p = en);

    const msg = "Set register: SPI_CTRL";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'SPI_CTRL', data_p = data0, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "SPI_CTRL", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: SPI_CTRL";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * check: SPI_CONF0
     ***************************************************************************
     */
    const spi_mode = 0;
    const spi_id = 2;
    const data0 = fpasim_build_spi_conf0(spi_id_p = spi_id, spi_mode_p = spi_mode)

    const msg = "Set register: SPI_CONF0";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'SPI_CONF0', data_p = data0, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "SPI_CONF0", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: SPI_CONF0";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    /*
     ***************************************************************************
     * check: SPI_CONF1
     ***************************************************************************
     */
    const mask = 0xFFFFFFFE; // protect the spi_dac_tx_en
    const data0 = 0xABCDEFA & mask;

    const msg = "Set register: SPI_CONF1";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    // data0 = fpasim_build_spi_conf1(spi_dac_tx_en_p=spi_dac_tx_en)
    fpasim_set_debug_wirein_by_name(reg_name_p = 'SPI_CONF1', data_p = data0, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);

    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "SPI_CONF1", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: SPI_CONF1";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * check: SPI_WR_DATA
     ***************************************************************************
     */
    const spi_data = 0x9ABDCEF1;
    // build the data to send
    const data0 = fpasim_build_spi_wr_data(data_p = spi_data);

    const msg = "Set register: SPI_WR_DATA";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'SPI_WR_DATA', data_p = data0, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "SPI_WR_DATA", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: SPI_WR_DATA";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    /*
     ***************************************************************************
     * check: DEBUG_CTRL
     ***************************************************************************
     */
    const dac_en_pattern = 0;
    const rst_status = 0;
    const debug_pulse = 1;
    // build the data to send
    const data0 = fpasim_build_debug_ctrl(dac_en_pattern_p = dac_en_pattern, rst_status_p = rst_status, debug_pulse_p = debug_pulse);

    const msg = "Set register: DEBUG_CTRL";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = 'DEBUG_CTRL', data_p = data0, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "DEBUG_CTRL", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: DEBUG_CTRL";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * check: ERROR_SEL
     ***************************************************************************
     */
    const sel_error = 2;
    // build the data to send
    const data0 = fpasim_build_error_sel(sel_error_p = sel_error);

    const msg = "Set register: ERROR_SEL";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    fpasim_set_debug_wirein_by_name(reg_name_p = 'ERROR_SEL', data_p = data0, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // read the register
    const data1 = fpasim_get_wireout_by_name(reg_name_p = "ERROR_SEL", level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    // check the read data Vs the written data
    const msg = "Check register: ERROR_SEL";
    error = check_equal(value0_p = data0, value1_p = data1, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    return cnt_error_wire

}

/**
 * Test the adc recording.
 *   The steps are:
 *     . configure the ADC devices in order to generate a pre-defined pattern
 *     . configure the FPASIM in order to records few samples
 *     . print the recorded samples
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function test_recording(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // count the number of error message
    cnt_error_rec = 0;

    /*
     ***************************************************************************
     * reset the fpasim function
     ***************************************************************************
     */
    const msg = "Reset the FPASim function";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_reset(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    /*
     ***************************************************************************
     * Configure the FPGA sim registers
     ***************************************************************************
     */
    configure_fpasim(level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p);

    /*
     ***************************************************************************
     * Configure the ADC to generate a pre-defined pattern
     ***************************************************************************
     */
    const msg = "Configure the ADC pattern generator (pre-defined pattern)";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
    // configure the adc to automatically generate pattern.
    adc_generate_pattern0(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    /*
     ***************************************************************************
     Enable the fpasim function
      ***************************************************************************
      */
    const rst = 0;
    const en = 1;
    const data = fpasim_build_ctrl(rst_p = rst, en_p = en);
    const msg = "Enable the FPASim function";
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);
    sendToFPA_configureControl(data);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    /*
     ***************************************************************************
     * Set the number of words to record
     ***************************************************************************
     */

    // Set the number of 32 bit-words to record.
    const rec_adc_nb_word_32b = 4092 - 1;
    const msg = "Configure the number of ADC samples to record: " + rec_adc_nb_word_32b.toString(10);
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);
    const data = fpasim_build_rec_conf0(rec_adc_nb_word_32b_p = rec_adc_nb_word_32b);
    fpasim_set_debug_wirein_by_name(reg_name_p = "REC_CONF0", data_p = data, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * Enable the recording
     ***************************************************************************
     */
    const en = 1;
    const data = fpasim_build_rec_ctrl(en_p = en);
    const msg = "Enable the FPASim recording";
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);
    fpasim_set_debug_wirein_by_name(reg_name_p = "REC_CTRL", data_p = data, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    /*
     ***************************************************************************
     * Set a tempo
     ***************************************************************************
     */
    const tempo = 2000;
    const msg = "wait for " + tempo.toString(10) + " ms";
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);
    waitMs(tempo);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    /*
     ***************************************************************************
     * Get ADC samples
     * Get the number of recording ADC samples
     ***************************************************************************
     */
    const msg = "Get the ADC samples (adc0 and adc1)";
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);

    getLatestValue("FPA_adc_mux_squid_feedback,FPA_adc_amp_squid_offset_correction,FPA_rec_adc_size");


    const msg = "Read FPA_adc_mux_squid_feedback tab";
    display(msg_p = msg, level_p = level2, mode_p = mode_p);
    print(FPA_adc_mux_squid_feedback);

    const msg = "";
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    const msg = "Read FPA_adc_amp_squid_offset_correction";
    display(msg_p = msg, level_p = level2, mode_p = mode_p);
    print(FPA_adc_amp_squid_offset_correction);

    const msg = "";
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    const msg = "Number of read data (pipeout access): FPA_rec_adc_size=" + FPA_rec_adc_size.toString(10);
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    const msg = "";
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    /*
     ***************************************************************************
     * Auto-check the recording adc data
     *   if the adc device generates the pre-defined pattern0 then
     *      . adc0 (=FPA_adc_mux_squid_feedback) generates the following alternates values
     *          . "01010101010101" (14 bits) -> "0001010101010101" (16 bits) <-> 5461 at the software side
     *          . "10101010101010" (14 bits) -> "1110101010101010" (16 bits) <-> at the software side
     *      . adc1 (=FPA_amp_squid_offset_correction) generates the following incremental values
     *          . 0 to 16383 (14 bits) -> -8192 to 8191
     ***************************************************************************
     */
    const msg = "Check the pattern of the recorded samples from ADC0 (FPA_adc_mux_squid_feedback)";
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    // check the pattern on the adc0
    v_cnt_err0 = 0;
    v_first = 1;
    v_state = 0;
    // expected pattern
    const adc0_word0 = 5461;
    const adc0_word1 = -5462; //
    for (i = 0; i < FPA_rec_adc_size; i++) {
        // data from the FPGA
        adc0 = FPA_adc_mux_squid_feedback[i];
        // initial pattern
        if (v_first == 1) {
            v_first = 0;
            // define the initial state
            if (adc0 == adc0_word0) {
                v_state = 0;
            } else if (adc0 == adc0_word1) {
                v_state = 1;
            } else {
                v_cnt_err0 += 1;
            }
        }

        // state machine
        if (v_state == 0) {
            v_state = 1;
            if (adc0 != adc0_word0) {
                v_cnt_err0 += 1;
            }

        } else if (v_state == 1) {
            v_state = 0;
            if (adc0 != adc0_word1) {
                v_cnt_err0 += 1;
            }
        } else {
            v_cnt_err0 += 1;
        }


    }

    // check the read data Vs the written data
    const msg = "Check the number of errors on the FPA_adc_mux_squid_feedback(adc0)";
    error = check_equal(value0_p = v_cnt_err0, value1_p = 0, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error != 0) {
        cnt_error_rec += 1;

    }

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    //check the pattern on the adc1
    const msg = "Check the pattern of the recorded samples from ADC1 (FPA_amp_squid_offset_correction)";
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    v_cnt_err1 = 0;
    v_first = 1;
    v_last_data = 0;
    const adc1_word_max = 8191; //16383 (considered as signed value) + 2 extension bits (signe)
    const adc1_word_min = -8192; //16383 (considered as signed value) + 2 extension bits (signe)
    for (i = 0; i < FPA_rec_adc_size; i++) {
        // data from the FPGA
        adc1 = FPA_adc_amp_squid_offset_correction[i];
        // initial value for v_last_data
        if (v_first == 1) {
            v_first = 0;
            v_last_data = adc1;
            continue;
        }

        if (v_last_data == adc1_word_max) {
            if (adc1 != adc1_word_min) {
                print(i.toString(10), ' ', v_last_data.toString(10), ' ', adc1_word_max.toString(10));
                v_cnt_err1 += 1;
            }
        } else {
            // adc1 should be equal to v_last_data + 1
            new_data = v_last_data + 1;
            if (new_data != adc1) {
                const msg = "ADC1 errors (id,new_data,adc1): (" + i.toString(10) + ", " + new_data.toString(10) + ", " + adc1.toString(10) + ' )';
                display(msg_p = msg, level_p = level1, mode_p = mode_p);
                v_cnt_err1 += 1;
            }

        }

        v_last_data = adc1;


    }
    // check the read data Vs the written data
    const msg = "Check the number of errors on the FPA_amp_squid_offset_correction(adc1)";
    error = check_equal(value0_p = v_cnt_err1, value1_p = 0, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);

    if (error != 0) {
        cnt_error_rec += 1;

    }
    return cnt_error_rec
}


/**
 * Test the RAM configuration
 *   The steps are:
 *     . for each RAM, write an unique and custom pattern
 *     . Read the RAM contents from the pipeout access
 *     . check if each written and read value are equal.
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function test_ram_conf(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // for each ram, expected ram size
    //sendToFPA_loadTES_PulseShape(32768);
    //sendToFPA_loadAmpSQUID_TF(16384);
    //sendToFPA_loadMuxSQUID_TF(8192);
    //sendToFPA_loadTES_SteadyState(64);
    //sendToFPA_loadMuxSQUID_Offset(64);

    // count the number of error message
    cnt_error_ram_conf = 0;


    /*
     ***************************************************************************
     * configure the tes_pulse_shape RAM
     ***************************************************************************
     */
    const msg = "Load the FPASim tes_pulse_shape RAM";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);

    const tab_length = 32768;
    tes_pulse_shape_tab = Array(tab_length);
    cnt = 0;
    for (i = 0; i < tab_length; ++i) {
        tes_pulse_shape_tab[i] = cnt;
        if (cnt == 16383) {
            cnt = 0;
        } else {
            cnt = cnt + 1;
        }
    }
    sendToFPA_loadTES_PulseShape(tes_pulse_shape_tab);

    /*
     ***************************************************************************
     * Configure the amp_squid_tf RAM
     ***************************************************************************
     */
    const msg = "Load the FPASim amp_squid_tf RAM";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);

    const tab_length = 16384;
    amp_squid_tf_tab = Array(tab_length);
    cnt = 0;
    for (i = 0; i < tab_length; ++i) {
        amp_squid_tf_tab[i] = cnt;
        if (cnt == 16383) {
            cnt = 0;
        } else {
            cnt = cnt + 2;
        }
    }
    sendToFPA_loadAmpSQUID_TF(amp_squid_tf_tab);

    /*
     ***************************************************************************
     * Configure the mux_squid_tf RAM
     ***************************************************************************
     */
    const msg = "Load the FPASim mux_squid_tf RAM";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);

    const tab_length = 8192;
    mux_squid_tf_tab = Array(tab_length);
    cnt = 0;
    for (i = 0; i < tab_length; ++i) {
        mux_squid_tf_tab[i] = cnt;
        if (cnt == 16383) {
            cnt = 0;
        } else {
            cnt = cnt + 3;
        }
    }
    sendToFPA_loadMuxSQUID_TF(mux_squid_tf_tab);

    /*
     ***************************************************************************
     * Configure the tes_std_state RAM
     ***************************************************************************
     */
    const msg = "Load the FPASim tes_std_state RAM";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);

    const tab_length = 64;
    tes_steady_state_tab = Array(tab_length);
    cnt = 0;
    for (i = 0; i < tab_length; ++i) {
        tes_steady_state_tab[i] = cnt;
        if (cnt == 16383) {
            cnt = 0;
        } else {
            cnt = cnt + 4;
        }
    }
    sendToFPA_loadTES_SteadyState(tes_steady_state_tab);

    /*
     ***************************************************************************
     * Configure the mux_squid_offset RAM
     ***************************************************************************
     */
    const msg = "Configure the FPASim mux_squid_offset RAM";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);


    const tab_length = 64;
    mux_squid_offset_tab = Array(tab_length);
    cnt = 0;
    for (i = 0; i < tab_length; ++i) {
        mux_squid_offset_tab[i] = cnt;
        if (cnt == 16383) {
            cnt = 0;
        } else {
            cnt = cnt + 5;
        }
    }
    sendToFPA_loadMuxSQUID_Offset(mux_squid_offset_tab);

    /*
     ***************************************************************************
     * Configure the mux_squid_offset RAM
     ***************************************************************************
     */
    const msg = "Set the read_all bit: read the FPASim RAMs";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
    sendToFPA_readAllRegisters();

    const tempo = 2000
    const msg = "Wait for " + tempo.toString(10) + " ms";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
    waitMs(tempo);

    /*
     ***************************************************************************
     * Read and check the tes_pulse_shape RAM
     ***************************************************************************
     */

    const msg = "Read the tes_pulse_shape RAM (pipeout access)";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
    getLatestValue("FPA_TES_PULSE_SHAPE");

    const msg = "FPA_TES_PULSE_SHAPE: length:" + FPA_TES_PULSE_SHAPE.length;
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    print(FPA_TES_PULSE_SHAPE);

    const msg = "Check: the FPASim tes_pulse_shape";
    error = check_equal_tab(tab0_p = FPA_TES_PULSE_SHAPE, tab1_p = tes_pulse_shape_tab, msg_p = msg, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error != 0) {
        cnt_error_ram_conf += 1;

    }

    const msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    /*
     ***************************************************************************
     * Read and check the amp_squid_tf RAM
     ***************************************************************************
     */

    const msg = "Read the amp_squid_tf RAM (pipeout access)";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);

    getLatestValue("FPA_AMP_SQUID_TF");

    const msg = "FPA_AMP_SQUID_TF: length=" + FPA_AMP_SQUID_TF.length;
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    print(FPA_AMP_SQUID_TF);

    const msg = "Check: the FPASim amp_squid_tf RAM";
    error = check_equal_tab(tab0_p = FPA_AMP_SQUID_TF, tab1_p = amp_squid_tf_tab, msg_p = msg, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error != 0) {
        cnt_error_ram_conf += 1;

    }

    const msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);


    /*
     ***************************************************************************
     * Read and check the mux_squid_offset RAM
     ***************************************************************************
     */

    const msg = "Read the mux_squid_tf RAM (pipeout access)";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);

    getLatestValue("FPA_MUX_SQUID_TF");

    const msg = "FPA_MUX_SQUID_TF: length=" + FPA_MUX_SQUID_TF.length;
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    print(FPA_MUX_SQUID_TF);

    const msg = "Check: the FPASim mux_squid_tf RAM";
    error = check_equal_tab(tab0_p = FPA_MUX_SQUID_TF, tab1_p = mux_squid_tf_tab, msg_p = msg, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error != 0) {
        cnt_error_ram_conf += 1;

    }
    const msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);


    /*
     ***************************************************************************
     * Read and check the tes_std_state RAM
     ***************************************************************************
     */

    const msg = "Read the tes_std_state RAM (pipeout access)";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);


    getLatestValue("FPA_TES_STD_STATE");
    const msg = "FPA_TES_STD_STATE: length=" + FPA_TES_STD_STATE.length;
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    print(FPA_TES_STD_STATE);

    const msg = "Check: the FPASim tes_std_state RAM";
    error = check_equal_tab(tab0_p = FPA_TES_STD_STATE, tab1_p = tes_steady_state_tab, msg_p = msg, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error != 0) {
        cnt_error_ram_conf += 1;

    }
    const msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);


    /*
     ***************************************************************************
     * Read and check the mux_squid_offset RAM
     ***************************************************************************
     */

    const msg = "Read the mux_squid_offset RAM (pipeout access)";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);

    getLatestValue("FPA_MUX_SQUID_OFFSET");

    const msg = "FPA_MUX_SQUID_OFFSET: length=" + FPA_MUX_SQUID_OFFSET.length;
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    print(FPA_MUX_SQUID_OFFSET);

    const msg = "Check: the FPASim mux_squid_offset RAM";
    error = check_equal_tab(tab0_p = FPA_MUX_SQUID_OFFSET, tab1_p = mux_squid_offset_tab, msg_p = msg, level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error != 0) {
        cnt_error_ram_conf += 1;

    }
    const msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);

    return cnt_error_ram_conf;
}


/**
 * Test the dac pattern
 *   The steps are:
 *     . reset the fpasim
 *     . configure the dac with default value
 *     . configure the dac to check a pre-defined pattern
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function test_dac_pattern(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // count the number of error message
    cnt_error_dac_pattern = 0;

    /*
     ***************************************************************************
     * reset the fpasim function
     ***************************************************************************
     */
    const msg = "Reset the FPASim function";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_reset(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    /*
     ***************************************************************************
     * Configure the FPGA sim registers
     ***************************************************************************
     */
    configure_fpasim(level_p = level_p, mode_p = mode_p, verbosity_p = verbosity_p)

    /*
     ***************************************************************************
     * check: dac pattern generation
     ***************************************************************************
     */
    // enable dac pattern check
    const msg = "Enable the dac pattern generator";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_dac_enable_pattern(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);


    // tempo
    tempo = 2000;
    const msg = "wait for " + tempo.toString(10) + " ms";
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);

    waitMs(tempo);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    // disable dac pattern check
    const msg = "Disable the dac pattern generator";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_dac_disable_pattern(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    // check
    const msg = "Error detection";
    display_subtitle(msg_p = msg, level_p = level0, mode_p = mode_p);
    iotest_results = fpasim_dac_get_pattern_result(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    // check the read data Vs the written data
    const msg = "Check iotest_results";
    error = check_equal(value0_p = 0, value1_p = iotest_results, msg_p = msg, level_p = level2, mode_p = mode_p, verbosity_p = verbosity_p);
    if (error != 0) {
        cnt_error_dac_pattern += 1;

    }
    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    return cnt_error_dac_pattern;

}



/**
 * Script Entry Point
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */

function main(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;


    /*
     ***************************************************************************
     * display the test description
     ***************************************************************************
     */
    const msg = "FPAsim Test Description: check_tmtc_link";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);

    const msg = "Contexte et objet du test";
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);

    const msg = [
        "Certains parametres de fonctionnement du FPAsim peuvent se regler par commandes depuis le XIFU Studio.",
        "Les parametres de ces commandes sont stockes dans des registres du FPAsim et ils peuvent etre relus.",
        "L'objet de ce test est de verifier la communication entre le FPAsim et le XIFU Studio en programmant et en relisant le contenu des registres du FPAsim."
    ];
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    const msg = "Deroulement du test"
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);
    const msg = [
        "Lire le contenu des registres constant du FPAsim et verifier qu'il correspond aux valeurs par defauts (en particulier le champs qui correspond à la version du firmware)",
        "Configurer les composants de la carte FMC150 tel que le CDCE, l'ADC, le DAC, l'AMC.",
        "    . Note:",
        "        . Cette configuration est importante puisque le composant ADC fournit la clock utilisé pour la lecture des registres liès aux fonctionnalités de la fonction FPAsim",
        "Initilialiser les fonctions du FPASim",
        "Tester la configuration des registres du FPAsim",
        "    . Pour chaque registre, effectuer les étapes suivantes:",
        "      . ecriture -> lecture -> vérification (valeur écrite = valeur lue?)",
        "Tester la configuration des RAMs du FPAsim",
        "    . Effectuer les étapes suivantes:",
        "      . Configurer les RAMs avec de nouvelles valeurs",
        "      . activer la lecture automatique des RAMs",
        "      . vérifier le contenu de chaque RAMs (valeurs écrites = valeurs luee?)",
        "Tester le lien de communication: puce ADC de la carte FMC150 -> FPASim",
        "    . Effectuer les étapes suivantes:",
        "      . Configurer la puce ADC en générateur de 'pattern' pré-défini",
        "      . Activer la fonction de 'recording' du FPASim",
        "      . vérifier le pattern des échantillons ADC enregistrés (= au pattern pré-défini de la puce ADC?)",
        "Tester le lien de communication: FPASim -> puce DAC de la carte FMC150",
        "    . Effectuer les étapes suivantes:",
        "      . Configurer la puce DAC en vérificateur de 'pattern'",
        "         . Note:",
        "             . Le pattern a vérifié est configurable via les registres de la puce DAC",
        "             . Le pattern doit être égale au pattern codé en dure dans le FPASim: (see pkg_fpasim/pkg_DAC_PATTERN0, etc.)",
        "      . Configurer le FPASim en générateur de pattern (voir le bit dac_en_pattern du registre 'DEBUG_CTRL')",
        "      . lire le(s) registre(s) d'erreur(s) de la puce DAC. Ce(s) registre(s) sont associés au vérificateur de pattern de la puce DAC."
    ];
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    const msg = "Criteres de succes"
    display_subtitle(msg_p = msg, level_p = level1, mode_p = mode_p);
    const msg = [
        "La premiere lecture des registres correspond aux valeurs par defauts du firmware.",
        "La deuxieme lecture des registres correspond aux valeurs programmees dans le firmware."
    ];
    display(msg_p = msg, level_p = level2, mode_p = mode_p);

    const msg = "";
    display(msg_p = msg, level_p = level0, mode_p = mode_p);



    /*
     ***************************************************************************
     * display the script info
     ***************************************************************************
     */
    error_info_cnt = 0;
    error_info_cnt = fpasim_script_info(level_p = level0, mode_p = mode_p, 2);


    /*
     ***************************************************************************
     * Get the test to execute
     ***************************************************************************
     */
    const msg = "Tests to execute:";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);

    // 1st Test to execute
    const str_en_wire = getText("Test: Check wire registers (0 or 1)", "0");
    const en_wire = parseInt(str_en_wire, 10);
    const msg = "Test: Check wire registers: " + str_en_wire;
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    // 2nd Test to execute
    const str_en_rec = getText("Test: Check ADC recording (0 or 1)", "0");
    const en_rec = parseInt(str_en_rec, 10);
    const msg = "Test: Check adc recording: " + str_en_rec;
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    // 3rd Test to execute
    const str_en_ram_conf = getText("Test: Check RAM configuration (0 or 1)", "0");
    const en_ram_conf = parseInt(str_en_ram_conf, 10);
    const msg = "Test: Check RAM configuration: " + str_en_ram_conf;
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    // 4th Test to execute
    const str_dac_en_pattern = getText("Test: Check DAC pattern generation (0 or 1)", "0");
    const dac_en_pattern = parseInt(str_dac_en_pattern, 10);
    const msg = "Test: Check DAC pattern generation: " + str_dac_en_pattern;
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    /*
     ***************************************************************************
     * configure spi devices, FPAsim RAM with default values
     ***************************************************************************
     */
    const msg = "Configure spi devices + FPAsim RAMs with default values";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);
    error_load_ram_cnt = fpasim_configure(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);


    /*
     ***************************************************************************
     * reset the fpasim function
     ***************************************************************************
     */
    const msg = "Reset the FPASim function";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);
    fpasim_reset(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    error_wire_cnt = 0;
    error_rec_cnt = 0;
    error_ram_conf_cnt = 0;
    error_dac_pattern_cnt = 0;

    /*
     ***************************************************************************
     * Check: Wire registers
     ***************************************************************************
     */
    if (en_wire == 1) {
        const msg = "Test: wire Registers";
        display_title(msg_p = msg, level_p = level0, mode_p = mode_p);
        error_wire_cnt = test_wire(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    }

    /*
     ***************************************************************************
     * Check: ADC recording
     ***************************************************************************
     */
    if (en_rec == 1) {
        const msg = "Test: ADC recording";
        display_title(msg_p = msg, level_p = level0, mode_p = mode_p);
        error_rec_cnt = test_recording(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);

    }

    /*
     ***************************************************************************
     * Check: RAM configuration
     ***************************************************************************
     */
    if (en_ram_conf == 1) {
        const msg = "Test: RAM configuration";
        display_title(msg_p = msg, level_p = level0, mode_p = mode_p);
        error_ram_conf_cnt = test_ram_conf(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    }

    /*
     ***************************************************************************
     * Check: dac pattern generation
     ***************************************************************************
     */
    if (dac_en_pattern == 1) {
        const msg = "Test: DAC pattern generation";
        display_title(msg_p = msg, level_p = level0, mode_p = mode_p);
        error_dac_pattern_cnt = test_dac_pattern(level_p = level1, mode_p = mode_p, verbosity_p = verbosity_p);
    }


    /*
     ***************************************************************************
     * check all errors
     ***************************************************************************
     */
    error_debug_cnt = 0;
    const msg = "Check Debug Errors";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);
    error_debug_cnt = fpasim_check_all_errors(level_p = level1, mode_p = 0, verbosity_p = 0);

    /*
     ***************************************************************************
     * Summary
     ***************************************************************************
     */
    const msg = "Summary: Errors";
    display_title(msg_p = msg, level_p = level1, mode_p = mode_p);

    // get board id
    const reg_name = 'BOARD_ID';
    const msg = "Get " + reg_name + ": ";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    const data = fpasim_get_wireout_by_name(reg_name_p = reg_name, level_p = level2, mode_p = mode_p, 2);

    const msg = "";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    // get the firmware Id
    const reg_name = 'FIRMWARE_ID';
    const msg = "Get " + reg_name + ": ";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    const data = fpasim_get_wireout_by_name(reg_name_p = reg_name, level_p = level2, mode_p = mode_p, 2);


    const msg = " ";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);

    // get firmware version
    const reg_name = 'FIRMWARE_VERSION';
    const msg = "Get " + reg_name + ": ";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);
    data = fpasim_get_wireout_by_name(reg_name_p = reg_name, level_p = level2, mode_p = mode_p, 2);

    const msg = " ";
    display(msg_p = msg, level_p = level1, mode_p = mode_p);


    // summary of the fpasim_script_info errors
    if (error_info_cnt == 0) {
        const msg_tmp = "[OK]: Script Info has " + error_info_cnt.toString(10) + " error";
        display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
    } else {
        const msg_tmp = "[KO]: Script Info has " + error_info_cnt.toString(10) + " errors";
        display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
    }

    // summary of the RAM loading with default value
    if (error_load_ram_cnt == 0) {
        const msg_tmp = "[OK]: Default RAM loading " + error_load_ram_cnt.toString(10) + " error";
        display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
    } else {
        const msg_tmp = "[KO]: Default RAM loading " + error_load_ram_cnt.toString(10) + " errors";
        display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
    }


    // summary of the test_wire errors
    if (en_wire == 0)
    {
        const msg_tmp = "[N/A]: Test: Wire Registers was not performed ";
        display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
    }
    else
    {
        if (error_wire_cnt == 0) {
            const msg_tmp = "[OK]: Test: Wire Registers has " + error_wire_cnt.toString(10) + " error";
            display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
        } else {
            const msg_tmp = "[KO]: Test: Wire Registers has " + error_wire_cnt.toString(10) + " errors";
            display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
        }
    }
    // summary of the test_recording errors

    if (en_rec == 0)
    {
        const msg_tmp = "[N/A]: Test: ADC recording was not performed ";
        display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
    }
    else
    {
        if (error_rec_cnt == 0) {
            const msg_tmp = "[OK]: Test: ADC recording has " + error_rec_cnt.toString(10) + " error";
            display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
        } else {
            const msg_tmp = "[KO]: ADC recording has " + error_rec_cnt.toString(10) + " errors";
            display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
        }
    }

    // summary of the test_ram_conf errors
    if (en_ram_conf == 0)
    {
        const msg_tmp = "[N/A]: Test: RAM configuration was not performed ";
        display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
    }
    else
    {
        if (error_ram_conf_cnt == 0) {
            const msg_tmp = "[OK]: Test: RAM configuration has " + error_ram_conf_cnt.toString(10) + " error";
            display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
        } else {
            const msg_tmp = "[KO]: Test: RAM configuration has " + error_ram_conf_cnt.toString(10) + " errors";
            display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
        }
    }

    // summary of the test_dac_pattern errors
     if (dac_en_pattern == 0)
    {
        const msg_tmp = "[N/A]: Test: DAC pattern generation was not performed ";
        display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
    }
    else
    {
        if (error_dac_pattern_cnt == 0) {
            const msg_tmp = "[OK]: Test: DAC pattern generation has " + error_dac_pattern_cnt.toString(10) + " error";
            display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
        } else {
            const msg_tmp = "[KO]: Test: DAC pattern generation has " + error_dac_pattern_cnt.toString(10) + " errors";
            display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
        }
    }

    if (error_debug_cnt == 0) {
        const msg_tmp = "[OK]: Debug errors has " + error_debug_cnt.toString(10) + " error";
        display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
    } else {
        const msg_tmp = "[KO]: Debug errors generation has " + error_debug_cnt.toString(10) + " errors";
        display(msg_p = msg_tmp, level_p = level1, mode_p = mode_p);
    }
    /*
     ***************************************************************************
     * End of Test
     ***************************************************************************
     */
    const msg = "End of Test";
    display_title(msg_p = msg, level_p = level0, mode_p = mode_p);

}

/**
 * Execute the main function
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
main(level_p = 0, mode_p = 0, verbosity_p = 0);