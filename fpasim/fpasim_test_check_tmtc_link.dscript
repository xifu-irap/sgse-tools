// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Ken-ji de la Rosa, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE Focal Plane Assembly simulator.
//
//                              fpasim-fw is free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                   kenji.delarosa@alten.com
//    @file                   fpasim_test_check_tmtc_link.dscript
// -------------------------------------------------------------------------------------------------------------
//    Automatic Generation    No
//    Code Rules Reference
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//   This test does the following tests:
//      . test_wire: test the FPASim registers
//          . For the main registers: write -> read back -> check
//      . test_ram_conf: test the FPASim RAM configuration
//          . Write -> read back -> check
//      . test_recording: test the link adc device -> FPASim
//          . configure the adc device into a pattern generator
//          . records ADC samples
//          . compare the recorded ADC samples with the generated one.
//      . test_dac_pattern: test the link FPASim -> dac device.
//          . configure the dac device into a pattern checker.
//          . configure the FPASim into a pattern generator.
//          . compare the generated DAC samples with the checked one.
//
//   Note:
//      . Tested with javascript
//
// -------------------------------------------------------------------------------------------------------------

// import javascript
include("./fpasim/utils_tools.dscript");
include("./fpasim/fpasim_tools.dscript");

/**
 * Configure the registers of the FPAsim function with default values
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function configure_fpasim(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;
    /*
     ***************************************************************************
     * Configure the FPASIM functions
     ***************************************************************************
     */

    msg = "Configure the fpasim function";
    display_title(msg, level0, mode_p);


    // set the register: MUX_SQ_FB_DELAY
    mux_sq_fb_delay = 0x0;
    msg = "Set register: MUX_SQ_FB_DELAY";
    display(msg, level1, mode_p);
    sendToFPAsim_configureFeedbackDelay(mux_sq_fb_delay);

    msg = "";
    display(msg, level1, mode_p);



    // set the register: AMP_SQ_OF_DELAY
    amp_sq_of_delay = 0x0;
    msg = "Set register: AMP_SQ_OF_DELAY";
    display(msg, level1, mode_p);
    sendToFPAsim_configureOffsetCompDelay(amp_sq_of_delay);

    msg = "";
    display(msg, level1, mode_p);


    // set the register: ERROR_DELAY
    error_delay = 0x0;
    msg = "Set register: ERROR_DELAY";
    display(msg, level1, mode_p);
    sendToFPAsim_configureErrorDelay(error_delay);

    msg = "";
    display(msg, level1, mode_p);


    // set the register: RA_DELAY
    ra_delay = 0x0;
    msg = "Set register: RA_DELAY";
    display(msg, level1, mode_p);
    sendToFPAsim_configureRaDelay(ra_delay);

    msg = "";
    display(msg, level1, mode_p);


    // set the register: TES_CONF (Mandatory)
    nbPixels = 34;
    nbSamplesPerPixel = 40;
    totalFrameSize = nbPixels * nbSamplesPerPixel;

    nbPixels = nbPixels - 1; // add -1 because we start from 0
    nbSamplesPerPixel = nbSamplesPerPixel - 1; // add -1 because we start from 0
    totalFrameSize = totalFrameSize - 1; // add -1 because we start from 0

    msg = "Set register: TES_CONF";
    display(msg, level1, mode_p);
    sendToFPAsim_configureTES_conf(nbPixels, nbSamplesPerPixel, totalFrameSize);

    msg = "";
    display(msg, level1, mode_p);

    // set the register: CONF0
    inter_squid_gain = 0xFF;
    msg = "Set register: CONF0";
    display(msg, level1, mode_p);
    data = fpasim_build_conf0(inter_squid_gain);
    fpasim_set_debug_wirein_by_name('CONF0', data, level1, mode_p)

    msg = "";
    display(msg, level1, mode_p);
}

/**
 * Test the wire register:
 *   For each defined wire register, the steps are:
 *      . write the register (wire_in)
 *      . read the register (wire_out)
 *      . check if the written data and the read data are equal.
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function test_wire(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    //
    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    cnt_error_wire = 0

    /*
     ***************************************************************************
     * check: CTRL
     ***************************************************************************
     */
    data0 = 0xFFFF0000;

    msg = "Set register: CTRL";
    display(msg, level1, mode_p);
    sendToFPAsim_configureControl(data0);
    // read the register
    data1 = fpasim_get_wireout_by_name("CTRL", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: Ctrl";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }

    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * check: MAKE_PULSE
     ***************************************************************************
     */
    pixel_all = 0x0;
    pixelId = 0x1;
    timeShift = 0x2;
    pulseHeight = 0x3;

    msg = "Set register: MAKE_PULSE";
    display(msg, level1, mode_p);
    sendToFPAsim_makePulse(pixelId, timeShift, pulseHeight);
    // build the data to send
    data0 = fpasim_build_make_pulse(pixel_all, pixelId, timeShift, pulseHeight);
    // read the register
    data1 = fpasim_get_wireout_by_name("MAKE_PULSE", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: Make_Pulse";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }

    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * check: MUX_SQ_FB_DELAY
     ***************************************************************************
     */

    mux_sq_fb_delay = 0x5;

    msg = "Set register: MUX_SQ_FB_DELAY";
    display(msg, level1, mode_p);
    sendToFPAsim_configureFeedbackDelay(mux_sq_fb_delay);
    // build the data to send
    data0 = fpasim_build_mux_sq_fb_delay(mux_sq_fb_delay);
    // read the register
    data1 = fpasim_get_wireout_by_name("MUX_SQ_FB_DELAY", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: MUX_SQ_FB_DELAY";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * check: AMP_SQ_OF_DELAY
     ***************************************************************************
     */

    amp_sq_of_delay = 0x6;

    msg = "Set register: AMP_SQ_OF_DELAY";
    display(msg, level1, mode_p);
    sendToFPAsim_configureOffsetCompDelay(amp_sq_of_delay);
    // build the data to send
    data0 = fpasim_build_amp_sq_of_delay(amp_sq_of_delay);
    // read the register
    data1 = fpasim_get_wireout_by_name("AMP_SQ_OF_DELAY", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: AMP_SQ_OF_DELAY";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);
    /*
     ***************************************************************************
     * check: ERROR_DELAY
     ***************************************************************************
     */

    error_delay = 0x7;

    msg = "Set register: ERROR_DELAY";
    display(msg, level1, mode_p);
    sendToFPAsim_configureErrorDelay(error_delay);
    // build the data to send
    data0 = fpasim_build_error_delay(error_delay);
    // read the register
    data1 = fpasim_get_wireout_by_name("ERROR_DELAY", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: ERROR_DELAY";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * check: RA_DELAY
     ***************************************************************************
     */
    ra_delay = 0x8;
    // build the data to send
    data0 = fpasim_build_ra_delay(ra_delay);

    msg = "Set register: RA_DELAY";
    display(msg, level1, mode_p);
    sendToFPAsim_configureRaDelay(ra_delay);
    // read the register
    data1 = fpasim_get_wireout_by_name("RA_DELAY", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: RA_DELAY";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * check: TES_CONF
     ***************************************************************************
     */
    nbPixels = 34 - 1; // add -1 because we start from 0
    nbSamplesPerPixel = 40 - 1; // add -1 because we start from 0
    totalFrameSize = nbPixels * nbSamplesPerPixel - 1; // add -1 because we start from 0

    msg = "Set register: TES_CONF";
    display(msg, level1, mode_p);
    sendToFPAsim_configureTES_conf(nbPixels, nbSamplesPerPixel, totalFrameSize);
    // build the data to send
    data0 = fpasim_build_tes_conf(nbPixels, nbSamplesPerPixel, totalFrameSize);
    // read the register
    data1 = fpasim_get_wireout_by_name("TES_CONF", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: TES_CONF";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * check: CONF0
     ***************************************************************************
     */

    inter_squid_gain = 0xFF;
    // build the data to send
    data0 = fpasim_build_conf0(inter_squid_gain);

    msg = "Set register: CONF0";
    display(msg, level1, mode_p);
    fpasim_set_debug_wirein_by_name('CONF0', data0, level2, mode_p);

    // read the register
    data1 = fpasim_get_wireout_by_name("CONF0", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: CONF0";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * check: REC_CONF0
     ***************************************************************************
     */
    rec_adc_nb_word_32b = 0x0000ABCD;
    data0 = fpasim_build_rec_conf0(rec_adc_nb_word_32b);

    msg = "Set register: REC_CONF0";
    display(msg, level1, mode_p);
    // build the data to send
    fpasim_set_debug_wirein_by_name('REC_CONF0', data0, level2, mode_p, verbosity_p);
    // read the register
    data1 = fpasim_get_wireout_by_name("REC_CONF0", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: REC_CONF0";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * check: REC_CTRL
     ***************************************************************************
     */

    mask_en = 0xFFFFFFFE // don't touch the en bit
    rec_ctrl_data = 0x9ABCEF0 & mask_en;
    data0 = rec_ctrl_data;

    msg = "Set register: REC_CTRL";
    display(msg, level1, mode_p);
    // build the data to send
    fpasim_set_debug_wirein_by_name('REC_CTRL', data0, level2, mode_p, verbosity_p);
    // read the register
    data1 = fpasim_get_wireout_by_name("REC_CTRL", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: REC_CTRL";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * check: SPI_CTRL
     ***************************************************************************
     */
    en = 0;
    rst = 1;
    // build the data to send
    data0 = fpasim_build_spi_ctrl(rst_p = rst, en);

    msg = "Set register: SPI_CTRL";
    display(msg, level1, mode_p);
    fpasim_set_debug_wirein_by_name('SPI_CTRL', data0, level2, mode_p, verbosity_p);
    // read the register
    data1 = fpasim_get_wireout_by_name("SPI_CTRL", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: SPI_CTRL";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * check: SPI_CONF0
     ***************************************************************************
     */
    spi_mode = 0;
    spi_id = 2;
    data0 = fpasim_build_spi_conf0(spi_id_p = spi_id, spi_mode_p = spi_mode)

    msg = "Set register: SPI_CONF0";
    display(msg, level1, mode_p);
    fpasim_set_debug_wirein_by_name('SPI_CONF0', data0, level2, mode_p, verbosity_p);
    // read the register
    data1 = fpasim_get_wireout_by_name("SPI_CONF0", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: SPI_CONF0";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * check: SPI_CONF1
     ***************************************************************************
     */
    mask = 0xFFFFFFFE; // protect the spi_dac_tx_en
    data0 = 0xABCDEFA & mask;

    msg = "Set register: SPI_CONF1";
    display(msg, level1, mode_p);
    // data0 = fpasim_build_spi_conf1(spi_dac_tx_en_p=spi_dac_tx_en)
    fpasim_set_debug_wirein_by_name('SPI_CONF1', data0, level2, mode_p, verbosity_p);

    // read the register
    data1 = fpasim_get_wireout_by_name("SPI_CONF1", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: SPI_CONF1";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * check: SPI_WR_DATA
     ***************************************************************************
     */
    spi_data = 0x9ABDCEF1;
    // build the data to send
    data0 = fpasim_build_spi_wr_data(spi_data);

    msg = "Set register: SPI_WR_DATA";
    display(msg, level1, mode_p);
    fpasim_set_debug_wirein_by_name('SPI_WR_DATA', data0, level2, mode_p, verbosity_p);
    // read the register
    data1 = fpasim_get_wireout_by_name("SPI_WR_DATA", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: SPI_WR_DATA";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * check: DEBUG_CTRL
     ***************************************************************************
     */
    adc1_bypass = 0;
    adc0_bypass = 0;
    dac_en_pattern = 0;
    rst_status = 0;
    debug_pulse = 1;
    // build the data to send
    data0 = fpasim_build_debug_ctrl(adc1_bypass, adc0_bypass, dac_en_pattern, rst_status, debug_pulse);

    msg = "Set register: DEBUG_CTRL";
    display(msg, level1, mode_p);
    fpasim_set_debug_wirein_by_name('DEBUG_CTRL', data0, level2, mode_p, verbosity_p);
    // read the register
    data1 = fpasim_get_wireout_by_name("DEBUG_CTRL", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: DEBUG_CTRL";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * check: ERROR_SEL
     ***************************************************************************
     */
    sel_error = 2;
    // build the data to send
    data0 = fpasim_build_error_sel(sel_error);

    msg = "Set register: ERROR_SEL";
    display(msg, level1, mode_p);

    fpasim_set_debug_wirein_by_name('ERROR_SEL', data0, level2, mode_p, verbosity_p);
    // read the register
    data1 = fpasim_get_wireout_by_name("ERROR_SEL", level2, mode_p, verbosity_p);
    // check the read data Vs the written data
    msg = "Check register: ERROR_SEL";
    error = check_equal(data0, data1, msg, level2, mode_p, verbosity_p);
    if (error == -1) {
        cnt_error_wire += 1
    }
    msg = "";
    display(msg, level1, mode_p);

    return cnt_error_wire

}

/**
 * Test the adc recording.
 *   The steps are:
 *     . configure the ADC devices in order to generate a pre-defined pattern
 *     . configure the FPASIM in order to records few samples
 *     . print the recorded samples
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function test_recording(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // count the number of error message
    cnt_error_rec = 0;

    /*
     ***************************************************************************
     * reset the fpasim function
     ***************************************************************************
     */
    msg = "Reset the FPASim function";
    display_title(msg, level0, mode_p);
    fpasim_reset(level1, mode_p, verbosity_p);

    /*
     ***************************************************************************
     * Configure the FPGA sim registers
     ***************************************************************************
     */
    configure_fpasim(level_p, mode_p, verbosity_p);

    /*
     ***************************************************************************
     * Configure the ADC to generate a pre-defined pattern
     ***************************************************************************
     */
    msg = "Configure the ADC pattern generator (pre-defined pattern)";
    display_subtitle(msg, level0, mode_p);
    // configure the adc to automatically generate pattern.
    adc_generate_pattern0(level1, mode_p, verbosity_p);

    /*
     ***************************************************************************
     Enable the fpasim function
      ***************************************************************************
      */
    rst = 0;
    en = 1;
    data = fpasim_build_ctrl(rst, en);
    msg = "Enable the FPASim function";
    display_subtitle(msg, level1, mode_p);
    sendToFPAsim_configureControl(data);

    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * Set the number of words to record
     ***************************************************************************
     */

    // Set the number of 32 bit-words to record.
    rec_adc_nb_word_32b = 4092 - 1;
    msg = "Configure the number of ADC samples to record: " + rec_adc_nb_word_32b.toString(10);
    display_subtitle(msg, level1, mode_p);
    data = fpasim_build_rec_conf0(rec_adc_nb_word_32b_p = rec_adc_nb_word_32b);
    fpasim_set_debug_wirein_by_name("REC_CONF0", data, level2, mode_p, verbosity_p);

    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * Enable the recording
     ***************************************************************************
     */
    en = 1;
    data = fpasim_build_rec_ctrl(en);
    msg = "Enable the FPASim recording";
    display_subtitle(msg, level1, mode_p);
    fpasim_set_debug_wirein_by_name("REC_CTRL", data, level2, mode_p, verbosity_p);

    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * Set a tempo
     ***************************************************************************
     */
    tempo = 2000;
    msg = "wait for " + tempo.toString(10) + " ms";
    display_subtitle(msg, level1, mode_p);
    waitMs(tempo);

    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * Get ADC samples
     * Get the number of recording ADC samples
     ***************************************************************************
     */
    msg = "Get the ADC samples (adc0 and adc1)";
    display_subtitle(msg, level1, mode_p);

    getLatestValue("FPAsim_ADC_feedback_record,FPAsim_ADC_offsetComp_record,FPAsim_ADC_recordSize");


    msg = "Read FPAsim_ADC_feedback_record tab";
    display(msg, level2, mode_p);
    print(FPAsim_ADC_feedback_record);

    msg = "";
    display(msg, level2, mode_p);

    msg = "Read FPAsim_ADC_offsetComp_record";
    display(msg, level2, mode_p);
    print(FPAsim_ADC_offsetComp_record);

    msg = "";
    display(msg, level2, mode_p);

    msg = "Number of read data (pipeout access): FPAsim_ADC_recordSize=" + FPAsim_ADC_recordSize.toString(10);
    display(msg, level2, mode_p);

    msg = "";
    display(msg, level2, mode_p);

    /*
     ***************************************************************************
     * Auto-check the recording adc data
     *   if the adc device generates the pre-defined pattern0 then
     *      . adc0 (=FPAsim_ADC_feedback_record) generates the following alternates values
     *          . "01010101010101" (14 bits) -> "0001010101010101" (16 bits) <-> 5461 at the software side
     *          . "10101010101010" (14 bits) -> "1110101010101010" (16 bits) <-> at the software side
     *      . adc1 (=FPA_amp_squid_offset_correction) generates the following incremental values
     *          . 0 to 16383 (14 bits) -> -8192 to 8191
     ***************************************************************************
     */
    msg = "Check the pattern of the recorded samples from ADC0 (FPAsim_ADC_feedback_record)";
    display_subtitle(msg, level1, mode_p);
    msg = "";
    display(msg, level1, mode_p);

    // check the pattern on the adc0
    v_cnt_err0 = 0;
    v_first = 1;
    v_state = 0;
    // expected pattern
    adc0_word0 = 5461;
    adc0_word1 = -5462; //
    for (i = 0; i < FPAsim_ADC_recordSize; i++) {
        // data from the FPGA
        adc0 = FPAsim_ADC_feedback_record[i];
        // initial pattern
        if (v_first == 1) {
            v_first = 0;
            // define the initial state
            if (adc0 == adc0_word0) {
                v_state = 0;
            } else if (adc0 == adc0_word1) {
                v_state = 1;
            } else {
                v_cnt_err0 += 1;
            }
        }

        // state machine
        if (v_state == 0) {
            v_state = 1;
            if (adc0 != adc0_word0) {
                v_cnt_err0 += 1;
            }

        } else if (v_state == 1) {
            v_state = 0;
            if (adc0 != adc0_word1) {
                v_cnt_err0 += 1;
            }
        } else {
            v_cnt_err0 += 1;
        }


    }

    // check the read data Vs the written data
    msg = "Check the number of errors on the FPAsim_ADC_feedback_record(adc0)";
    error = check_equal(v_cnt_err0, 0, msg, level2, mode_p, verbosity_p);
    if (error != 0) {
        cnt_error_rec += 1;

    }

    msg = "";
    display(msg, level1, mode_p);

    //check the pattern on the adc1
    msg = "Check the pattern of the recorded samples from ADC1 (FPA_amp_squid_offset_correction)";
    display_subtitle(msg, level1, mode_p);

    msg = "";
    display(msg, level1, mode_p);

    v_cnt_err1 = 0;
    v_first = 1;
    v_last_data = 0;
    adc1_word_max = 8191; //16383 (considered as signed value) + 2 extension bits (signe)
    adc1_word_min = -8192; //16383 (considered as signed value) + 2 extension bits (signe)
    for (i = 0; i < FPAsim_ADC_recordSize; i++) {
        // data from the FPGA
        adc1 = FPAsim_ADC_offsetComp_record[i];
        // initial value for v_last_data
        if (v_first == 1) {
            v_first = 0;
            v_last_data = adc1;
            continue;
        }

        if (v_last_data == adc1_word_max) {
            if (adc1 != adc1_word_min) {
                print(i.toString(10), ' ', v_last_data.toString(10), ' ', adc1_word_max.toString(10));
                v_cnt_err1 += 1;
            }
        } else {
            // adc1 should be equal to v_last_data + 1
            new_data = v_last_data + 1;
            if (new_data != adc1) {
                msg = "ADC1 errors (id,new_data,adc1): (" + i.toString(10) + ", " + new_data.toString(10) + ", " + adc1.toString(10) + ' )';
                display(msg, level1, mode_p);
                v_cnt_err1 += 1;
            }

        }

        v_last_data = adc1;


    }
    // check the read data Vs the written data
    msg = "Check the number of errors on the FPA_amp_squid_offset_correction(adc1)";
    error = check_equal(v_cnt_err1, 0, msg, level2, mode_p, verbosity_p);

    if (error != 0) {
        cnt_error_rec += 1;

    }
    return cnt_error_rec
}


/**
 * Test the RAM configuration
 *   The steps are:
 *     . for each RAM, write an unique and custom pattern
 *     . Read the RAM contents from the pipeout access
 *     . check if each written and read value are equal.
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function test_ram_conf(level_p, mode_p, verbosity_p) {

    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // for each ram, expected ram size
    //sendToFPAsim_loadTES_pulseShape(32768);
    //sendToFPAsim_loadSQA_TF(16384);
    //sendToFPAsim_loadSQM_TF(8192);
    //sendToFPAsim_loadTES_steadyState(64);
    //sendToFPAsim_loadSQM_offset(64);

    // count the number of error message
    cnt_error_ram_conf = 0;


    /*
     ***************************************************************************
     * configure the tes_pulse_shape RAM
     ***************************************************************************
     */
    msg = "Load the FPASim tes_pulse_shape RAM";
    display_subtitle(msg, level0, mode_p);

    tab_length = 32768;
    tes_pulse_shape_tab = Array(tab_length);
    cnt = 0;
    for (i = 0; i < tab_length; ++i) {
        tes_pulse_shape_tab[i] = cnt;
        if (cnt == 16383) {
            cnt = 0;
        } else {
            cnt = cnt + 1;
        }
    }
    sendToFPAsim_loadTES_pulseShape(tes_pulse_shape_tab);

    /*
     ***************************************************************************
     * Configure the amp_squid_tf RAM
     ***************************************************************************
     */
    msg = "Load the FPASim amp_squid_tf RAM";
    display_subtitle(msg, level0, mode_p);

    tab_length = 16384;
    amp_squid_tf_tab = Array(tab_length);
    cnt = 0;
    for (i = 0; i < tab_length; ++i) {
        amp_squid_tf_tab[i] = cnt;
        if (cnt == 16383) {
            cnt = 0;
        } else {
            cnt = cnt + 2;
        }
    }
    sendToFPAsim_loadSQA_TF(amp_squid_tf_tab);

    /*
     ***************************************************************************
     * Configure the mux_squid_tf RAM
     ***************************************************************************
     */
    msg = "Load the FPASim mux_squid_tf RAM";
    display_subtitle(msg, level0, mode_p);

    tab_length = 8192;
    mux_squid_tf_tab = Array(tab_length);
    cnt = 0;
    for (i = 0; i < tab_length; ++i) {
        mux_squid_tf_tab[i] = cnt;
        if (cnt == 16383) {
            cnt = 0;
        } else {
            cnt = cnt + 3;
        }
    }
    sendToFPAsim_loadSQM_TF(mux_squid_tf_tab);

    /*
     ***************************************************************************
     * Configure the tes_std_state RAM
     ***************************************************************************
     */
    msg = "Load the FPASim tes_std_state RAM";
    display_subtitle(msg, level0, mode_p);

    tab_length = 64;
    tes_steady_state_tab = Array(tab_length);
    cnt = 0;
    for (i = 0; i < tab_length; ++i) {
        tes_steady_state_tab[i] = cnt;
        if (cnt == 16383) {
            cnt = 0;
        } else {
            cnt = cnt + 4;
        }
    }
    sendToFPAsim_loadTES_steadyState(tes_steady_state_tab);

    /*
     ***************************************************************************
     * Configure the mux_squid_offset RAM
     ***************************************************************************
     */
    msg = "Configure the FPASim mux_squid_offset RAM";
    display_subtitle(msg, level0, mode_p);


    tab_length = 64;
    mux_squid_offset_tab = Array(tab_length);
    cnt = 0;
    for (i = 0; i < tab_length; ++i) {
        mux_squid_offset_tab[i] = cnt;
        if (cnt == 16383) {
            cnt = 0;
        } else {
            cnt = cnt + 5;
        }
    }
    sendToFPAsim_loadSQM_offset(mux_squid_offset_tab);

    /*
     ***************************************************************************
     * Configure the mux_squid_offset RAM
     ***************************************************************************
     */
    msg = "Set the read_all bit: read the FPASim RAMs";
    display_subtitle(msg, level0, mode_p);
    sendToFPAsim_readAllRegisters();

    tempo = 2000
    msg = "Wait for " + tempo.toString(10) + " ms";
    display_subtitle(msg, level0, mode_p);
    waitMs(tempo);

    /*
     ***************************************************************************
     * Read and check the tes_pulse_shape RAM
     ***************************************************************************
     */

    msg = "Read the tes_pulse_shape RAM (pipeout access)";
    display_subtitle(msg, level0, mode_p);
    getLatestValue("FPAsim_TES_pulseShape");

    msg = "FPAsim_TES_pulseShape: length:" + FPAsim_TES_pulseShape.length;
    display(msg, level1, mode_p);

    print(FPAsim_TES_pulseShape);

    msg = "Check: the FPASim tes_pulse_shape";
    error = check_equal_tab(FPAsim_TES_pulseShape, tes_pulse_shape_tab, msg, level1, mode_p, verbosity_p);
    if (error != 0) {
        cnt_error_ram_conf += 1;

    }

    msg = "";
    display(msg, level0, mode_p);

    /*
     ***************************************************************************
     * Read and check the amp_squid_tf RAM
     ***************************************************************************
     */

    msg = "Read the amp_squid_tf RAM (pipeout access)";
    display_subtitle(msg, level0, mode_p);

    getLatestValue("FPAsim_SQA_TF");

    msg = "FPAsim_SQA_TF: length=" + FPAsim_SQA_TF.length;
    display(msg, level1, mode_p);

    print(FPAsim_SQA_TF);

    msg = "Check: the FPASim amp_squid_tf RAM";
    error = check_equal_tab(FPAsim_SQA_TF, amp_squid_tf_tab, msg, level1, mode_p, verbosity_p);
    if (error != 0) {
        cnt_error_ram_conf += 1;

    }

    msg = "";
    display(msg, level0, mode_p);


    /*
     ***************************************************************************
     * Read and check the mux_squid_offset RAM
     ***************************************************************************
     */

    msg = "Read the mux_squid_tf RAM (pipeout access)";
    display_subtitle(msg, level0, mode_p);

    getLatestValue("FPAsim_SQM_TF");

    msg = "FPAsim_SQM_TF: length=" + FPAsim_SQM_TF.length;
    display(msg, level1, mode_p);

    print(FPAsim_SQM_TF);

    msg = "Check: the FPASim mux_squid_tf RAM";
    error = check_equal_tab(FPAsim_SQM_TF, mux_squid_tf_tab, msg, level1, mode_p, verbosity_p);
    if (error != 0) {
        cnt_error_ram_conf += 1;

    }
    msg = "";
    display(msg, level0, mode_p);


    /*
     ***************************************************************************
     * Read and check the tes_std_state RAM
     ***************************************************************************
     */

    msg = "Read the tes_std_state RAM (pipeout access)";
    display_subtitle(msg, level0, mode_p);


    getLatestValue("FPAsim_TES_steadyState");
    msg = "FPAsim_TES_steadyState: length=" + FPAsim_TES_steadyState.length;
    display(msg, level1, mode_p);

    print(FPAsim_TES_steadyState);

    msg = "Check: the FPASim tes_std_state RAM";
    error = check_equal_tab(FPAsim_TES_steadyState, tes_steady_state_tab, msg, level1, mode_p, verbosity_p);
    if (error != 0) {
        cnt_error_ram_conf += 1;

    }
    msg = "";
    display(msg, level0, mode_p);


    /*
     ***************************************************************************
     * Read and check the mux_squid_offset RAM
     ***************************************************************************
     */

    msg = "Read the mux_squid_offset RAM (pipeout access)";
    display_subtitle(msg, level0, mode_p);

    getLatestValue("FPAsim_SQM_offset");

    msg = "FPAsim_SQM_offset: length=" + FPAsim_SQM_offset.length;
    display(msg, level1, mode_p);
    print(FPAsim_SQM_offset);

    msg = "Check: the FPASim mux_squid_offset RAM";
    error = check_equal_tab(FPAsim_SQM_offset, mux_squid_offset_tab, msg, level1, mode_p, verbosity_p);
    if (error != 0) {
        cnt_error_ram_conf += 1;

    }
    msg = "";
    display(msg, level0, mode_p);

    return cnt_error_ram_conf;
}


/**
 * Test the dac pattern
 *   The steps are:
 *     . reset the fpasim
 *     . configure the dac with default value
 *     . configure the dac to check a pre-defined pattern
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function test_dac_pattern(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // count the number of error message
    cnt_error_dac_pattern = 0;

    /*
     ***************************************************************************
     * reset the fpasim function
     ***************************************************************************
     */
    msg = "Reset the FPASim function";
    display_title(msg, level0, mode_p);
    fpasim_reset(level1, mode_p, verbosity_p);

    /*
     ***************************************************************************
     * Configure the FPGA sim registers
     ***************************************************************************
     */
    configure_fpasim(level_p, mode_p, verbosity_p)

    /*
     ***************************************************************************
     * check: dac pattern generation
     ***************************************************************************
     */
    // enable dac pattern check
    msg = "Enable the dac pattern generator";
    display_subtitle(msg, level0, mode_p);
    fpasim_dac_enable_pattern(level1, mode_p, verbosity_p);


    // tempo
    tempo = 2000;
    msg = "wait for " + tempo.toString(10) + " ms";
    display_subtitle(msg, level1, mode_p);

    waitMs(tempo);

    msg = "";
    display(msg, level1, mode_p);

    // disable dac pattern check
    msg = "Disable the dac pattern generator";
    display_subtitle(msg, level0, mode_p);
    fpasim_dac_disable_pattern(level1, mode_p, verbosity_p);

    msg = "";
    display(msg, level1, mode_p);

    // check
    msg = "Error detection";
    display_subtitle(msg, level0, mode_p);
    iotest_results = fpasim_dac_get_pattern_result(level1, mode_p, verbosity_p);

    msg = "";
    display(msg, level1, mode_p);


    // check the read data Vs the written data
    msg = "Check iotest_results";
    error = check_equal(0, iotest_results, msg, level2, mode_p, verbosity_p);
    if (error != 0) {
        cnt_error_dac_pattern += 1;

    }
    msg = "";
    display(msg, level1, mode_p);

    return cnt_error_dac_pattern;

}

/**
 * Test the adc bypass functions with the recording functionality
 *   The steps are:
 *     . configure the FPASIM in order to records few samples
 *     . perform 2 tests:
 *       . test0: bypass ADC0, no change on ADC1
 *          . print the recorded samples
 *          . auto-check recorded (ADC0, ADC1)
 *       . test1: no change on ADC0, bypass ADC1
 *          . print the recorded samples
 *          . auto-check recorded (ADC0, ADC1)
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
function test_adc_bypass(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;

    // count the number of error message
    cnt_error_adc_bypass = 0;

    /*
     ***************************************************************************
     * reset the fpasim function
     ***************************************************************************
     */
    msg = "Reset the FPASim function";
    display_title(msg, level0, mode_p);
    fpasim_reset(level1, mode_p, verbosity_p);

    /*
     ***************************************************************************
     * Configure the FPGA sim registers
     ***************************************************************************
     */
    configure_fpasim(level_p, mode_p, verbosity_p);

    /*
     ***************************************************************************
     Enable the fpasim function
      ***************************************************************************
      */
    rst = 0;
    en = 1;
    data = fpasim_build_ctrl(rst, en);
    msg = "Enable the FPASim function";
    display_subtitle(msg, level1, mode_p);
    sendToFPAsim_configureControl(data);

    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * recording: Set the number of words to record
     ***************************************************************************
     */

    // Set the number of 32 bit-words to record.
    rec_adc_nb_word_32b = 4092 - 1;
    msg = "Configure the number of ADC samples to record: " + rec_adc_nb_word_32b.toString(10);
    display_subtitle(msg, level1, mode_p);
    data = fpasim_build_rec_conf0(rec_adc_nb_word_32b);
    fpasim_set_debug_wirein_by_name("REC_CONF0", data, level2, mode_p, verbosity_p);

    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * no change on adc1 (FPAsim_ADC_offsetComp_record)
     * bypass the adc0 (FPAsim_ADC_feedback_record)
     *   => adc1 values !=0 (because of noise/signal on the data path)
     *   => adc0 values = 0
     ***************************************************************************
     */
    msg = "Test0: Bypass ADC0, no change ADC1";
    display(msg, level0, mode_p);
     /*
     ***************************************************************************
     * check: DEBUG_CTRL
     ***************************************************************************
     */
    adc1_bypass = 0;
    adc0_bypass = 1;
    dac_en_pattern = 0;
    rst_status = 0;
    debug_pulse = 1;
    // build the data to send
    data0 = fpasim_build_debug_ctrl(adc1_bypass, adc0_bypass, dac_en_pattern, rst_status, debug_pulse);

    msg = "Set register: DEBUG_CTRL";
    display_subtitle(msg, level1, mode_p);
    fpasim_set_debug_wirein_by_name('DEBUG_CTRL', data0, level2, mode_p, verbosity_p);


    /*
     ***************************************************************************
     * recording: start
     ***************************************************************************
     */
    en = 1;
    data = fpasim_build_rec_ctrl(en);
    msg = "Enable the FPASim recording";
    display_subtitle(msg, level1, mode_p);
    fpasim_set_debug_wirein_by_name("REC_CTRL", data, level2, mode_p, verbosity_p);

    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * Set a tempo
     ***************************************************************************
     */
    tempo = 2000;
    msg = "wait for " + tempo.toString(10) + " ms";
    display_subtitle(msg, level1, mode_p);
    waitMs(tempo);

    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * Get ADC samples from the FPGA
     ***************************************************************************
     */
    msg = "Get the ADC samples: (ADC0, ADC1)";
    display_subtitle(msg, level1, mode_p);

    getLatestValue("FPAsim_ADC_feedback_record,FPAsim_ADC_offsetComp_record,FPAsim_ADC_recordSize");


    msg = "Read ADC0:  FPAsim_ADC_feedback_record tab";
    display(msg, level2, mode_p);
    print(FPAsim_ADC_feedback_record);

    msg = "";
    display(msg, level2, mode_p);

    msg = "Read ADC1: FPAsim_ADC_offsetComp_record";
    display(msg, level2, mode_p);
    print(FPAsim_ADC_offsetComp_record);

    msg = "";
    display(msg, level2, mode_p);

    msg = "Number of read data (pipeout access): FPAsim_ADC_recordSize=" + FPAsim_ADC_recordSize.toString(10);
    display(msg, level2, mode_p);

    msg = "";
    display(msg, level2, mode_p);

    /*
     ***************************************************************************
     * Auto-check the recording adc data
     * the adc1 isn't bypassed => sum((adc1[i])**2) !=0 because of noise on this channel
     * the adc0 is bypassed => sum((adc0[i])**2) = 0
     ***************************************************************************
     */
    msg = "Check the recorded samples: (ADC0, ADC1)=(FPAsim_ADC_feedback_record,FPAsim_ADC_offsetComp_record)";
    display_subtitle(msg, level1, mode_p);
    msg = "";
    display(msg, level1, mode_p);

    // check the pattern on the adc0
    adc0_sum = 0
    adc1_sum = 0

    for (i = 0; i < FPAsim_ADC_recordSize; i++) {
        // data from the FPGA
        adc0 = FPAsim_ADC_feedback_record[i];
        adc1 = FPAsim_ADC_offsetComp_record[i];
        adc0_sum = adc0_sum + (adc0*adc0);
        adc1_sum = adc1_sum + (adc1*adc1);

    }
    // display the computed values
    msg = "ADC0: sum(x*x) = "+adc0_sum.toString(10);
    display(msg, level2, mode_p);
    msg = "ADC1: sum(x*x) = "+adc1_sum.toString(10);
    display(msg, level2, mode_p);

    msg = "";
    display(msg, level2, mode_p);

    // error checking
    if (adc0_sum == 0)
    {

        msg = "[OK]: ADC0 values = 0";
        display(msg, level2, mode_p);
    }
    else
    {
        msg = "[KO]: ADC0 values != 0";
        display(msg, level2, mode_p);
        cnt_error_adc_bypass += 1;

    }
     if (adc1_sum == 0)
    {
        msg = "[KO]: ADC1 values = 0";
        display(msg, level2, mode_p);
        cnt_error_adc_bypass += 1;
    }
    else
    {
        msg = "[OK]: ADC1 values != 0";
        display(msg, level2, mode_p);

    }

    msg = "";
    display(msg, level1, mode_p);

    /*
     ***************************************************************************
     * bypass the adc1 (FPAsim_ADC_feedback_record)
     * no change on adc0 (FPAsim_ADC_offsetComp_record)
     *   => adc1 values = 0
     *   => adc0 values !=0 (because of noise/signal on the data path)
     ***************************************************************************
     */
     msg = "Test1: Bypass ADC1, no change ADC0";
    display(msg, level0, mode_p);
     /*
     ***************************************************************************
     * check: DEBUG_CTRL
     ***************************************************************************
     */
    adc1_bypass = 1;
    adc0_bypass = 0;
    dac_en_pattern = 0;
    rst_status = 0;
    debug_pulse = 1;
    // build the data to send
    data0 = fpasim_build_debug_ctrl(adc1_bypass, adc0_bypass, dac_en_pattern, rst_status, debug_pulse);

    msg = "Set register: DEBUG_CTRL";
    display_subtitle(msg, level1, mode_p);
    fpasim_set_debug_wirein_by_name('DEBUG_CTRL', data0, level2, mode_p, verbosity_p);


    /*
     ***************************************************************************
     * recording: start
     ***************************************************************************
     */
    en = 1;
    data = fpasim_build_rec_ctrl(en);
    msg = "Enable the FPASim recording";
    display_subtitle(msg, level1, mode_p);
    fpasim_set_debug_wirein_by_name("REC_CTRL", data, level2, mode_p, verbosity_p);

    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * Set a tempo
     ***************************************************************************
     */
    tempo = 2000;
    msg = "wait for " + tempo.toString(10) + " ms";
    display_subtitle(msg, level1, mode_p);
    waitMs(tempo);

    msg = "";
    display(msg, level1, mode_p);


    /*
     ***************************************************************************
     * Get ADC samples
     ***************************************************************************
     */
    msg = "Get the ADC samples: (ADC0, ADC1)";
    display_subtitle(msg, level1, mode_p);

    getLatestValue("FPAsim_ADC_feedback_record,FPAsim_ADC_offsetComp_record,FPAsim_ADC_recordSize");


    msg = "Read ADC0: FPAsim_ADC_feedback_record";
    display(msg, level2, mode_p);
    print(FPAsim_ADC_feedback_record);

    msg = "";
    display(msg, level2, mode_p);

    msg = "Read ADC1: FPAsim_ADC_offsetComp_record";
    display(msg, level2, mode_p);
    print(FPAsim_ADC_offsetComp_record);

    msg = "";
    display(msg, level2, mode_p);

    msg = "Number of read data (pipeout access): FPAsim_ADC_recordSize=" + FPAsim_ADC_recordSize.toString(10);
    display(msg, level2, mode_p);

    msg = "";
    display(msg, level2, mode_p);

    /*
     ***************************************************************************
     * Auto-check the recording adc data
     * the adc1 is bypassed => sum((adc1[i])**2) = 0
     * the adc0 isn't bypassed => sum((adc0[i])**2) != 0 because of noise on this channel
     ***************************************************************************
     */
    msg = "Check the recorded samples: (ADC0, ADC1)=(FPAsim_ADC_feedback_record,FPAsim_ADC_offsetComp_record)";
    display_subtitle(msg, level1, mode_p);
    msg = "";
    display(msg, level1, mode_p);

    // check the pattern on the adc0
    adc0_sum = 0
    adc1_sum = 0

    for (i = 0; i < FPAsim_ADC_recordSize; i++) {
        // data from the FPGA
        adc0 = FPAsim_ADC_feedback_record[i];
        adc1 = FPAsim_ADC_offsetComp_record[i];
        adc0_sum = adc0_sum + (adc0*adc0);
        adc1_sum = adc1_sum + (adc1*adc1);

    }

    // display the computed values
    msg = "ADC0: sum(x*x) = "+adc0_sum.toString(10);
    display(msg, level2, mode_p);
    msg = "ADC1: sum(x*x) = "+adc1_sum.toString(10);
    display(msg, level2, mode_p);

    msg = "";
    display(msg, level2, mode_p);

    // error checking
    if (adc0_sum == 0)
    {

        msg = "[KO]: ADC0 values = 0";
        display(msg, level2, mode_p);
        cnt_error_adc_bypass += 1;
    }
    else
    {
        msg = "[OK]: ADC0 values != 0";
        display(msg, level2, mode_p);

    }
     if (adc1_sum == 0)
    {
        msg = "[OK]: ADC1 values = 0";
        display(msg, level2, mode_p);
    }
    else
    {
        msg = "[KO]: ADC1 values != 0";
        display(msg, level2, mode_p);
        cnt_error_adc_bypass += 1;

    }




    return cnt_error_adc_bypass
}

/**
 * Script Entry Point
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */

function main(level_p, mode_p, verbosity_p) {
    // default function parameter values
    if (typeof(level_p) === 'undefined') level_p = 0;
    if (typeof(mode_p) === 'undefined') mode_p = 0;
    if (typeof(verbosity_p) === 'undefined') verbosity_p = 0;

    const level0 = level_p;
    const level1 = level_p + 1;
    const level2 = level_p + 2;


    // script name
    script_name = "fpasim_test_check_tmtc_link";

    /*
     ***************************************************************************
     * display the test description
     ***************************************************************************
     */
    msg = "Test description: " + script_name;
    display_title(msg, level0, mode_p);

    msg = "Contexte et objet du test";
    display_subtitle(msg, level1, mode_p);

    msg = [
        "Certains parametres de fonctionnement du FPAsim peuvent se regler par commandes depuis le XIFU Studio.",
        "Les parametres de ces commandes sont stockes dans des registres du FPAsim et ils peuvent etre relus.",
        "L'objet de ce test est de verifier la communication entre le FPAsim et le XIFU Studio en programmant et en relisant le contenu des registres du FPAsim."
    ];
    display(msg, level2, mode_p);

    msg = "Deroulement du test"
    display_subtitle(msg, level1, mode_p);
    msg = [
        "Lire le contenu des registres constant du FPAsim et verifier qu'il correspond aux valeurs par defauts (en particulier le champs qui correspond à la version du firmware)",
        "Configurer les composants de la carte FMC150 tel que le CDCE, l'ADC, le DAC, l'AMC.",
        "    . Note:",
        "        . Cette configuration est importante puisque le composant ADC fournit la clock utilisé pour la lecture des registres liès aux fonctionnalités de la fonction FPAsim",
        "Initilialiser les fonctions du FPASim",
        "Tester la configuration des registres du FPAsim",
        "    . Pour chaque registre, effectuer les étapes suivantes:",
        "      . ecriture -> lecture -> vérification (valeur écrite = valeur lue?)",
        "Tester la configuration des RAMs du FPAsim",
        "    . Effectuer les étapes suivantes:",
        "      . Configurer les RAMs avec de nouvelles valeurs",
        "      . activer la lecture automatique des RAMs",
        "      . vérifier le contenu de chaque RAMs (valeurs écrites = valeurs luee?)",
        "Tester le lien de communication: puce ADC de la carte FMC150 -> FPASim",
        "    . Effectuer les étapes suivantes:",
        "      . Configurer la puce ADC en générateur de 'pattern' pré-défini",
        "      . Activer la fonction de 'recording' du FPASim",
        "      . vérifier le pattern des échantillons ADC enregistrés (= au pattern pré-défini de la puce ADC?)",
        "Tester le lien de communication: FPASim -> puce DAC de la carte FMC150",
        "    . Effectuer les étapes suivantes:",
        "      . Configurer la puce DAC en vérificateur de 'pattern'",
        "         . Note:",
        "             . Le pattern a vérifié est configurable via les registres de la puce DAC",
        "             . Le pattern doit être égale au pattern codé en dure dans le FPASim: (see pkg_fpasim/pkg_DAC_PATTERN0, etc.)",
        "      . Configurer le FPASim en générateur de pattern (voir le bit dac_en_pattern du registre 'DEBUG_CTRL')",
        "      . lire le(s) registre(s) d'erreur(s) de la puce DAC. Ce(s) registre(s) sont associés au vérificateur de pattern de la puce DAC."
    ];
    display(msg, level2, mode_p);

    msg = "Criteres de succes"
    display_subtitle(msg, level1, mode_p);
    msg = [
        "La premiere lecture des registres correspond aux valeurs par defauts du firmware.",
        "La deuxieme lecture des registres correspond aux valeurs programmees dans le firmware."
    ];
    display(msg, level2, mode_p);

    msg = "";
    display(msg, level0, mode_p);



    /*
     ***************************************************************************
     * display the script info
     ***************************************************************************
     */
    list_tmp       = fpasim_script_info(level0, mode_p, 2);
    error_info_cnt = list_tmp[0];
    info           = list_tmp[1];

    // build output filename
    output_filename = script_name + "__" + info + ".txt";


    /*
     ***************************************************************************
     * Get the test to execute
     ***************************************************************************
     */
    msg = "Tests to execute:";
    display_title(msg, level0, mode_p);

    // 1st Test to execute
    str_en_wire = getText("Test: Check wire registers (0 or 1)", "0");
    en_wire = parseInt(str_en_wire, 10);
    msg = "Test: Check wire registers: " + str_en_wire;
    display(msg, level1, mode_p);

    // 2nd Test to execute
    str_en_rec = getText("Test: Check ADC recording (0 or 1)", "0");
    en_rec = parseInt(str_en_rec, 10);
    msg = "Test: Check adc recording: " + str_en_rec;
    display(msg, level1, mode_p);

    // 3rd Test to execute
    str_en_ram_conf = getText("Test: Check RAM configuration (0 or 1)", "0");
    en_ram_conf = parseInt(str_en_ram_conf, 10);
    msg = "Test: Check RAM configuration: " + str_en_ram_conf;
    display(msg, level1, mode_p);

    // 4th Test to execute
    str_en_dac_pattern = getText("Test: Check DAC pattern generation (0 or 1)", "0");
    en_dac_pattern = parseInt(str_en_dac_pattern, 10);
    msg = "Test: Check DAC pattern generation: " + str_en_dac_pattern;
    display(msg, level1, mode_p);

    // 5th Test to execute
    str_en_bypass_adc = getText("Test: Check Bypass ADCs (0 or 1)", "0");
    en_bypass_adc = parseInt(str_en_bypass_adc, 10);
    msg = "Test: Check Bypass ADCs: " + str_en_bypass_adc;
    display(msg, level1, mode_p);



    /*
     ***************************************************************************
     * configure spi devices, FPAsim RAM with default values
     ***************************************************************************
     */
    msg = "Configure spi devices + FPAsim RAMs with default values";
    display_title(msg, level0, mode_p);
    error_load_ram_cnt = fpasim_configure(level1, mode_p, verbosity_p);


    /*
     ***************************************************************************
     * reset the fpasim function
     ***************************************************************************
     */
    msg = "Reset the FPASim function";
    display_title(msg, level0, mode_p);
    fpasim_reset(level1, mode_p, verbosity_p);

    error_wire_cnt = 0;
    error_rec_cnt = 0;
    error_ram_conf_cnt = 0;
    error_dac_pattern_cnt = 0;
    error_adc_bypass_cnt = 0;

    /*
     ***************************************************************************
     * Check: Wire registers
     ***************************************************************************
     */
    if (en_wire == 1) {
        msg = "Test: wire Registers";
        display_title(msg, level0, mode_p);
        error_wire_cnt = test_wire(level1, mode_p, verbosity_p);

    }

    /*
     ***************************************************************************
     * Check: ADC recording
     ***************************************************************************
     */
    if (en_rec == 1) {
        msg = "Test: ADC recording";
        display_title(msg, level0, mode_p);
        error_rec_cnt = test_recording(level1, mode_p, verbosity_p);

    }

    /*
     ***************************************************************************
     * Check: RAM configuration
     ***************************************************************************
     */
    if (en_ram_conf == 1) {
        msg = "Test: RAM configuration";
        display_title(msg, level0, mode_p);
        error_ram_conf_cnt = test_ram_conf(level1, mode_p, verbosity_p);
    }

    /*
     ***************************************************************************
     * Check: dac pattern generation
     ***************************************************************************
     */
    if (en_dac_pattern == 1) {
        msg = "Test: DAC pattern generation";
        display_title(msg, level0, mode_p);
        error_dac_pattern_cnt = test_dac_pattern(level1, mode_p, verbosity_p);
    }

    /*
     ***************************************************************************
     * Check: bypass ADCs
     ***************************************************************************
     */
    if (en_bypass_adc == 1) {
        msg = "Test: bypass ADCs";
        display_title(msg, level0, mode_p);
        error_adc_bypass_cnt = test_adc_bypass(level_p, mode_p, verbosity_p);
    }

    /*
     ***************************************************************************
     * check all errors
     ***************************************************************************
     */
    error_debug_cnt = 0;
    msg = "Check internal errors (debug)";
    display_title(msg, level0, mode_p);
    error_debug_cnt = fpasim_check_all_errors(level1, 0, 0);

    /*
     ***************************************************************************
     * Summary
     ***************************************************************************
     */
    msg = "Summary: Errors";
    display_title(msg, level1, mode_p);

    // get board id
    reg_name = 'HARDWARE_ID';
    msg = "Get " + reg_name + ": ";
    display(msg, level1, mode_p);
    data = fpasim_get_wireout_by_name(reg_name, level2, mode_p, 2);

    msg = "";
    display(msg, level1, mode_p);

    // get the firmware Id
    reg_name = 'FIRMWARE_ID';
    msg = "Get " + reg_name + ": ";
    display(msg, level1, mode_p);
    data = fpasim_get_wireout_by_name(reg_name, level2, mode_p, 2);


    msg = " ";
    display(msg, level1, mode_p);

    // get firmware version
    reg_name = 'FIRMWARE_VERSION';
    msg = "Get " + reg_name + ": ";
    display(msg, level1, mode_p);
    data = fpasim_get_wireout_by_name(reg_name, level2, mode_p, 2);

    msg = " ";
    display(msg, level1, mode_p);


    // summary of the fpasim_script_info errors
    if (error_info_cnt == 0) {
        msg_tmp = "[OK]: Script Info: " + error_info_cnt.toString(10) + " error";
        display(msg_tmp, level1, mode_p);
    } else {
        msg_tmp = "[KO]: Script Info: " + error_info_cnt.toString(10) + " errors";
        display(msg_tmp, level1, mode_p);
    }

    // summary of the RAM loading with default value
    if (error_load_ram_cnt == 0) {
        msg_tmp = "[OK]: RAM loading: " + error_load_ram_cnt.toString(10) + " error";
        display(msg_tmp, level1, mode_p);
    } else {
        msg_tmp = "[KO]: RAM loading: " + error_load_ram_cnt.toString(10) + " errors";
        display(msg_tmp, level1, mode_p);
    }


    // summary of the test_wire errors
    if (en_wire == 0)
    {
        msg_tmp = "[N/A]: test_wire was not performed ";
        display(msg_tmp, level1, mode_p);
    }
    else
    {
        if (error_wire_cnt == 0) {
            msg_tmp = "[OK]: test_wire: " + error_wire_cnt.toString(10) + " error";
            display(msg_tmp, level1, mode_p);
        } else {
            msg_tmp = "[KO]: test_wire: " + error_wire_cnt.toString(10) + " errors";
            display(msg_tmp, level1, mode_p);
        }
    }
    // summary of the test_recording errors

    if (en_rec == 0)
    {
        msg_tmp = "[N/A]: test_recording (ADC) was not performed ";
        display(msg_tmp, level1, mode_p);
    }
    else
    {
        if (error_rec_cnt == 0) {
            msg_tmp = "[OK]: test_recording (ADC): " + error_rec_cnt.toString(10) + " error";
            display(msg_tmp, level1, mode_p);
        } else {
            msg_tmp = "[KO]: test_recording (ADC): " + error_rec_cnt.toString(10) + " errors";
            display(msg_tmp, level1, mode_p);
        }
    }

    // summary of the test_ram_conf errors
    if (en_ram_conf == 0)
    {
        msg_tmp = "[N/A]: test_ram_conf was not performed ";
        display(msg_tmp, level1, mode_p);
    }
    else
    {
        if (error_ram_conf_cnt == 0) {
            msg_tmp = "[OK]: test_ram_conf: " + error_ram_conf_cnt.toString(10) + " error";
            display(msg_tmp, level1, mode_p);
        } else {
            msg_tmp = "[KO]: test_ram_conf: " + error_ram_conf_cnt.toString(10) + " errors";
            display(msg_tmp, level1, mode_p);
        }
    }

    // summary of the test_dac_pattern errors
     if (en_dac_pattern == 0)
    {
        msg_tmp = "[N/A]: test_dac_pattern (generation) was not performed ";
        display(msg_tmp, level1, mode_p);
    }
    else
    {
        if (error_dac_pattern_cnt == 0) {
            msg_tmp = "[OK]: test_dac_pattern (generation): " + error_dac_pattern_cnt.toString(10) + " error";
            display(msg_tmp, level1, mode_p);
        } else {
            msg_tmp = "[KO]: test_dac_pattern (generation): " + error_dac_pattern_cnt.toString(10) + " errors";
            display(msg_tmp, level1, mode_p);
        }
    }

    // summary of the test_bypass_adc errors
     if (en_bypass_adc == 0)
    {
        msg_tmp = "[N/A]: test_adc_bypass was not performed ";
        display(msg_tmp, level1, mode_p);
    }
    else
    {
        if (error_adc_bypass_cnt == 0) {
            msg_tmp = "[OK]: test_adc_bypass: " + error_adc_bypass_cnt.toString(10) + " error";
            display(msg_tmp, level1, mode_p);
        } else {
            msg_tmp = "[KO]: test_adc_bypass: " + error_adc_bypass_cnt.toString(10) + " errors";
            display(msg_tmp, level1, mode_p);
        }
    }


    if (error_debug_cnt == 0) {
        msg_tmp = "[OK]: Debug internal errors: " + error_debug_cnt.toString(10) + " error";
        display(msg_tmp, level1, mode_p);
    } else {
        msg_tmp = "[KO]: Debug internal errors: " + error_debug_cnt.toString(10) + " errors";
        display(msg_tmp, level1, mode_p);
    }
    /*
     ***************************************************************************
     * End of Test
     ***************************************************************************
     */
    msg = "End of Test";
    display_title(msg, level0, mode_p);

    /*
     ***************************************************************************
     * Save the Log content
     ***************************************************************************
     */
    saveLogContent(output_filename);

}

/**
 * Execute the main function
 * @param {number} level_p - level of indentation at the beginning
 * @param {number} mode_p - define the print output
 * @param {number} verbosity_p - level of verbosity
 */
main(0, 0, 0);