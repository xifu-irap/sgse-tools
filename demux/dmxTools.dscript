// -------------------------------------------------------------------------------------------------------------
//                              Copyright (C) 2022-2030 Laurent Ravera, IRAP Toulouse.
// -------------------------------------------------------------------------------------------------------------
//                              This file is part of the ATHENA X-IFU DRE SGSE tools.
//
//                              sgse tools javascripts are free software: you can redistribute it and/or modify
//                              it under the terms of the GNU General Public License as published by
//                              the Free Software Foundation, either version 3 of the License, or
//                              (at your option) any later version.
//
//                              This program is distributed in the hope that it will be useful,
//                              but WITHOUT ANY WARRANTY; without even the implied warranty of
//                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//                              GNU General Public License for more details.
//
//                              You should have received a copy of the GNU General Public License
//                              along with this program.  If not, see <https://www.gnu.org/licenses/>.
// -------------------------------------------------------------------------------------------------------------
//    email                     laurent.ravera@irap.omp.eu
//    @file                     dmxTools.dscript
// -------------------------------------------------------------------------------------------------------------
//    @details
//
//    This file contains low level commands to configure and read the configuration of a DRE DEMUX module.
//
// -------------------------------------------------------------------------------------------------------------

// imports
include("../common/utilTools.dscript");
include("../demux/dmxRegAddresses.dscript");

/**
 * Definition of constants
 */

// General constants
const DMX_NB_COL = 4;
const DMX_NB_PIX_PER_COL = 34;
const DMX_PULSESHAPING_NBVALUES = 20;
const DMX_TEST_PATTERN_NBPARAMS = 4;
const DMX_TEST_PATTERN_NBREGIONS = 5;
const ON = 1;
const OFF = 0;
const TABUL = "   ";

// MUX SQUID feedback modes
const FEEDBACK_MODE_OPEN_LOOP = 0; // FB0 --> feedback output
const FEEDBACK_MODE_CLOSED_LOOP = 1; // computed feedback --> feedback output
const FEEDBACK_MODE_TESTPATTERN = 2; // test pattern --> feedback output

// AMP SQUID offset modes
const OFFSET_MODE_OFF = 0; // 0V diff --> offset output
const OFFSET_MODE_OFFSET = 1; // lockpoint value --> offset output
const OFFSET_MODE_CLOSED = 2; // feedback --> offset output
const OFFSET_MODE_TESTPATTERN = 3; // test pattern --> offset output

// Data acquisition modes
const ACQ_MODE_IDLE = 0; // no data
const ACQ_MODE_SCIENCE = 1; // science data
const ACQ_MODE_ERROR = 2; // averaged ADC data
const ACQ_MODE_DUMP = 4; // row ADC data during 2 frames
const ACQ_MODE_TSTPATTERN = 7; // test pattern

// Model versions
const DMX_MODEL_VERSION = ['DM', 'EM', 'PFM', 'FM', 'Unknown', 'Unknown', 'Unknown', 'Dev kit'];

// HK
const DMX_NB_HK = 14;
const DMX_HK_NAMES = ['P5V0_ANA', 'P3V3_ANA', 'P2V5_ANA', 'P1V8_ANA', 'M2V5_ANA', 'M5V0_ANA', 'P3V3_DIG',
    'P2V5_DIG', 'P1V2_DIG', 'TEMP_AVE', 'TEMP_MAX', 'P2V5_AUX', 'VREF_TEM', 'VREF_R2R'];
const DMX_HK_UNITS = [' V', ' V', ' V', ' V', ' V', ' V', ' V',
    ' V', ' V', ' C', ' C', ' V', ' V', ' V'];

/**
 * Sets the data acquisition mode (DATA_ACQ_MODE).
 * @param {number} dataAcqMode_p - [0, 7].
 */
function setDMX_dataAcqMode(dataAcqMode_p) {
    const reg_address = ADD_DMX_DATA_ACQ_MODE;
    // Checking the value of dataAcqMode
    if (!doesArrayInclude([0, 1, 2, 4, 7], dataAcqMode_p)) {
        print("ERROR, unrecognised data acquisition mode! > " + dataAcqMode_p + "\n" + "selecting Idle mode instead");
        dataAcqMode_p = 0
    }
    sendToDMXWriteRegister(reg_address, dataAcqMode_p);
}

/**
 * Reads the data acquisition mode (DATA_ACQ_MODE).
 * @return {number} dataAcqMode - Data acquisition mode [0, 7].
 */
function readDMX_dataAcqMode() {
    sendToDMXReadRegister(ADD_DMX_DATA_ACQ_MODE);
    getLatestValue("DMX_registers");
    return DMX_registers[ADD_DMX_DATA_ACQ_MODE];
}

/**
 * Sets the mux SQUID feedback On or Off (MUX_SQ_FB_ON_OFF).
 * @param {array} feedbackOnOff_p - four values (one per column):
 *      0: feedback is off
 *      1: feedback is on.
 */
function setDMX_feedbackOnOff(feedbackOnOff_p) {

    var value = 0;
    for (var col=0; col<DMX_NB_COL; col++) {
        // Checking the value of feedbackOnOff
        if (feedbackOnOff_p[col] > 1) {
            print("ERROR, unrecognised value for MUX_SQ_FB_ON_OFF for column " + col + "! > " + feedbackOnOff_p[col] + "\n" + "Selecting OFF mode instead.");
            feedbackOnOff_p[col] = 0;
        }
        value = value + (feedbackOnOff_p[col] << (4 * col));
    }
	sendToDMXWriteRegister(ADD_DMX_MUX_SQ_FB_ON_OFF, value);
}

/**
 * Reads the feedback status (MUX_SQ_FB_ON_OFF).
 * @return {number} feedbackOnOff - Feedback on/off mode [0, 7].
 */
function readDMX_feedbackOnOff() {
    sendToDMXReadRegister(ADD_DMX_MUX_SQ_FB_ON_OFF);
    getLatestValue("DMX_registers");
    return DMX_registers[ADD_DMX_MUX_SQ_FB_ON_OFF];
}

/**
 * Sets the AMP SQUID offset mode (AMP_SQ_OFFSET_MODE).
 * @param {array} offsetMode_p - four values (one value column) in [0; 3].
 */
function setDMX_offsetMode(offsetMode_p) {
    var value = 0;
    for (var col=0; col<DMX_NB_COL; col++) {
        // Checking the value of offsetMode
        if (offsetMode_p[col] > 3) {
            print("ERROR, unrecognised offset mode for column " + col + "! > " + offsetMode_p[col] + "\n" + "Selecting OFF mode instead.");
            offsetMode_p[col] = 0;
        }
        value = value + (offsetMode_p[col] << (4 * col));
    }
	sendToDMXWriteRegister(ADD_DMX_AMP_SQ_OFFSET_MODE, value);
}

/**
 * Reads the AMP SQUID offset mode (AMP_SQ_OFFSET_MODE).
 * @return {number} offsetMode - Offset mode.
 */
function readDMX_offsetMode() {
    sendToDMXReadRegister(ADD_DMX_AMP_SQ_OFFSET_MODE);
    getLatestValue("DMX_registers");
    return DMX_registers[ADD_DMX_AMP_SQ_OFFSET_MODE];
}

/**
 * Sets the test pattern parameters (TEST_PATTERN).
 * @param {array} parameters_p - 5 sets (one per region) of 4 parameters.
 *  a - value of the pattern at the beginning of the region S(16,2)
 *  b - number of frames per step is 1+b U(16,0)
 *  c - increment between 2 successive steps S(16,2)
 *  N - number of steps in the region U(16,0)
 */
function setDMX_testPattern(parameters_p) {

    if (parameters_p.length !== DMX_TEST_PATTERN_NBREGIONS) {
        print("ERROR, wrong number of regions --> Expected " + DMX_TEST_PATTERN_NBREGIONS + ", received " + parameters_p.length);
        return;
    }
    for (var region=0; region<DMX_TEST_PATTERN_NBREGIONS; region+=1) {
        if (parameters_p[region].length !== DMX_TEST_PATTERN_NBPARAMS) {
            print("ERROR, wrong number of parameters for region " + region + " --> Expected " + DMX_TEST_PATTERN_NBPARAMS + ", received " + parameters_p[region].length);
            return;
        }
    }

	var result = [];
    for (var i=0; i<DMX_TEST_PATTERN_NBREGIONS; i++) {
		for (var j=0; j<DMX_TEST_PATTERN_NBPARAMS; j++) {
			if (j===0 || j===2) result.push(convert_sInt_to_2compInt(parameters_p[i][j], 16));
			else result.push(parameters_p[i][j]);
		}
	}

    sendToDMXWriteMultiRegisters(ADD_DMX_TEST_PATTERN, DMX_TEST_PATTERN_NBREGIONS * DMX_TEST_PATTERN_NBPARAMS, result);
}

/**
 * Reads the test pattern parameters (TEST_PATTERN).
 * @return {array} parameters - 5 sets (one per region) of 4 parameters.
 *  a - value of the pattern at the beginning of the region S(16,2)
 *  b - number of frames per step is 1+b U(16,0)
 *  c - increment between 2 successive steps S(16,2)
 *  N - number of steps in the region U(16,0)
 */
function readDMX_testPattern() {
    // Reading the test parameters from the DEMUX firmware
    const reg_address = ADD_DMX_TEST_PATTERN;
    const nbValues = DMX_TEST_PATTERN_NBREGIONS * DMX_TEST_PATTERN_NBPARAMS;
    sendToDMXReadMultiRegisters(reg_address, nbValues);
    getLatestValue("DMX_registers");
	const tp = DMX_registers.slice(reg_address, reg_address+nbValues); // parameters in a 1D array

    // Slicing the parameters per region
    var parameters2D = [];  // parameters in a 2D array
    for (var region=0; region<DMX_TEST_PATTERN_NBREGIONS; region++) {
        parameters2D[region] = tp.slice(region*DMX_TEST_PATTERN_NBPARAMS, (region+1)*DMX_TEST_PATTERN_NBPARAMS);
        // conversion of 2'complemented values to signed values
        parameters2D[region][0] = convert_2compInt_to_sInt(parameters2D[region][0], 16);
        parameters2D[region][2] = convert_2compInt_to_sInt(parameters2D[region][2], 16);
    }

    return parameters2D;
}

/**
 * enable / disable the test pattern (TEST_PATTERN_ENABLE).
 * @param {boolean} enable_p - active if true.
 * @param {boolean} infinite_p - infinitely generated if true.
 * @param {number} numberIterations_p - number of repetitions, in [0, 15].
 */
function setDMX_testPatternEnable(enable_p, infinite_p, numberIterations_p) {
    if (numberIterations_p > 15) {
        print("ERROR, incorrect number of test pattern iterations! > " + numberIterations_p + "\n" + "Setting the number of iterations to 0 instead.");
		numberIterations_p = 0;
    }
    const value = numberIterations_p + (infinite_p << 4) + (enable_p << 5);
	sendToDMXWriteRegister(ADD_DMX_TEST_PATTERN_ENABLE, value);
}

/**
 * Reads the test pattern enable register (TEST_PATTERN_ENABLE).
 * @return {array} testPatternEnable
 *							enable
 *							infinitely
 *							numberIterations.
 */
function readDMX_testPatternEnable() {
    sendToDMXReadRegister(ADD_DMX_TEST_PATTERN_ENABLE);
    getLatestValue("DMX_registers");
    const testPatternEnable = DMX_registers[ADD_DMX_TEST_PATTERN_ENABLE];
	var enable = (testPatternEnable & 0x002F) >> 5;
	var infinitely = (testPatternEnable & 0x0010) >> 4;
	var numberIterations = (testPatternEnable & 0x000F);
	return [enable===1, infinitely===1, numberIterations];
}

/**
 * sets the length of the boxcar (BOXCAR_LENGTH).
 * The real length of the boxcar is 1+length
 * @param {array} length_p - four values (one per column) in [0; 15].
 */
function setDMX_boxcarLength(length_p) {
    const reg_address = ADD_DMX_BOXCAR_LENGTH;
    var value = 0;
    for (var col = 0; col < DMX_NB_COL; col++) {
        if (length_p[col] > 15) {
            print("ERROR, boxcar length for column " + col + " is incorrect! > " + length_p[col]);
			print(" --> setting boxcar length to 0 (1 sample) instead");
			length_p[col] = 0;
        }
        value = value + (length_p[col] << (4 * col));
    }
    sendToDMXWriteRegister(reg_address, value);
}

/**
 * Reads the length of the boxcar (BOXCAR_LENGTH).
 * @return {array} length - number of samples - 1.
 */
function readDMX_boxcarLength() {
    var length = new Array(DMX_NB_COL);
    sendToDMXReadRegister(ADD_DMX_BOXCAR_LENGTH);
    getLatestValue("DMX_registers");
    var l = DMX_registers[ADD_DMX_BOXCAR_LENGTH];

	for (col = 0; col < DMX_NB_COL; col++) {
		length[col] = l & 0xF;
		l = l >> 4;
	}
    return length;
}

/**
 * Sets the values of the feedback algorithm parameter a (A) for a column.
 * This parameter defines the bandwidth.
 * @param {number} col_p - column number [0, 3].
 * @param {array} a_p - one value of parameter a per pixel U(16,16).
 */
function setDMX_a(col_p, a_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    const reg_address = ADD_DMX_A | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteMultiRegisters(reg_address, DMX_NB_PIX_PER_COL, a_p);
}

/**
 * Reads the values of the feedback algorithm parameter a (A).
 * @param {number} col_p - column number [0, 3].
 * @return {array} a - value of the parameter a (one value per pixel).
 */
function readDMX_a(col_p) {
    const reg_address = ADD_DMX_A | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadMultiRegisters(reg_address, DMX_NB_PIX_PER_COL);
    getLatestValue("DMX_registers");
    return DMX_registers.slice(reg_address, reg_address + DMX_NB_PIX_PER_COL);
}

/**
 * Sets the value of the demux input gain (MUX_SQ_INPUT_GAIN).
 * It is used in all configuration except in AMP SQUID closed loop.
 * @param {number} col_p - column number [0, 3]
 * @param {number} input_gain_p - value of the input gain S(16,12).
 */
function setDMX_sqm_inputGain(col_p, input_gain_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    input_gain_p = input_gain_p * Math.pow(2,12);
    if (input_gain_p > Math.pow(2, 16)) {
        print("ERROR, gain value is too high!  --> " + input_gain_p);
    }
    const reg_address = ADD_DMX_MUX_SQ_INPUT_GAIN | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, input_gain_p);
}

/**
 * Reads the value of the demux input gain (MUX_SQ_INPUT_GAIN).
 * @param {number} col_p - column number [0, 3].
 * @return {number} input_gain - value of the input gain (one value per pixel).
 */
function readDMX_sqm_inputGain(col_p) {
    const reg_address = ADD_DMX_MUX_SQ_INPUT_GAIN | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address] / Math.pow(2,12);
}

/**
 * Sets the value of the demux input gain for AMP SQUID closed loop (AMP_SQ_INPUT_GAIN).
 * It is used for AMP SQUID closed loop only
 * @param {number} col_p - column number [0, 3]
 * @param {number} input_gain_p - value of the input gain S(16,12).
 */
function setDMX_sqa_inputGain(col_p, input_gain_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    input_gain_p = input_gain_p * Math.pow(2,12);
    if (input_gain_p > Math.pow(2, 16)) {
        print("ERROR, gain value is too high!  --> " + input_gain_p);
    }
    const reg_address = ADD_DMX_AMP_SQ_INPUT_GAIN | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, input_gain_p);
}

/**
 * Reads the value of the demux input gain for AMP SQUID closed loop (AMP_SQ_INPUT_GAIN).
 * @param {number} col_p - column number [0, 3].
 * @return {number} input_gain - value of the input gain (one value per pixel).
 */
function readDMX_sqa_inputGain(col_p) {
    const reg_address = ADD_DMX_AMP_SQ_INPUT_GAIN | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address] / Math.pow(2,12);
}

/**
 * Sets the values of ki.knorm for the MUX SQUID closed loop mode (MUX_SQ_KIKNORM).
 * @param {number} col_p - column number [0, 3]
 * @param {array} kiknorm_p - one value of ki.knorm per pixel.
 */
function setDMX_sqm_kiknorm(col_p, kiknorm_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    const reg_address = ADD_DMX_MUX_SQ_KIKNORM | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteMultiRegisters(reg_address, DMX_NB_PIX_PER_COL, kiknorm_p);
}

/**
 * Reads the value of ki.knorm for the MUX SQUID closed loop mode (MUX_SQ_KIKNORM).
 * @param {number} col_p - column number [0, 3].
 * @return {array} kiknorm - value of ki.knorm (one value per pixel).
 */
function readDMX_sqm_kiknorm(col_p) {
    const reg_address = ADD_DMX_MUX_SQ_KIKNORM | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadMultiRegisters(reg_address, DMX_NB_PIX_PER_COL);
    getLatestValue("DMX_registers");
    return DMX_registers.slice(reg_address, reg_address+DMX_NB_PIX_PER_COL);
}

/**
 * Sets the value of ki.knorm for the AMP SQUID closed loop mode (AMP_SQ_KIKNORM).
 * @param {number} col_p - column number [0, 3]
 * @param {number} kiknorm_p - value of ki.knorm.
 */
function setDMX_sqa_kiknorm(col_p, kiknorm_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    const reg_address = ADD_DMX_AMP_SQ_KIKNORM | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, kiknorm_p);
}

/**
 * Reads the value of ki.knorm for the AMP SQUID closed loop mode (AMP_SQ_KIKNORM).
 * @param {number} col_p - column number [0, 3].
 * @return {number} kiknorm - value of the kiknorm (one value per pixel).
 */
function readDMX_sqa_kiknorm(col_p) {
    const reg_address = ADD_DMX_AMP_SQ_KIKNORM | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address];
}

/**
 * Sets the values of knorm for the MUX SQUID closed loop mode (MUX_SQ_KNORM).
 * @param {number} col_p - column number [0, 3]
 * @param {array} knorm_p - one value of knorm per pixel.
 */
function setDMX_sqm_knorm(col_p, knorm_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    const reg_address = ADD_DMX_MUX_SQ_KNORM | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteMultiRegisters(reg_address, DMX_NB_PIX_PER_COL, knorm_p);
}

/**
 * Reads the value of knorm for the MUX SQUID closed loop mode (MUX_SQ_KNORM).
 * @param {number} col_p - column number [0, 3].
 * @return {array} knorm - value of knorm (one value per pixel).
 */
function readDMX_sqm_knorm(col_p) {
    const reg_address = ADD_DMX_MUX_SQ_KNORM | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadMultiRegisters(reg_address, DMX_NB_PIX_PER_COL);
    getLatestValue("DMX_registers");
    return DMX_registers.slice(reg_address, reg_address+DMX_NB_PIX_PER_COL);
}

/**
 * Sets the value of knorm for the AMP SQUID closed loop mode (AMP_SQ_KNORM).
 * @param {number} col_p - column number [0, 3]
 * @param {number} knorm_p - value of knorm.
 */
function setDMX_sqa_knorm(col_p, knorm_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    const reg_address = ADD_DMX_AMP_SQ_KNORM | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, knorm_p);
}

/**
 * Reads the value of knorm for the AMP SQUID closed loop mode (AMP_SQ_KNORM).
 * @param {number} col_p - column number [0, 3].
 * @return {number} knorm - value of knorm (one value per pixel).
 */
function readDMX_sqa_knorm(col_p) {
    const reg_address = ADD_DMX_AMP_SQ_KNORM | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address];
}

/**
 * Sets the values of the default feedback for the MUX SQUID (FB0).
 * @param {number} col_p - column number [0, 3]
 * @param {array} fb0_p - one value of FB0 per pixel.
 */
function setDMX_fb0(col_p, fb0_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    const reg_address = ADD_DMX_MUX_SQ_FB0 | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteMultiRegisters(reg_address, DMX_NB_PIX_PER_COL, fb0_p);
}

/**
 * Reads the value of the default feedback for the MUX SQUID (FB0).
 * @param {number} col_p - column number [0, 3].
 * @return {array} fb0 - value of the default feedback (one value per pixel).
 */
function readDMX_fb0(col_p) {
    const reg_address = ADD_DMX_MUX_SQ_FB0 | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadMultiRegisters(reg_address, DMX_NB_PIX_PER_COL);
    getLatestValue("DMX_registers");
    return DMX_registers.slice(reg_address, reg_address+DMX_NB_PIX_PER_COL);
}

/**
 * Sets the values of the feedbacks lockpoint voltage (MUX_SQ_LOCKPOINT_V).
 * @param {number} col_p - column number [0, 3]
 * @param {array} lockpointV_p - one value of lockpointV per pixel.
 */
function setDMX_lockpointV(col_p, lockpointV_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    const reg_address = ADD_DMX_MUX_SQ_LOCKPOINT_V | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteMultiRegisters(reg_address, DMX_NB_PIX_PER_COL, lockpointV_p);
}

/**
 * Reads the value of the feedbacks lockpoint voltage (MUX_SQ_LOCKPOINT_V).
 * @param {number} col_p - column number [0, 3].
 * @return {array} lockpointV - value of the lockpoint (one value per pixel).
 */
function readDMX_lockpointV(col_p) {
    const reg_address = ADD_DMX_MUX_SQ_LOCKPOINT_V | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadMultiRegisters(reg_address, DMX_NB_PIX_PER_COL);
    getLatestValue("DMX_registers");
    return DMX_registers.slice(reg_address, reg_address+DMX_NB_PIX_PER_COL);
}

/**
 * Sets the MUX SQUID feedback mode (MUX_SQ_FB_MODE).
 * @param {number} col_p - column number [0: Open loop, 1: closed loop, 2 pattern]
 * @param {array} fbMode_p - one value of feedback mode per pixel.
 */
function setDMX_sqm_FBMode(col_p, fbMode_p) {
	var reg_address = ADD_DMX_MUX_SQ_FB_MODE | (col_p << ADD_DMX_COL_BIT_SHIFT);

    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    for (var pix=0; pix < DMX_NB_PIX_PER_COL; pix++) {
        if (fbMode_p[pix] > 2) {
            print("ERROR, unrecognised feedback mode for pixel " + pix + "! > " + fbMode_p[pix]);
            print("Setting the mode to Open loop");
            fbMode_p[pix] = 0;
        }
        sendToDMXWriteRegister(reg_address, fbMode_p[pix]);
        reg_address++;
    }
}

/**
 * Reads the value of the MUX SQUID feedback mode (MUX_SQ_FB_MODE).
 * @param {number} col_p - column number [0, 3].
 * @return {array} fbMode - feedback mode (one value per pixel).
 */
function readDMX_sqm_FBMode(col_p) {
    const reg_address = ADD_DMX_MUX_SQ_FB_MODE | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadMultiRegisters(reg_address, DMX_NB_PIX_PER_COL);
    getLatestValue("DMX_registers");
    return DMX_registers.slice(reg_address, reg_address+DMX_NB_PIX_PER_COL);
}

/**
 * Sets the LSB of the AMP SQUID offset (AMP_SQ_OFFSET_FINE).
 * @param {number} col_p - column number [0, 3]
 * @param {array} offsetFine_p - fine offset: U(3, 0)
 * @param {array} offsetFinePTR_p - fine offset for test pattern: U(3, 0)
 */
function setDMX_sqa_OffsetFine(col_p, offsetFine_p, offsetFinePTR_p) {
    const valMin = 0;
    const valMax = Math.pow(2, 3)-1;
	
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    var values = [DMX_NB_PIX_PER_COL];
    for (var pix=0; pix < DMX_NB_PIX_PER_COL; pix++) {
        // Checking the value of offsetFine
        if ((offsetFine_p[pix] < valMin) || (offsetFine_p[pix] > valMax)) {
            print("ERROR, the fine offset for pixel " + pix + " is incorrect!  > " + offsetFine_p[pix]);
            print("Setting the value to 0 instead");
            offsetFine_p[pix] = 0;
        }
        // Checking the value of offsetFinePTR
        if ((offsetFinePTR_p[pix] < valMin) || (offsetFinePTR_p[pix] > valMax)) {
            print("ERROR, the fine offset PTR for pixel " + pix + " is incorrect!  > " + offsetFinePTR_p[pix]);
            print("Setting the value to 0 instead");
            offsetFinePTR_p[pix] = 0;
        }
        values[pix] = (offsetFinePTR_p[pix] << 3) | offsetFine_p[pix];
    }
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_FINE | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteMultiRegisters(reg_address, DMX_NB_PIX_PER_COL, values);
}

/**
 * Reads the LSB of the AMP SQUID offset (AMP_SQ_OFFSET_FINE).
 * @param {number} col_p - column number [0, 3]
 * @return {{std: number[], ptr: number[]}} offsetFine - fine offset: U(3, 0)
 * @return {array} offsetFinePTR - fine offset for test pattern: U(3, 0)
 */
function readDMX_sqa_OffsetFine(col_p) {
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_FINE | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadMultiRegisters(reg_address, DMX_NB_PIX_PER_COL);
    getLatestValue("DMX_registers");
    const data = DMX_registers.slice(reg_address, reg_address+DMX_NB_PIX_PER_COL);
    var sqaOffsetFine = [DMX_NB_PIX_PER_COL];
    var sqaOffsetFinePTR = [DMX_NB_PIX_PER_COL];
    for (var pix=0; pix < DMX_NB_PIX_PER_COL; pix++) {
        sqaOffsetFine[pix] = data[pix] % Math.pow(2, 3);
        sqaOffsetFinePTR[pix] = data[pix] >> 3;
    }
	return [sqaOffsetFine, sqaOffsetFinePTR];
}

/**
 * Sets the weight of the LSB of the AMP SQUID offset for test patterns (AMP_SQ_OFFSET_LSB_PTR).
 * @param {number} col_p - column number [0, 3]
 * @param {number} offsetLSBptr_p - weight of the offset LSB: U(12, 0)
 */
function setDMX_sqa_OffsetLSBptr(col_p, offsetLSBptr_p) {
	const valMin = 0;
	const valMax = Math.pow(2, 12)-1;
	
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    if ((offsetLSBptr_p < valMin ) || (offsetLSBptr_p > valMax)) {
        print("ERROR, the weight of the LSB is incorrect! > " + offsetLSBptr_p);
        return;
    }
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_LSB_PTR | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, offsetLSBptr_p);
}

/**
 * Reads the weight of the LSB of the AMP SQUID offset for test patterns (AMP_SQ_OFFSET_LSB_PTR).
 * @param {number} col_p - column number [0, 3]
 * @return {number} sqaOffsetLSB - weight of the offset LSB.
 */
function readDMX_sqa_OffsetLSBptr(col_p) {
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_LSB_PTR | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address];
}

/**
 * Sets the weight of the LSB of the AMP SQUID offset (AMP_SQ_OFFSET_LSB).
 * @param {number} col_p - column number [0, 3]
 * @param {number} offsetLSB_p - weight of the offset LSB: U(12, 0)
 */
function setDMX_sqa_OffsetLSB(col_p, offsetLSB_p) {
    const valMin = 0;
    const valMax = Math.pow(2, 12)-1;

    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    if ((offsetLSB_p < valMin ) || (offsetLSB_p > valMax)) {
        print("ERROR, the weight of the LSB is incorrect! > " + offsetLSB_p);
        return;
    }
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_LSB | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, offsetLSB_p);
}

/**
 * Reads the weight of the LSB of the AMP SQUID offset (AMP_SQ_OFFSET_LSB).
 * @param {number} col_p - column number [0, 3]
 * @return {number} sqaOffsetLSB - weight of the offset LSB.
 */
function readDMX_sqa_OffsetLSB(col_p) {
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_LSB | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address];
}

/**
 * Sets common coarse offset for the AMP SQUID (AMP_SQ_OFFSET_COARSE).
 * @param {number} col_p - column number [0, 3]
 * @param {number} offsetCoarse_p - common AMP SQUID coarse offset : U(12, 0)
 */
function setDMX_sqa_OffsetCoarse(col_p, offsetCoarse_p) {
    const valMin = 0;
    const valMax = Math.pow(2, 12)-1;

    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    if ((offsetCoarse_p < valMin ) || (offsetCoarse_p > valMax)) {
        print("ERROR, the common coarse offset is incorrect! > " + offsetCoarse_p);
        return;
    }
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_COARSE | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, offsetCoarse_p);
}

/**
 * Reads the common coarse offset for the AMP SQUID (AMP_SQ_OFFSET_COARSE).
 * @param {number} col_p - column number [0, 3]
 * @return {number} offsetCoarse -  common AMP SQUID coarse offset.
 */
function readDMX_sqa_OffsetCoarse(col_p) {
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_COARSE | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address];
}

/**
 * Sets the feedback delay (MUX_SQ_FB_DELAY).
 * @param {number} col_p - column number [0, 3]
 * @param {number} feedback_delay_p - feedback delay (number of periods of 125MHz clock): S(10, 0)
 */
function setDMX_feedback_delay(col_p, feedback_delay_p) {
    const valMin = -512;
    const valMax = 40;
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    if ((feedback_delay_p < valMin ) || (feedback_delay_p > valMax)) {
        print("ERROR, the feedback delay is incorrect! > " + feedback_delay_p);
        return;
    }
    const val = convert_sInt_to_2compInt(feedback_delay_p, 10);
    const reg_address = ADD_DMX_MUX_SQ_FB_DELAY | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, val);
}

/**
 * Reads the feedback delay (MUX_SQ_FB_DELAY).
 * @param {number} col_p - column number [0, 3]
 * @return {number} feedback_delay - delay of the feedback signal.
 */
function readDMX_feedback_delay(col_p) {
    const reg_address = ADD_DMX_MUX_SQ_FB_DELAY | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return convert_2compInt_to_sInt(DMX_registers[reg_address],10);
}

/**
 * Sets the offset DAC delay (AMP_SQ_OFFSET_DAC_DELAY).
 * @param {number} col_p - column number [0, 3]
 * @param {number} offsetDAC_delay_p - offset/DAC delay (number of periods of 125MHz clock): U(10, 0)
 */
function setDMX_offsetDAC_delay(col_p, offsetDAC_delay_p) {
    const valMin = 0;
    const valMax = Math.pow(2, 10)-1;
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    if ((offsetDAC_delay_p < valMin ) || (offsetDAC_delay_p > valMax)) {
        print("ERROR, the offset DAC delay is incorrect! > " + offsetDAC_delay_p);
        return;
    }
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_DAC_DELAY | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, offsetDAC_delay_p);
}

/**
 * Reads the offset DAC delay (AMP_SQ_OFFSET_DAC_DELAY).
 * @param {number} col_p - column number [0, 3]
 * @return {number} offsetDAC_delay - offset/DAC delay.
 */
function readDMX_offsetDAC_delay(col_p) {
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_DAC_DELAY | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address];
}

/**
 * Sets the offset MUX delay (AMP_SQ_OFFSET_MUX_DELAY).
 * @param {number} col_p - column number [0, 3]
 * @param {number} offsetMUX_delay_p - offset/MUX delay (number of periods of 125MHz clock): S(10, 0)
 */
function setDMX_offsetMUX_delay(col_p, offsetMUX_delay_p) {
    const valMin = -512;
    const valMax = 40;
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    if ((offsetMUX_delay_p < valMin ) || (offsetMUX_delay_p > valMax)) {
        print("ERROR, the offset MUX delay is incorrect! > " + offsetMUX_delay_p);
        return;
    }
    const val = convert_sInt_to_2compInt(offsetMUX_delay_p, 10);
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_MUX_DELAY | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, val);
}

/**
 * Reads the offset MUX delay (AMP_SQ_OFFSET_MUX_DELAY).
 * @param {number} col_p - column number [0, 3]
 * @return {number} offsetMUX_delay - offset/MUX delay.
 */
function readDMX_offsetMUX_delay(col_p) {
    const reg_address = ADD_DMX_AMP_SQ_OFFSET_MUX_DELAY | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return convert_2compInt_to_sInt(DMX_registers[reg_address], 10);
}

/**
 * Sets the sampling delay (SAMPLING_DELAY).
 * @param {number} col_p - column number [0, 3]
 * @param {number} sampling_delay_p - sampling delay (number of periods of 125MHz clock): U(5, 0)
 */
function setDMX_sampling_delay(col_p, sampling_delay_p) {
    const valMin = 0;
    const valMax = 19;
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    if ((sampling_delay_p < valMin ) || (sampling_delay_p > valMax)) {
        print("ERROR, the sampling delay is incorrect! > " + sampling_delay_p);
        return;
    }
    const reg_address = ADD_DMX_SAMPLING_DELAY | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, sampling_delay_p);
}

/**
 * Reads the sampling delay (SAMPLING_DELAY).
 * @param {number} col_p - column number [0, 3]
 * @return {number} sampling_delay - sampling delay.
 */
function readDMX_sampling_delay(col_p) {
    const reg_address = ADD_DMX_SAMPLING_DELAY | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address];
}

/**
 * Sets the values of a set of pulse shaping (PULSE_SHAPING).
 * @param {number} col_p - column number [0, 3]
 * @param {number} setId_p - id of the set of values [0; 3].
 * @param {array} values_p - a set of pulse shaping parameters U(16,16)
 */
function setDMX_pulseShapingSet(col_p, setId_p, values_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    if (values_p.length !== DMX_PULSESHAPING_NBVALUES) {
        print("ERROR, the number of values is incorrect!  -->  " + values_p.length);
        return;
    }
    if (setId_p > 3) {
        print("ERROR, the pulse shaping set number is incorrect!  -->  " + setId_p);
        return;
    }
    const reg_address = ADD_DMX_PULSE_SHAPING[setId_p] | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteMultiRegisters(reg_address, DMX_PULSESHAPING_NBVALUES, values_p);
}

/**
 * Sets the values of the 4 sets of pulse shaping (PULSE_SHAPING).
 * @param {number} col_p - column number [0, 3]
 * @param {array} values_p - 4 sets of pulse shaping parameters U(16,16)
 */
function setDMX_pulseShaping(col_p, values_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    if (values_p.length !== 4) {
        print("ERROR, the number of sets is incorrect!  -->  " + values_p.length);
        return;
    }
    for (var set=0; set<4; set++) {
        setDMX_pulseShapingSet(col_p, set, values_p[set]);
    }
}

/**
 * Reads the values of a set of pulse shaping (PULSE_SHAPING).
 * @param {number} col_p - column number [0, 3]
 * @param {number} setId_p - id of the set of values [0; 3].
 * @return {array} values - a set of pulse shaping parameters.
 */
function readDMX_pulseShapingSet(col_p, setId_p) {
    const reg_address = ADD_DMX_PULSE_SHAPING[setId_p] | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadMultiRegisters(reg_address, DMX_PULSESHAPING_NBVALUES);
    getLatestValue("DMX_registers");
    return DMX_registers.slice(reg_address, reg_address + DMX_PULSESHAPING_NBVALUES);
}

/**
 * Reads the values of the 4 sets of pulse shaping (PULSE_SHAPING).
 * @param {number} col_p - column number [0, 3]
 * @return {array} values - 4 sets of pulse shaping parameters.
 */
function readDMX_pulseShaping(col_p) {
    var values = [];
    for (set=0; set<4; set++) {
        values[set] = readDMX_pulseShapingSet(col_p, set);
    }
    return values;
}

/**
 * Selects a set of pulse shaping (PULSE_SHAPING_SELECTION).
 * @param {number} col_p - column number [0, 3]
 * @param {number} setId_p - id of the set of values [0; 3].
 */
function setDMX_pulseShapingSelection(col_p, setId_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    if (setId_p > 3) {
        print("ERROR, the pulse shaping set number is incorrect! >  " + setId_p);
        return;
    }
    const reg_address = ADD_DMX_PULSE_SHAPING_SELECTION | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, setId_p);
}

/**
 * Reads the set of pulse shaping (PULSE_SHAPING_SELECTION).
 * @param {number} col_p - column number [0, 3]
 * @return {number} setId - sampling delay.
 */
function readDMX_pulseShapingSelection(col_p) {
    const reg_address = ADD_DMX_PULSE_SHAPING_SELECTION | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address];
}

/**
 * Sets the relock delay (RELOCK_DELAY).
 * @param {number} col_p - column number [0, 3]
 * @param {number} relock_delay_p - delay of the relock algorithm (number of periods of frame clock): U(16, 0)
 */
function setDMX_relock_delay(col_p, relock_delay_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    const reg_address = ADD_DMX_RELOCK_DELAY | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, relock_delay_p);
}

/**
 * Reads the relock delay (RELOCK_DELAY).
 * @param {number} col_p - column number [0, 3]
 * @return {number} relock_delay - delay of the relock algorithm (number of periods of frame clock).
 */
function readDMX_relock_delay(col_p) {
    const reg_address = ADD_DMX_RELOCK_DELAY | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address];
}

/**
 * Sets the relock threshold (RELOCK_THRESHOLD).
 * @param {number} col_p - column number [0, 3]
 * @param {number} relock_threshold_p - threshold of the relock algorithm: U(16, 2)
 */
function setDMX_relock_threshold(col_p, relock_threshold_p) {
    if ((col_p < 0) || (col_p > DMX_NB_COL-1)) {
        print("ERROR, column number is incorrect!  --> " + col_p);
        return;
    }
    const reg_address = ADD_DMX_RELOCK_THRESHOLD | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXWriteRegister(reg_address, relock_threshold_p);
}

/**
 * Reads the relock threshold (RELOCK_THRESHOLD).
 * @param {number} col_p - column number [0, 3]
 * @return {number} relock_threshold - delay of the relock algorithm (number of periods of frame clock).
 */
function readDMX_relock_threshold(col_p) {
    const reg_address = ADD_DMX_RELOCK_THRESHOLD | (col_p << ADD_DMX_COL_BIT_SHIFT);
    sendToDMXReadRegister(reg_address);
    getLatestValue("DMX_registers");
    return DMX_registers[reg_address];
}

/**
 * Reads the status.
 * @param {boolean} verbose_p - verbosity level (true to display messages).
 * @return {number} SPIstatus - status of the last command.
 */
function readDMX_SPIstatus(verbose_p) {
    sendToDMXReadRegister(ADD_DMX_STATUS);
    getLatestValue("DMX_registers");
    const SPIstatus = DMX_registers[ADD_DMX_STATUS];
    if (verbose_p) print("DEMUX SPI status is: " + to_hexaString(SPIstatus));
    return SPIstatus;
}

/**
 * Reads the firmware version.
 * @param {boolean} verbose_p - verbosity level (true to display messages).
 * @return {number} firmwareVersion - version of the firmware.
 */
function readDMX_firmwareVersion(verbose_p) {
    if (typeof(verbose_p) === 'undefined') verbose_p = false;
    sendToDMXReadRegister(ADD_DMX_FIRMWARE_VERSION);
    getLatestValue("DMX_registers");
    const firmwareVersion = DMX_registers[ADD_DMX_FIRMWARE_VERSION];
    if (verbose_p) print("DEMUX firmware version is: " + to_hexaString(firmwareVersion));
    return firmwareVersion;
}

/**
 * Reads the hardware version.
 * @param {boolean} verbose_p - verbosity level (true to display messages).
 * @return {array} model reference, board reference.
 */
function readDMX_hardwareVersion(verbose_p) {
    if (typeof(verbose_p) === 'undefined') verbose_p = false;
    sendToDMXReadRegister(ADD_DMX_HARDWARE_VERSION);
    getLatestValue("DMX_registers");
    const hardwareVersion = DMX_registers[ADD_DMX_HARDWARE_VERSION];
    const modelReference = (hardwareVersion >> 8) & 0x7;
    const boardReference = hardwareVersion & 0x1F;
    if (verbose_p) {
        print("DEMUX hardware version is:");
        print(TABUL + "Model reference: " + DMX_MODEL_VERSION[modelReference]);
        print(TABUL + "Board reference: " + to_hexaString(boardReference));
    }
	return [modelReference, boardReference];
}

/**
 * Reads the housekeepings.
 * @param {boolean} verbose_p - verbosity level (true to display messages).
 * @return {array} houseKeepings - housekeepings.
 */
function readDMX_HK(verbose_p) {
    if (typeof(verbose_p) === 'undefined') verbose_p = false;
    sendToDMXReadMultiRegisters(ADD_DMX_HK_P5V0_ANA, DMX_NB_HK);
    getLatestValue("DMX_registers");
    const houseKeepings = DMX_registers.slice(ADD_DMX_HK_P5V0_ANA, ADD_DMX_HK_P5V0_ANA+DMX_NB_HK);
    if (verbose_p) {
        print("DEMUX HK are:");
        for (var hk=0; hk<DMX_NB_HK; hk++) print(TABUL + DMX_HK_NAMES[hk] + ": " + houseKeepings[hk]);
    }
    return houseKeepings;
}

/**
 * HK conversion formula for positive HK with buffer and dividers.
 * @param {number} HKADU - HK value in ADU
 * @param {number} FSRRatio - FSR Volatge over FSR ADU.
 * @param {number} R1 - Resistance 1
 * @param {number} R2 - Resistance 2
 * return {number} HKeng - Engineering value of the HK
 */
function positiveHKBufferAndDivider(HKADU, FSRRatio, R1, R2) {
    return FSRRatio * HKADU * (R1 + R2) / R1;
}

/**
 * HK conversion formula for positive HK (non inverter)
 * @param {number} HKADU - HK value in ADU
 * @param {number} FSRRatio - FSR Volatge over FSR ADU.
 * @param {number} RF - Resistance F
 * @param {number} RG - Resistance G
 * return {number} HKeng - Engineering value of the HK
 */
function positiveHKNonInverter(HKADU, FSRRatio, RF, RG) {
    return FSRRatio * HKADU / (1 + RF / RG);
}

/**
 * HK conversion formula for negative HK (inverter)
 * @param {number} HKADU - HK value in ADU
 * @param {number} FSRRatio - FSR Volatge over FSR ADU.
 * @param {number} RF - Resistance F
 * @param {number} RG - Resistance G
 * return {number} HKeng - Engineering value of the HK
 */
function negativeHKInverter(HKADU, FSRRatio, RF, RG) {
    return FSRRatio * HKADU / (-RF / RG);
}

/**
 * HK conversion formula for temperatures
 * @param {number} HKADU - HK value in ADU
 * @param {number} FSRRatio - FSR Volatge over FSR ADU.
 * return {number} HKeng - Engineering value of the HK
 */
function temperatureHK(HKADU, FSRRatio) {
    const Tmin = -40;
    const Tmax = + 60;
    const Vmin = 0.1;
    const Vmax = 3.2;
    const a =  (Vmax - Vmin) / (Tmax - Tmin);
    const b = Vmin - a * Tmin;

    return (FSRRatio * HKADU - b) / a;
}

/**
 * Prints the converted values of the housekeepings.
 * @param {array} hk_p - housekeepings.
 */
function convertDMX_HK(hk_p) {
    const VFSR = 3.3;
    const ADUFSR = Math.pow(2, 12);
    const FSRVoverADU = VFSR / (ADUFSR - 1);

    plotSmallLine();

    // Temperatures
    const hkTemp = [9, 10];
    for (var iHK = 0; iHK < hkTemp.length; iHK++) {
        var hkEng = temperatureHK(hk_p(iHK), FSRVoverADU);
        var hkEngTxt = ("        " +(hkEng).toString()).slice(-8);
        print(TAB2 + DMX_HK_NAMES[iHK] + ": " + hkEngTxt + DMX_HK_UNITS[iHK]);
    }

    // Positive housekeepings with buffer and divider
    const hkPosBuffAndDiv = [0, 1, 2, 3, 6, 7, 11, 12, 13];
    const R1PosBuffAndDiv = [28000, 34800, 49900, 162000, 34800, 49900, 49900, 49900, 34800];
    const R2PosBuffAndDiv = [56200, 34800, 28000,  20300, 34800, 28000, 28000, 28000, 34800];
    for (var iHK = 0; iHK < hkPosBuffAndDiv.length; iHK++) {
        var hkEng = positiveHKBufferAndDivider(hk_p(iHK), FSRVoverADU, R1PosBuffAndDiv[iHK], R2PosBuffAndDiv[iHK]);
        var hkEngTxt = ("        " +(hkEng).toString()).slice(-8);
        print(TAB2 + DMX_HK_NAMES[iHK] + ": " + hkEngTxt + DMX_HK_UNITS[iHK]);
    }

    // Positive housekeepings (non inverter)
    const hkPosNonInv = [8];
    const RFPosNonInv = [17800];
    const RGPosNonInv = [56200];
    for (var iHK = 0; iHK < hkPosNonInv.length; iHK++) {
        var hkEng = positiveHKNonInverter(hk_p(iHK), FSRVoverADU, RFPosNonInv[iHK], RGPosNonInv[iHK]);
        var hkEngTxt = ("        " +(hkEng).toString()).slice(-8);
        print(TAB2 + DMX_HK_NAMES[iHK] + ": " + hkEngTxt + DMX_HK_UNITS[iHK]);
    }

    // Negative housekeepings (inverter)
    const hkNegInv = [4, 5];
    const RFNegInv = [17800, 17800];
    const RGNegInv = [28000, 56200];
    for (var iHK = 0; iHK < hkNegInv.length; iHK++) {
        var hkEng = negativeHKInverter(hk_p(iHK), FSRVoverADU, RFNegInv[iHK], RGNegInv[iHK]);
        var hkEngTxt = ("        " +(hkEng).toString()).slice(-8);
        print(TAB2 + DMX_HK_NAMES[iHK] + ": " + hkEngTxt + DMX_HK_UNITS[iHK]);
    }
    plotSmallLine();
}

/**
 * Reads the delock flag (DELOCK_FLAG).
 * @param {boolean} verbose_p - verbosity level (true to display messages).
 * @return {number} delockFlag - delock flag.
 */
function readDMX_delockFlag(verbose_p) {
    if (typeof(verbose_p) === 'undefined') verbose_p = false;
    sendToDMXReadRegister(ADD_DMX_DELOCK_FLAG);
    getLatestValue("DMX_registers");
    const delockFlag = DMX_registers[ADD_DMX_DELOCK_FLAG];
    if (verbose_p) print("Delock flag is: " + to_hexaString(delockFlag));
    return delockFlag;
}

// -------------------------------------------------------------------------------------------------------------